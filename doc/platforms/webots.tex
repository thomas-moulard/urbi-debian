%% Copyright (C) 2009-2010, Gostai S.A.S.
%%
%% This software is provided "as is" without warranty of any kind,
%% either expressed or implied, including but not limited to the
%% implied warranties of fitness for a particular purpose.
%%
%% See the LICENSE file for more information.

% \begin{attribute}{name}{permissions}{type}{range}
%   Documentation.
% \end{attribute}
\newenvironment{attribute}[4]
{
  % Because of a bug in TeX4HT, we cannot use this embedded \item (in
  % the output, it keeps on embedding descriptions within
  % descriptions).
  %
  % When fixed, we can restore this \item, and remove all the ones
  % that were added before each \begin{attribute}.
  %
  % \item \lstinline|#1|
    \begin{description}
    \item[Permissions] #2.
    \item[Type] #3.
      \ifx#4\empty\else
    \item[Range] #4.
      \fi
    \item[Description]
}{
    \end{description}
}

\chapter{Webots}
\label{sec:webots}

This chapter documents the use of \urbi in the \webots simulation
environment.

\section{Setup}

This section describes how to setup the software on your computer and
give you the basis to use \uwebots{}.

\subsection{Installation}

The setup process depends on your OS, please follow the corresponding
instructions.

\subsubsection{Linux}

To install \uwebots{} in your \webots{} on Linux, you must download an
archive of the form
\file{urbi-for-webots-\var{version}-linux-x86-gcc4-release.tar.bz2}.
You may choose an other archive format than \texttt{.tar.bz2}, but you
will need to slightly adjust the following instruction accordingly.

The archive is structured to blend into the \webots hierarchy, as
follow:

\begin{itemize}
\item
  \file{urbi-for-webots-\var{version}/projects/default/controllers/urbi2.0/}\\
  \usdk and \webots{} controller.
\item \file{urbi-for-webots-\var{version}/projects/packages/urbi2.0/share/robot-name/}\\ Shared
  \us{} robot behaviors.
\item \file{urbi-for-webots-\var{version}/projects/packages/urbi2.0/controllers/robot-name/}\\
  Demonstration controllers for each robot.
\item \file{urbi-for-webots-\var{version}/projects/packages/urbi2.0/worlds/}\\ Demonstration
  worlds.
\end{itemize}

All you need to do is extract it into your \webots directory, minus the
\texttt{urbi-for-webots-\var{version}} containing directory, so as to
merge the packaged \texttt{project} directory with your \webots{}'
\texttt{project} directory.

This can be easily done with the following \texttt{tar} command:

\begin{shell}
tar -xvjf urbi-for-webots.tar.bz2 -C /path/to/webots --strip-components 1
\end{shell}

Otherwise, you can also merge the directory after extracting the archive:

\begin{shell}
cp --archive urbi-for-webots/project /path/to/webots
\end{shell}

You can check your installation works correctly by starting a test world:

\begin{shell}
cd /path/to/webots
./webots projects/packages/urbi2.0/worlds/aibo-ball-tracking.wbt
\end{shell}

You should see an \aibo{} looking at a moving ball.

\subsubsection{\macosx{}}

\uwebots{} is not available under \macosx{} anymore for now. We hope to
fix this very shortly.

%% You have to be administrator on your machine in order to install \urbi
%% for Webots.  Extract the zip file containing \urbi by double clicking
%% on it.  You obtain two folders: \file{usr} and \file{webots}.  Copy
%% the contents of the \file{webots} directory in the directory
%% containing Webots installation (if you did the default installation it
%% is in \file{/Applications/Webots}), and copy the contents of the
%% \file{usr} folder in the \file{/usr} system folder.

%% If, for instance, you extracted the zip file in your \file{Desktop}
%% folder, and that you have set the variable \env{WEBOTS\_HOME} to the
%% Webots installation path as explained in Webots documentation.  From a
%% shell terminal this gives you:

%% \begin{shell}
%% $ cd $HOME/Desktop
%% $ ls
%% usr webots
%% webots-urbiengine-sdk-webots-1.03-k1462-e247-l482-powerpc-apple-darwin8-gcc-4.0.1.zip
%% $ cp -r usr /
%% $ cp -r webots/* $WEBOTS_HOME/
%% \end{shell}

\subsubsection{Windows}

\uwebots{} is not available under windows anymore for now. We hope to
fix this very shortly.

%% \paragraph{Installation}

%% To install \urbi for Webots under windows, Webots must be installed on
%% your computer. If Webots is not installed, please first proceed to
%% Webots installation. Then double click on the ``\urbi Webots 1.0
%% Setup.exe'' and follow the instructions given by the installer:

%% \begin{enumerate}
%% \item The installer recommends to close all other running applications
%%   while installing \urbi for Webots. Click ``Next $>$'' to proceed.

%% \item Before installing \urbi for Webots, read and accept the Licence
%%   Agreement. Once you have read it, check ``I accept the agreement'' and
%%   click on ``Next $>$'' to proceed.

%% \item The installer will automatically detect your Webots installation
%%   path and install the \urbi controller, the worlds and data in the
%%   same location. For all the other files (\urbi for Webots SDK and
%%   \urbi for Webots Documentation) you have to provide a new
%%   location. This is what the installer is asking at this step. Choose
%%   a custom location if you don't want the default one,
%%   \verb+C:\Program Files\Gostai\Urbi Webots 1.0+, and click
%%   ``Next $>$'' to proceed.

%% \item In this step you can choose which features will be installed on
%%   your computer. Required features (``\urbi Webots'') cannot be
%%   unchecked. These are the \urbi controller and the Urbi for Webots
%%   worlds and data. They will be installed in your Webots installation
%%   directory. Optional features are the ``\urbi Software Development
%%   Kit'', useful if you want to develop your own UObjects and plug them
%%   in \urbi, and the ``\urbi Documentation''. Optional features will be
%%   installed in the location you provided at Step 3).  Check the
%%   checkbox near the features you want to install, and click ``Next $>$''
%%   to proceed to next step.

%% \item You can customize the location where shortcuts to \urbi files
%%   will be installed in you Start Menu. You can choose not to put any
%%   shortcuts just by checking ``Don't create a start menu folder''. Click
%%   ``Next $>$'' to proceed to next step.

%% \item \urbi source code files have a ``.u'' extension. By default the
%%   installer associate all ``.u'' files with \urbi. If you don't want
%%   these files to be associated unckeck the corresponding
%%   checkbox. Then click ``Next $>$'' to proceed to next step.

%% \item The installer prints a summary of the installation options for
%%   you to verify that it is correct. Then click ``Install'' to install
%%   \urbi for webots on your computer.

%% \item The installer display the README file. Click ``Next $>$'' to
%%   proceed to next step.

%% \item You have finished to install \urbi for Webots. Click ``Finish'' to
%%   close the installer.
%% \end{enumerate}

\subsection{License}

\subsubsection{Evaluation mode}

If you don't provide a valid license file to the \urbi controller, it
will be launched in \dfn{evaluation mode}. The only difference with
the normal version is that the controller will exit after five
minutes, thus letting you test all the features of the registered
version during this amount of time. In evaluation mode, the \urbi
controller will display the following message in the \webots console:

\begin{lstlisting}
**************************************************
* URBI: Invalid or missing license.
* Urbi for Webots will quit after five minutes.
**************************************************
\end{lstlisting}

In order to run \uwebots without constraints you must provide it with a
license file, as described in the following section.

\subsubsection{Setting up a license}
\newcommand{\webotskey}{\file{webots.key}\xspace}
\newcommand{\urbikey}{\file{urbi.key}\xspace}
\newcommand{\webotskeydir}{\file{webots/resources/}\xspace}
\newcommand{\contactemail}{\email{contact@gostai.com}\xspace}
\newcommand{\webotsworldsdir}{\file{projects/packages/urbi2.0/worlds/}\xspace}

Providing a valid \uwebots license will enable you to run \urbi
controllers for an unlimited amount of time. The license is a file
named \urbikey. You simply need copy it in the
\webotskeydir directory of your \webots installation.

The \uwebots licensing system is based on the \webots licensing
system: your \uwebots key is attached to your \webots key. The
procedure will depend on whether your \webots license is based on a
\webotskey file or an USB dongle.

If you have any problem setting up your \uwebots license, feel free to
contact us at \contactemail.

\paragraph{Urbi licensing with a \webotskey \webots license:}

If you use a file-based \webots license, please send us your
\webotskey on \contactemail so as we can generate your \urbikey. In
this case, you need to put your \webotskey together with your \urbikey
in the \webotskeydir directory.

\paragraph{Urbi licensing with an USB dongle \webots license:}

If you use an USB dongle based license, please send us your dongle
number available in the help/about \webots menu to \contactemail so as
we can generate your \urbikey.

\section{Using \urbi as a controller in your \webots worlds}

This section will show you how to control your own simulation with
\urbi controllers.

A robot controlled by \urbi in \webots uses a controller which is
actually a standard \urbi server, with custom UObjects plugged
in. This mean you can connect to the \urbi server and interact with
the robot just like you would with the actual \urbi server of the
robot. Note however that since the \urbi server is started by webots,
we have no way to interact with it on the standard input, and need to
connect to it via the network. Please refer to
\autoref{sec:tut:started} to learn how to interact with an \urbi
server via the network.

You can try it out with one of the bundled demonstration worlds. For
instance, run in \webots the \file{aibo-ball-tracking.wbt} world
located in the \webotsworldsdir. You can then connect on the 54000
port and control the \aibo like a regular one.

\subsection{Using the default urbi-2.0 controller}

To use an urbi controller in your \webots world, first define an
\verb+urbi-2.0+ controller for your webots node:

\begin{lstlisting}
DEF MYNODE Robot
{
  ...
  controller "urbi-2.0"
}
\end{lstlisting}

This will start an \urbi server to interact with your robot. This
server is however useless since it doesn't run any specific behavior
and you cannot interact with it. You can ask the \urbi server to
listen for incoming connection, so as you can connect to it and
control the robot interactively. You can also load \us files in the
server to run them at start-up. You can of course do both.

To do this, simply pass arguments to the controller with the
\verb+controllerArgs+ \webots attribute. Available arguments are the
exact same as the \verb+urbi+ program, as described in
\autoref{sec:tools:urbi}.

\paragraph{Listening for incoming connections:} pass a \verb+--port+
option to the controller.

\begin{lstlisting}
DEF MYNODE Robot
{
  ...
  controller "urbi-2.0"
  controllerArgs "--port 54000"
}
\end{lstlisting}

\paragraph{Loading an \us file:} pass a \verb+--file+ option to the
controller. In addition to standard directories, scripts are also
searched in the \file{projects/packages/urbi-2.0/share/} directory of
your webots installation. For instance, you could create a
\file{my\_behavior/my\_script.u} script in this directory, and use the
following \verb+controllerArgs+.

\begin{lstlisting}
DEF MYNODE Robot
{
  ...
  controller "urbi-2.0"
  controllerArgs "--file my_behavior/my_script.u"
}
\end{lstlisting}

\subsection{Defining custom \urbi controllers}

A different approach would be to define your own \urbi-based
controller. If you create a controller in \webots' controllers
directory and create a \file{global.u} file in it, \webots will
automatically recognize it as an \urbi controller and start the
\file{urbi-2.0} controller. The \file{global.u} and potential
\file{local.u} will be automatically loaded by the \urbi kernel, as
documented in \autoref{sec:tools:files}.

This approach is equivalent to using the default \file{urbi-2.0}
controller and passing it file to load, but enables you to define
custom, reusable controllers for your robots. For instance, you could
create a \file{my-project/controllers/my-robot/} controller, with a
\file{global.u} file in it that load all your robots objects (motors,
sensors, \ldots). To use an \urbi controller for your robot, you would
then simply have to use \lstinline+controller "my-robot"+ in your
world file. If you used the default \file{urbi-2.0} controller, you
would have to add

\lstinline+controllerArgs "--file some-dir/my-robot-bindings.u"+

\noindent
to get a functional controller for your robot.

\section{Binding your own robots with \uwebots}

Binding your own robot model with \uwebots is extremely similar to
binding an actual robot with \urbi, except the UObjects (device
drivers) are already written for \webots generic devices. It thus
mainly consists in writing an initialization \us file that instantiate
those \urbi objects for your robots devices (motors, sensors,
\ldots). For instance, a binding for a minimalist robot that only has
a servomotor and a distance sensor could be:

\begin{urbiunchecked}
var motor = Servo.new("webots_motor_node_name");
var distance = DistanceSensor.new("webots_sensor_node_name");
\end{urbiunchecked}

Note that, whenever possible, your \webots binding should be strictly
identical to the actual robot binding (if any) so as the same \urbi
code will work in the simulator and in reality. Additionally, you
should whenever possible respect the \gsrapi (see
\autoref{sec:naming}) to be compatible with standard \urbi components.

\section{Built-in robots and worlds}

\uwebots comes with several built-in demonstration robots and
worlds. Every included robot has a binding file named
\file{projects/packages/urbi-2.0/share/robot-name/robot-name.u} and a
custom controller located in
\file{projects/packages/urbi-2.0/controllers} whose \file{global.u}
start-up file loads the binding. Thus, using \lstinline+controller "robot-name"+
in the webots world file automatically starts an \urbi
kernel with the right binding to control the robot.

Here is a description of the built-in worlds:

\begin{itemize}
\item \file{aibo-ball-tracking.wbt}\\
  This world demonstrates the \urbi classical \aibo ball tracking
  behavior. It uses two \urbi controllers:
  \begin{itemize}
  \item The first one controls the \aibo and runs the tracking
    behavior. It uses the \file{aibo} controller and the
    \file{aibo/ball-tracking.u} script. You can connect to this
    controller on port 54000.
  \item The second controls the ball. It uses the generic
    \file{urbi-2.0} controller and moves the ball around automatically
    with the \file{aibo/move-ball.u} script thanks to the supervisor
    API (see \autoref{sec:webots:supervisor}).
  \end{itemize}
\item \file{aibo-soccer.wbt}\\
  This empty world simply provide and \aibo on a soccer field with a
  ball. It uses the \file{aibo} controller. You can connect to it on
  the 54000 port to control the \aibo or program behaviors.
\item \file{e-puck-wander.wbt}\\
  This world presents an e-puck robot wandering around randomly. It
  uses the \file{e-puck} controller and the \file{e-puck/wander.u}
  script for the wandering behavior. You can connect to it on port
  54000.
\item \file{pioneer-wander.wbt}\\
  This world presents a Pioneer robot wandering around randomly. It
  uses the \file{pioneer} controller and the \file{pioneer/wander.u}
  script for the wandering behavior. You can connect to it on port
  54000.
\end{itemize}

\section{\webots UObjects}

\subsection{Robot devices UObjects}

These uobjects are the \urbi API for \webots robots devices such as
motors or sensors. They all implement at least an interface from the
\gsrapi (see \autoref{sec:naming}). Please refer to these interfaces
to discover most functionalities of the object. Only additional slots
are documented here.

All objects are constructed with a \verb+node_name+ argument, which is
the name of the corresponding node in the \webots world.

\subsubsection{Accelerometer}

While \webots accelerators all have three components, \urbi prefer to
differentiate every component in one linear accelerometer.

\paragraph{Gostai Standard Robotic API interface:} \refFacet{AccelerationSensor}

\paragraph{Constructor:} Accelerometer.new(\var{node\_name}, \var{component\_name})

\begin{itemize}
\item \var{node\_name} Name of the \webots node.
\item \var{component\_name} The component of the \webots accelerometer
  to use. Must be \verb+"x"+, \verb+"y"+ or \verb+"z"+.
\end{itemize}

\paragraph{Note:} Since there is only one device for the three
components in \webots, disabling one of the component (by setting the
\var{load} slot to \var{false} will disable all three components.

\subsubsection{Camera}

\paragraph{Gostai Standard Robotic API interface:} \refFacet{VideoIn}

\paragraph{Constructor: } Camera.new(\var{node\_name})

\begin{itemize}
\item \var{node\_name} Name of the \webots node.
\end{itemize}

\paragraph{Additional slots}

\begin{itemize}
\item \lstinline{near}
\begin{attribute}{near}
  {read only}
  {Float}
  {}
  Distance of the camera to the near OpenGL clipping
  plane.
\end{attribute}

\item \lstinline|far|
\begin{attribute}{far}
  {read only}
  {Float}
  {}
  Distance of the camera to the far OpenGL clipping
  plane.
\end{attribute}
\end{itemize}

\paragraph{Note:} The \webots camera won't appear in the webots interface until the
corresponding UObject has been instantiated. You can create only one
camera Urbi Object by \webots camera device.

\subsubsection{Differential Wheels}

Differential wheels in \webots represent a pair of wheels. They are
represented as separated motors in \urbi.

\paragraph{Gostai Standard Robotic API interface:} \refFacet{RotationalMotor}

\paragraph{Constructor: } DifferentialWheels.new(\var{node\_name}, \var{left})

\begin{itemize}
\item \var{node\_name} Name of the \webots node.
\item \var{left} A Boolean: attach to the left wheel if true, to the
  right otherwise.
\end{itemize}

\begin{itemize}

\item \lstinline|encoder|
\begin{attribute}{encoder}
  {read / write}
  {Float}
  {}
  Encoders are counters incremented when a wheel turns, according to
  the \var{encoderResolution} \webots attribute of the
  DifferentialWheels.  Setting the encoder value will not rotate the
  wheel, it will simply reset it to the given value.
\end{attribute}

\end{itemize}

\paragraph{Note:} The differential wheels won't work correctly unless
you instantiate both left and right objects.

\subsubsection{Distance Sensor}

\paragraph{Gostai Standard Robotic API interface:} \refFacet{DistanceSensor}

\paragraph{Constructor:} DistanceSensor.new(\var{node\_name})

\begin{itemize}
\item \var{node\_name} Name of the \webots node.
\end{itemize}

\paragraph{Additional slots}

\begin{itemize}
\item \lstinline|factor|
\begin{attribute}{factor}
  {read / write}
  {Float}
  {}
  Multiplier factor used to compute the distance.
\end{attribute}
\end{itemize}

% \subsubsection{Emitter}

% \paragraph{Constructor}

% \noindent
% \begin{description}
% \item[{Emitter (string NodeName)}] Construct a new Emitter
%   component. The ``NodeName'' attribute is the value of the name
%   field, in the Emitter node in \webots.

% \end{description}

% \paragraph{Functions}

% \noindent
% \begin{description}
% \item[{send (UrbiVariable)}] Adds to the emitters's queue a packet
%   corresponding to the data of the UrbiVariable, plus some
%   informations on the type of the variable. Then the enqueued data
%   packets will be sent to potential receivers (and removed from the
%   emitter's queue) at the rate specified by the baudRate field of the
%   Emitter node. On success this function returns 0. If the queue is
%   currently full, 1 is returned and the packet will not be
%   enqueued. The queue is considered to be full when the sum of bytes
%   of all the enqueued packets exceeds the buffer size specified by the
%   bufferSize field.  NB: You can send every type of \urbi variables
%   with the send function EXCEPT UObjects variables.


%   Example:


% \begin{urbiunchecked}
% var1 = "hello world";
% emitter.send (var1);
% // will send 13 bytes:
% // '"','h','e','l','l','o',' ','w','o','r','l','d','"'
% // note that the enclosing quotes ("") are also send, in order for the
% // receiver to be able to recognize that the received data is a string
% var2=BIN 11;hello world
% emitter.send (var2),
% // will send 20 bytes: 5 bytes for the BIN header, 2 bytes for the
% // size, 1 byte for the ';', and 11 bytes for the actual data (hello
% // world) (the BIN header size can augment if you set some information
% // in the BIN header variable, like in images variables for example).
% \end{urbiunchecked}

%   Note that if you set the ``rawMode'' attribute to true, then the
%   comportment of the send () function will change. When ``rawMode'' is
%   true, you can only send BIN variables with the send () function, and
%   only the data in the BIN variable is send.


% \begin{urbiunchecked}
% var2=BIN 11;hello world
% emitter.rawMode = true;
% emitter.send (var2);
% /// Will send 11 bytes:
% // 'h','e','l','l','o',' ','w','o','r','l','d'
% // ie only the bytes that are in the data of the BIN variable.
% \end{urbiunchecked}

% Please note that since no type information is included in the send
% data, an \urbi receiver won't be able to parse the data received and
% won't be able to recreate the corresponding \urbi variable.

% This function use the following \webots functions:

% \begin{cxx}
% int emitter_send_packet  (DeviceTag emitter, const void *data, int size);
% \end{cxx}
% \end{description}

% \paragraph{Attributes}

% \noindent
% \begin{itemize}
% \item \lstinline{bufferSize}
% \begin{attribute}{bufferSize}
%   {readable, writeable}
%   {float}
%   {}
%   Size (in bytes) of the emission buffer. This
%   corresponds to the value specified by the bufferSize field of the
%   Emitter node. The buffer size indicates the maximal amount of data
%   bytes that the emitter's queue can hold in total.

%   Retrieved with the following \webots function:

% \begin{cxx}
% int emitter_get_buffer_size  (DeviceTag emitter);
% \end{cxx}
% \end{attribute}

% \item \lstinline{channel}
% \begin{attribute}{channel}
%   {readable, writeable}
%   {float}
%   {}
%   Emission channel. Change it to modifies the channel
%   field of the corresponding Emitter node. Normally, an emitter can
%   send data only to receivers that use the same channel. However, the
%   value -{}1 can be used for broadcasting to all channels. By
%   switching the channel number an emitter can selectively send data to
%   different receivers.

%   Retrieved and set with the following \webots functions:
% \begin{cxx}
% void emitter_set_channel  (DeviceTag emitter, int channel);
% int emitter_get_channel (DeviceTag emitter);
% \end{cxx}
% \end{attribute}

% \item \lstinline{range}
% \begin{attribute}{range}
%   {readable, writeable}
%   {float}
%   {}
%   Emission range. Change it to modifies the range field of
%  the corresponding Emitter node. If the range is larger than the
%  maxRange field of the Emitter node then the current range will be set
%  to maxRange.

%  Retrieved with the following \webots function:

% \begin{cxx}
% void emitter_set_range  (DeviceTag emitter, float range);
% float emitter_get_range (DeviceTag emitter);
% \end{cxx}
% \end{attribute}

% \item \lstinline{rawMode}
% \begin{attribute}{rawMode}
%   {readable, writeable}
%   {float}
%   {}
%   Set this attribute to true to enable sending BIN
%  variables in raw mode (ie only the data in BIN variables is
%  send). Please see ``receive ()'' function for more information.
% \end{attribute}
% \end{itemize}

% \subsubsection{Gps}

% \paragraph{Constructor}

% \noindent
% \begin{description}
% \item[{Gps (string \var{NodeName}, string \var{ComponentName})}]
%   Construct a new Gps object.  The ``NodeName'' attribute is the value
%   of the name field, in the Gps node in \webots.  The ``ComponentName''
%   is the name of the Gps component this object represent.  Because you
%   need 3 Gps UObject to represent the \webots Gps device. Each Gps
%   UObject represent one of the component of the \webots Gps device.
%   ``ComponentName'' can take 3 values: ``x'', ``y'' or ``z''.
% \end{description}

% \paragraph{Attributes}

% \noindent
% \begin{description}
% \item \lstinline{load}
% \begin{attribute}{load}
%   {readable, writeable}
%   {float}
%   {\{0,1\}}
%   This attribute let you enable or disable the Gps
%   device.  By default it is set to 1, which means that the Gps is
%   enabled. If you set it to 0 it will disable it. NB: If you enable or
%   disable one of the Gps UObject component, then all the associated
%   Gps UObject components will also be enabled or disabled (ex: if you
%   disable the y Gps component, then the x and z Gps components will
%   also be disabled).

%   To enable and disable the device we use the following \webots
%   functions:

% \begin{cxx}
% void gps_enable  (DeviceTag sensor, unsigned short ms);
% void gps_disable (DeviceTag sensor);
% \end{cxx}

% The frequency given to the enable function is the frequency of the
% \urbi controller (given in the ``controllerArgs'' field in the .wbt
% file).
% \end{attribute}

% \item \lstinline{val}
% \begin{attribute}{val}
%   {readable}
%   {float}
%   {}
%   The value of the component this UObject represent. So it
%  is one of the 3 component of the \webots Gps device. Either x, y or z.


%  Retrieved with the following \webots functions:


% \begin{cxx}
% const float *gps_get_matrix  (DeviceTag sensor);
% float gps_position_x (float *matrix);
% float gps_position_y (float *matrix);
% float gps_position_z (float *matrix);
% \end{cxx}
% \end{attribute}

% \item \lstinline{angle}
% \begin{attribute}{angle}
%   {readable}
%   {float}
%   {}
%   Euler angles associated to the UObject component. If the
%  component of this UObject is x or z, then the Euler angle can be
%  interpreted as inclinometer angle value along either the local X or
%  the local Z axis. If the component is y, then Euler angle can be
%  interpreted as a compass angle value. NB: the angles are given in
%  degrees !


%           Retrieved with the following \webots functions:


% \begin{cxx}
% void gps_euler (const float *matrix, float *euler);
% const float *gps_get_matrix  (DeviceTag sensor);
% \end{cxx}
% \end{attribute}

% \end{description}

% \subsubsection{Gripper}

% \paragraph{Constructor}

% \noindent
% \begin{description}
% \item[{Gripper (string \var{NodeName})}] Construct a new Gripper
%   component. The ``NodeName'' attribute is the value of the name
%   field, in the Gripper node in \webots.

% \end{description}

% \paragraph{Attributes}

% \noindent
% \begin{itemize}
% \item \lstinline{val}
% \begin{attribute}{val}
%   {readable, writeable}
%   {float}
%   {}
%   Position of the Gripper device.

%   Retrieved and set with the following \webots functions:

% \begin{cxx}
% float gripper_get_position  (DeviceTag gripper);
% void gripper_set_position  (DeviceTag gripper, float position);
% \end{cxx}
% \end{attribute}

% \item \lstinline{resistivity}
% \begin{attribute}{resistivity}
%   {readable}
%   {float}
%   {}
%   the resistivity of the Gripper device.

%   Retrieved with the following \webots function:

% \begin{cxx}
% float gripper_get_resistivity  (DeviceTag gripper);
% \end{cxx}
% \end{attribute}

% \end{itemize}

% \subsubsection{Keyboard}

% \paragraph{Constructor}

% \noindent
% \begin{description}
% \item[{Keyboard ()}] Construct a new Keyboard object. This object is
%   used to retrieve the key codes corresponding to keys pressed on the
%   keyboard.
% \end{description}

% \paragraph{Attributes}

% \noindent
% \begin{itemize}
% \item \lstinline{load}
% \begin{attribute}{load}
%   {readable, writeable}
%   {float}
%   {\{0,1\}}
%   This attribute let you enable or disable the Keyboard
%   device.  By default it is set to 1, which means that the Keyboard is
%   enabled. If you set it to 0 it will disable it.


%   To enable and disable the device we use the following \webots functions:
% \begin{cxx}
% void robot_keyboard_enable(unsigned short ms);
% void robot_keyboard_disable();
% \end{cxx}

% The frequency given to the enable function is the frequency of the
% \urbi controller (given in the ``controllerArgs'' field in the .wbt
% file).
% \end{attribute}

% \item \lstinline{val}
% \begin{attribute}{val}
%   {readable}
%   {float}
%   {}
%   Key code corresponding to the key currently pressed on
%   the keyboard. If no key is currently pressed, ``val'' equal 0.

%   Retrieved with the following \webots function:
% \begin{cxx}
% int robot_keyboard_get_key();
% \end{cxx}
% \end{attribute}
% \end{itemize}


\subsubsection{Led}

\paragraph{Gostai Standard Robotic API interface:} \refFacet{Led}

\paragraph{Constructor:} Led.new(\var{node\_name})

\begin{itemize}
\item \var{node\_name} Name of the \webots node.
\end{itemize}

% \subsubsection{Light Sensor}

% \paragraph{Constructor}

% \noindent
% \begin{description}
% \item[{LightSensor (string \var{NodeName})}] Construct a new Light
%   Sensor object. The ``NodeName'' attribute is the value of the name
%   field, in the LightSensor node in \webots.

% \end{description}

% \paragraph{Attributes}

% \noindent
% \begin{itemize}
% \item \lstinline{load}
% \begin{attribute}{load}
%   {readable, writeable}
%   {float}
%   {\{0,1\}}
%   This attribute let you enable or disable the
%   LightSensor device.  By default it is set to 1, which means that the
%   LightSensor is enabled. If you set it to 0 it will disable it.

%   To enable and disable the device we use the following \webots functions:

% \begin{cxx}
% void light_sensor_enable (DeviceTag sensor, unsigned short ms);
% void light_sensor_disable (DeviceTag sensor);
% \end{cxx}

% The frequency given to the enable function is the frequency of the
% \urbi controller (given in the ``controllerArgs'' field in the .wbt
% file).
% \end{attribute}

% \item \lstinline{val}
% \begin{attribute}{val}
%   {readable}
%   {float}
%   {}
%   Light value measured by the sensor. The values measured
%   are computed from the lookup table defined in the corresponding
%   \webots node.

%   Retrieved with the following \webots function:
% \begin{cxx}
% unsigned short light_sensor_get_value  (DeviceTag sensor);
% \end{cxx}
% \end{attribute}

% \end{itemize}

% \subsubsection{Plunger}

% \paragraph{Constructor}

% \noindent
% \begin{description}
% \item[{Plunger (string \var{NodeName}, float \var{offValue}, float
%     \var{onValue})}] Construct a new Plunger object. The ``NodeName''
%   attribute is the value of the name field, in the Servo node in
%   \webots. In \webots plunger objects do not exist. They are emulated by
%   Servo with on and off modes represented by the min and max values of
%   the Servo (we remind the reader that a plunger is a device with two
%   states: On / Off). In Urbi Plungers usually varies from 0 to 1. So
%   the offValue and onValue you have to pass to the constructor are the
%   values corresponding to On and Off in \webots. NB: all values must be
%   given in degree (while in \webots they are in radian) !
% \end{description}

% \paragraph{Attributes}

% \begin{itemize}
% \item \lstinline{val}
% \begin{attribute}{val}
%   {readable, writeable}
%   {float}
%   {}
%   The value of the plunger. When you set this value, the
%   value that will be given to \webots is computed as follow: val *
%   ((onValue -{} offValue) + offValue).  NB: all values must be given in
%   degree (while in \webots they are in radian) !

%   Retrieved and set with the following \webots function:
% \begin{cxx}
% float servo_get_position  (DeviceTag servo);
% void servo_set_position  (DeviceTag servo, float position);
% \end{cxx}
% \end{attribute}
% \end{itemize}

% \subsubsection{Receiver}

% \paragraph{Constructor}

% \begin{description}
% \item[{Receiver (string \var{NodeName})}] Construct a new Receiver
%   component. The ``NodeName'' attribute is the value of the name
%   field, in the Receiver node in \webots.
% \end{description}

% \paragraph{Functions}

% \noindent
% \begin{description}
% \item[{receive ()}] Returns an \urbi variable corresponding to the
%   data of the packet at the head of the reception queue. An \urbi
%   receiver can only receive data from an \urbi emitter, because the
%   \urbi emitter send the data corresponding to \urbi variables given
%   to its emit () function, plus some informations on the type of the
%   variable. The receiver then parse the received data to recreate the
%   \urbi variable.  If the \urbi emitter is in rawMode, the Receiver
%   won't be able to parse the received values.  So you have to set the
%   receiver rawMode also. In raw mode, the receiver returns BIN
%   variables containing the data received.  Please refers to \webots
%   documentation for more information on the Receiver device.

%   This function use the following \webots functions:

% \begin{cxx}
% const void *receiver_get_data  (DeviceTag receiver);
% \end{cxx}

% \item[{next ()}] Deletes the head packet. The next packet in the
%   queue, if any, becomes the new head packet.

%   This function use the following \webots functions:

% \begin{cxx}
% void receiver_next_packet  (DeviceTag receiver);
% \end{cxx}
% \end{description}

% \paragraph{Attributes}

% \begin{itemize}
% \item \lstinline{load}
% \begin{attribute}{load}
%   {readable, writeable}
%   {float}
%   {\{0,1\}}
%   This attribute let you enable or disable the Receiver
%   device.  By default it is set to 1, which means that the Receiver is
%   enabled. If you set it to 0 it will disable it.

%   To enable and disable the device we use the following \webots functions:

% \begin{cxx}
% void receiver_enable  (DeviceTag receiver, unsigned short ms);
% void receiver_disable (DeviceTag receiver);
% \end{cxx}

% The frequency given to the enable function is the frequency of the
% \urbi controller (given in the ``controllerArgs'' field in the .wbt
% file).
% \end{attribute}

% \item \lstinline{channel}
% \begin{attribute}{channel}
%   {readable, writeable}
%   {float}
%   {}
%   Reception channel. Normally, receiver can only receive
%   data packets from emitters that use the same channel, however, the
%   value -{}1 can be used to listen simultaneously to all channels.

%   Retrieved and set with the following \webots functions:
% \begin{cxx}
% void receiver_set_channel  (DeviceTag receiver, int channel);
% int receiver_get_channel (DeviceTag receiver);
% \end{cxx}
% \end{attribute}

% \item \lstinline{dataSize}
% \begin{attribute}{dataSize}
%   {readable}
%   {float}
%   {}
%   Number of data bytes present in the head packet of the
%   reception queue. Since it is \urbi variables that are sent, the
%   receiver need informations on the type of the variable to be able to
%   retrieve it correctly. So dataSize is usually greater than the actual
%   data size.

%   Retrieved with the following \webots function:

% \begin{cxx}
% int receiver_get_data_size  (DeviceTag receiver);
% \end{cxx}
% \end{attribute}

% \item \lstinline{emitterDirection}
% \begin{attribute}{emitterDirection}
%   {readable}
%   {list of 3 float values}
%   {}
%   Normalized vector that indicates the direction of the
%   emitter with respect to the receiver's coordinate system. The three
%   vector components indicate respectively the x, y, and z-{}direction
%   of the emitter.

%   Retrieved with the following \webots function:
% \begin{cxx}
% const float *receiver_get_emitter_direction  (DeviceTag receiver);
% \end{cxx}
% \end{attribute}

% \item \lstinline{queueLength}
% \begin{attribute}{queueLength}
%   {readable}
%   {float}
%   {}
%   Number of data packets currently present in the
%   receiver's queue.

%   Retrieved with the following \webots function:
% \begin{cxx}
% int receiver_get_queue_length  (DeviceTag receiver);
% \end{cxx}
% \end{attribute}

% \item \lstinline{rawMode}
% \begin{attribute}{rawMode}
%   {readable, writeable}
%   {float}
%   {}
%   Set this attribute to true to enable receiving data in
%   raw mode.  In raw mode the ``receive ()'' function will return BIN
%   variables containing the data received. Use this mode when you the
%   emitter emit non Urbi data.
% \end{attribute}

% \item \lstinline{signalStrength}
% \begin{attribute}{signalStrength}
%   {readable}
%   {float}
%   {}
%   Simulated signal strength at the time the last packet
%   was transmitted.  This signal strength is equal to the inverse of the
%   squared distance between the emitter and the receiver. In other
%   words: s = 1 / r\^{}2, where s is the signal strength and r is the
%   distance between emitter and receiver.

%   Retrieved with the following \webots function:
% \begin{cxx}
% float receiver_get_signal_strength  (DeviceTag receiver);
% \end{cxx}
% \end{attribute}
% \end{itemize}

% \subsubsection{RobotName}

% \paragraph{Constructor}

% \noindent
% \begin{description}
% \item[{RobotName ()}] Construct a new RobotName object. This object is
%   used to retrieve the name of the robot associated to the \urbi
%   controller.
% \end{description}

% \paragraph{Attributes}

% \noindent
% \begin{itemize}
% \item \lstinline{val}
% \begin{attribute}{val}
%   {readable}
%   {string}
%   {}
%   Name of the robot associated to the \urbi controller.

%   Retrieved with the following \webots function:
% \begin{cxx}
% const char *robot_get_name();
% \end{cxx}
% \end{attribute}

% \end{itemize}

\subsubsection{Servo}

\paragraph{Gostai Standard Robotic API interface:} \refFacet{RotationalMotor}

\paragraph{Constructor:} Servo.new(\var{node\_name}, \var{force\_feedback})

\begin{itemize}
\item \var{node\_name} Name of the \webots node.
\item \var{force\_feedback} Whether to enable the reading of the force
  applied to the joint.
\end{itemize}

\paragraph{Additional slots}

\begin{itemize}
\item \lstinline{force}
\begin{attribute}{force}
  {read only}
  {Float}
  {}

  \fixme{This is named \var{torque} in the standard, and should be
    renamed accordingly.}

  Force currently deployed by the motor to achieve the desired
  motion. Available only if \var{force\_feedback} was turned on at
  construction time.
\end{attribute}
\end{itemize}

\subsubsection{Touch Sensor}

\paragraph{Gostai Standard Robotic API interface:} \refFacet{TouchSensor}

\paragraph{Constructor:} TouchSensor.new(\var{node\_name})

\begin{itemize}
\item \var{node\_name} Name of the \webots node.
\end{itemize}

\subsection{Supervisor \api UObjects}
\label{sec:webots:supervisor}

The supervisor UObjects are only available from a supervisor robot
(i.e. from the controller of a supervisor node in \webots). They
enable to control the simulation in an omnipotent manner.

\subsubsection{Label}

\paragraph{Constructor:} Label.new(\var{text})

\begin{itemize}
\item \var{text} The displayed text.
\end{itemize}

\paragraph{Slots}

\begin{itemize}
\item \lstinline{txt}
\begin{attribute}{txt}
  {read / write}
  {String}
  {}
  Displayed text.
\end{attribute}
\item \lstinline{x, y}
\begin{attribute}{x, y}
  {read / write}
  {Float}
  {}
  Coordinates of the label on the screen.
\end{attribute}
\item \lstinline{r, g, b, a}
\begin{attribute}{r, g, b, a}
  {read / write}
  {Float}
  {0, 1}
  Red, blue, green and alpha components of the label's text color.
\end{attribute}
\item \lstinline{size}
\begin{attribute}{size}
  {read / write}
  {Float}
  {}
  Size of the displayed text.
\end{attribute}
\end{itemize}

\subsubsection{Manipulate Node}

\paragraph{Constructor:} ManipulateNode.new(\var{node\_name})

\begin{itemize}
\item \var{node\_name} Name of the \webots node to
  manipulate. \webots' ManipulateNode objects only apply to solid
  objects.
\end{itemize}

\paragraph{Slots}

\begin{itemize}
\item \lstinline{tx, ty, tz}
\begin{attribute}{tx, ty, tz}
  {read / write}
  {Float}
  {}
  Applied translation on the three axis.
\end{attribute}
\item \lstinline{ax, ay, az}
\begin{attribute}{ax, ay, az}
  {read / write}
  {Float}
  {}
  Applied rotation on the three axis.
\end{attribute}
\end{itemize}

\subsubsection{Simulation Controller}

\paragraph{Constructor:} SimulationController.new()

\paragraph{Slots}

\begin{itemize}
\item physicsReset() \\
  Send a request to the simulator process, asking to stop the movement
  of all physics enabled solids in the world. It means that for any
  Solid node containing a Physics node, the linear and angular
  velocities of the corresponding body is reset to 0, hence the
  inertia is stopped. This function is especially useful when
  resetting a robot at an initial position from which no initial
  inertia is required.  This function resets the seed of the random
  number generator used in \webots, so that noise based simulations
  can be be reproduced identically after calling this function.

\item revert() \\
  Send a request to the simulator process, asking to reload the
  current world immediately. As a result of reloading the current
  world, the supervisor process and all the robot processes are
  terminated and restarted. You might want to save some data in a file
  from you supervisor program to be able to reload it when the
  supervisor controller restarts.

\item quit() \\
  Send a request to the simulator process, asking to terminate and
  quit immediately. As a result of terminating the simulator process,
  all the controller processes, including the calling supervisor
  controller process will terminate.
\end{itemize}

% \subsection{Other UObjects}

% \subsubsection{UBinaryReader}

% \paragraph{Constructor}

% \noindent
% \begin{description}
% \item[{UBinaryReader ()}] Construct a new UBinaryReader.
% \end{description}

% \paragraph{Functions}

% \noindent
% \begin{description}
% \item[{int set (UBinary \var{b})}] Set the UBinary you want to
%   parse. You have to call the 'set' function before calling the 'read'
%   function.  Return 0 in case of success, and 1 in case of error.

% \item[{UList read (String \var{format})}] Read formated binary data
%   from the UBinary, and return a list corresponding to the data which
%   was read.

%   \var{format} is a list of type identifiants separated by \samp{,}.

%   The type identifiants describe a type, and are of the form
%   \samp{\var{Type}[:n]} where \var{Type} can be:
%   \begin{description}
%   \item[i8]   8 bit integer
%   \item[i16] 16 bit integer
%   \item[i32] 32 bit integer
%   \item[i64] 64 bit integer
%   \item[u8]   8 bit unsigned integer
%   \item[u16] 16 bit unsigned integer
%   \item[u32] 32 bit unsigned integer
%   \item[u64] 64 bit unsigned integer
%   \item[f32] 32 bit float
%   \item[f64] 64 bit float
%   \item[c]    8 bit character
%   \end{description}
%   and where \samp{n} specify the number of times the UBinaryReader
%   should read a value of this type.

%   \samp{n} is optional (that is the meaning of the enclosing \samp{[}
%   \samp{]} which are not part of the syntax).

%   The function returns a list of values corresponding to the data
%   read.  In case of character data, if you specify the \samp{n}
%   parameter, then the characters are concateneted and put in a string.

%   ex:
% \begin{urbiunchecked}
% p = new UBinaryReader();
% a = BIN 10;abcdefghij   /// Create an UBinary which contains abcdefghij
% p.set (a);              /// Set the UBinary in the reader.
% p.read ("c,i8");        /// we read: a character then an 8 bits integer
% [00175588] ["a", 98]    /// a is for the 'a' and 98 for the 'b' (8 bit ascii
%                         /// code is 98)
% p.index = 0;            /// Set the reading cursor to the begining.
% p.read ("c,c:3,i8:2,i16"),
% [00161064] ["a", "bcd", 101, 102, 26727]
% p.index = 4;            /// Set the reading cursor to read the 5th character
% p.read ("c:5"),
% [00169480] ["efghi"]
% \end{urbiunchecked}

%   In case of error, the function stop reading, and return a list
%   containing the values that were successfully read until the error
%   occur. The function then set the reading cursor 'index' to -{}1, and
%   set an error message in the 'error' attribute.
% \end{description}

% \paragraph{Attributes}

% \noindent
% \begin{description}
% \item[index] Index of the reading cursor. When you read from an
%   UBinary with the 'read' function, this index is automatically
%   updated so that the next read will occur where the previous read
%   stopped.

%   You can change the position of the reading cursor by assigning a new
%   value to 'index'. Note that the begining of the UBinary is
%   associated to a value of 0 for 'index'.

%   'index' cannot be greater than the UBinary size.

%   When a reading error occur, 'index' is set to -1, and you have to
%   change it's value manually to continue reading.

% \item[size] The size of the UBinary currently read.

% \item[error] In case of error, this attribute contains a readable
%   error message corresponding to the error.
% \end{description}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% ispell-dictionary: "american"
%%% ispell-personal-dictionary: "../urbi.dict"
%%% fill-column: 76
%%% End:
