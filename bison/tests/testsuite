#! /bin/sh
# Generated from /home/build/kernel-2.0_x86-64_gcc4_release-dynamic/work/source/bison/tests/local.at by GNU Autoconf 2.67.
#
# Copyright (C) 2009, 2010 Free Software Foundation, Inc.
#
# This test suite is free software; the Free Software Foundation gives
# unlimited permission to copy, distribute and modify it.
## -------------------- ##
## M4sh Initialization. ##
## -------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi


as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
# Prefer a ksh shell builtin over an external printf program on Solaris,
# but without wasting forks for bash or zsh.
if test -z "$BASH_VERSION$ZSH_VERSION" \
    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='print -r --'
  as_echo_n='print -rn --'
elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in #(
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
case $0 in #((
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
  done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  exit 1
fi

# Unset variables that we do not need and which cause bugs (e.g. in
# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
# suppresses any "Segmentation fault" message there.  '((' could
# trigger a bug in pdksh 5.2.14.
for as_var in BASH_ENV ENV MAIL MAILPATH
do eval test x\${$as_var+set} = xset \
  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# CDPATH.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH

if test "x$CONFIG_SHELL" = x; then
  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '\${1+\"\$@\"}'='\"\$@\"'
  setopt NO_GLOB_SUBST
else
  case \`(set -o) 2>/dev/null\` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi
"
  as_required="as_fn_return () { (exit \$1); }
as_fn_success () { as_fn_return 0; }
as_fn_failure () { as_fn_return 1; }
as_fn_ret_success () { return 0; }
as_fn_ret_failure () { return 1; }

exitcode=0
as_fn_success || { exitcode=1; echo as_fn_success failed.; }
as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :

else
  exitcode=1; echo positional parameters were not saved.
fi
test x\$exitcode = x0 || exit 1"
  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
test \$(( 1 + 1 )) = 2 || exit 1"
  if (eval "$as_required") 2>/dev/null; then :
  as_have_required=yes
else
  as_have_required=no
fi
  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :

else
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
as_found=false
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  as_found=:
  case $as_dir in #(
	 /*)
	   for as_base in sh bash ksh sh5; do
	     # Try only shells that exist, to save several forks.
	     as_shell=$as_dir/$as_base
	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
  CONFIG_SHELL=$as_shell as_have_required=yes
		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
  break 2
fi
fi
	   done;;
       esac
  as_found=false
done
$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
  CONFIG_SHELL=$SHELL as_have_required=yes
fi; }
IFS=$as_save_IFS


      if test "x$CONFIG_SHELL" != x; then :
  # We cannot yet assume a decent shell, so we have to provide a
	# neutralization value for shells without unset; and this also
	# works around shells that cannot unset nonexistent variables.
	BASH_ENV=/dev/null
	ENV=/dev/null
	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
	export CONFIG_SHELL
	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
fi

    if test x$as_have_required = xno; then :
  $as_echo "$0: This script requires a shell more modern than all"
  $as_echo "$0: the shells that I found on your system."
  if test x${ZSH_VERSION+set} = xset ; then
    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
  else
    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
$0: including any error possibly output before this
$0: message. Then install a modern shell, or manually run
$0: the script under such a shell if you do have one."
  fi
  exit 1
fi
fi
fi
SHELL=${CONFIG_SHELL-/bin/sh}
export SHELL
# Unset more variables known to interfere with behavior of common tools.
CLICOLOR_FORCE= GREP_OPTIONS=
unset CLICOLOR_FORCE GREP_OPTIONS

## --------------------- ##
## M4sh Shell Functions. ##
## --------------------- ##
# as_fn_unset VAR
# ---------------
# Portably unset VAR.
as_fn_unset ()
{
  { eval $1=; unset $1;}
}
as_unset=as_fn_unset

# as_fn_set_status STATUS
# -----------------------
# Set $? to STATUS, without forking.
as_fn_set_status ()
{
  return $1
} # as_fn_set_status

# as_fn_exit STATUS
# -----------------
# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
as_fn_exit ()
{
  set +e
  as_fn_set_status $1
  exit $1
} # as_fn_exit

# as_fn_mkdir_p
# -------------
# Create "$as_dir" as a directory, including parents if necessary.
as_fn_mkdir_p ()
{

  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || eval $as_mkdir_p || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"


} # as_fn_mkdir_p
# as_fn_append VAR VALUE
# ----------------------
# Append the text in VALUE to the end of the definition contained in VAR. Take
# advantage of any shell optimizations that allow amortized linear growth over
# repeated appends, instead of the typical quadratic growth present in naive
# implementations.
if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
  eval 'as_fn_append ()
  {
    eval $1+=\$2
  }'
else
  as_fn_append ()
  {
    eval $1=\$$1\$2
  }
fi # as_fn_append

# as_fn_arith ARG...
# ------------------
# Perform arithmetic evaluation on the ARGs, and store the result in the
# global $as_val. Take advantage of shells that can avoid forks. The arguments
# must be portable across $(()) and expr.
if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
  eval 'as_fn_arith ()
  {
    as_val=$(( $* ))
  }'
else
  as_fn_arith ()
  {
    as_val=`expr "$@" || test $? -eq 1`
  }
fi # as_fn_arith


# as_fn_error STATUS ERROR [LINENO LOG_FD]
# ----------------------------------------
# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
# script with STATUS, using 1 if that was 0.
as_fn_error ()
{
  as_status=$1; test $as_status -eq 0 && as_status=1
  if test "$4"; then
    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
  fi
  $as_echo "$as_me: error: $2" >&2
  as_fn_exit $as_status
} # as_fn_error

if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi

as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits


  as_lineno_1=$LINENO as_lineno_1a=$LINENO
  as_lineno_2=$LINENO as_lineno_2a=$LINENO
  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
  sed -n '
    p
    /[$]LINENO/=
  ' <$as_myself |
    sed '
      s/[$]LINENO.*/&-/
      t lineno
      b
      :lineno
      N
      :loop
      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
      t loop
      s/-\n.*//
    ' >$as_me.lineno &&
  chmod +x "$as_me.lineno" ||
    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }

  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensitive to this).
  . "./$as_me.lineno"
  # Exit status is that of the last command.
  exit
}

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in #(((((
-n*)
  case `echo 'xy\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  xy)  ECHO_C='\c';;
  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
       ECHO_T='	';;
  esac;;
*)
  ECHO_N='-n';;
esac

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -p'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -p'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -p'
  fi
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null

if mkdir -p . 2>/dev/null; then
  as_mkdir_p='mkdir -p "$as_dir"'
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

if test -x / >/dev/null 2>&1; then
  as_test_x='test -x'
else
  if ls -dL / >/dev/null 2>&1; then
    as_ls_L_option=L
  else
    as_ls_L_option=
  fi
  as_test_x='
    eval sh -c '\''
      if test -d "$1"; then
	test -d "$1/.";
      else
	case $1 in #(
	-*)set "./$1";;
	esac;
	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
	???[sx]*):;;*)false;;esac;fi
    '\'' sh
  '
fi
as_executable_p=$as_test_x

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"





SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args="$@"


# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_p=false
(times) >/dev/null 2>&1 && at_times_p=:

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?  ':' means no, empty means yes.
at_verbose=:
at_quiet=
# Running several jobs in parallel, 0 means as many as test groups.
at_jobs=1
at_traceon=:
at_trace_echo=:
at_check_filter_trace=:

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# Display the version message?
at_version_p=false
# List test groups?
at_list_p=false
# --clean
at_clean=false
# Test groups to run
at_groups=
# Whether to rerun failed tests.
at_recheck=
# Whether a write failure occurred
at_write_fail=0

# The directory we run the suite in.  Default to . if no -C option.
at_dir=`pwd`
# An absolute reference to this testsuite script.
case $as_myself in
  [\\/]* | ?:[\\/]* ) at_myself=$as_myself ;;
  * ) at_myself=$at_dir/$as_myself ;;
esac
# Whether -C is in effect.
at_change_dir=false

# Whether to enable colored test results.
at_color=no
# List of the tested programs.
at_tested='bison'
# List of the all the test groups.
at_groups_all=' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308'
# As many question marks as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='???'
# Description of all the test groups.
at_help_all="1;input.at:28;Invalid \$n and @n;;
2;input.at:48;Type Clashes;;
3;input.at:157;Unused values;;
4;input.at:167;Unused values before symbol declarations;;
5;input.at:177;Default %printer and %destructor redeclared;;
6;input.at:237;Per-type %printer and %destructor redeclared;;
7;input.at:280;Unused values with default %destructor;;
8;input.at:322;Unused values with per-type %destructor;;
9;input.at:347;Incompatible Aliases;;
10;input.at:388;Torturing the Scanner;;
11;input.at:551;Typed symbol aliases;;
12;input.at:587;Require 1.0;;
13;input.at:588;Require 2.3b.564-5697;;
14;input.at:590;Require 100.0;;
15;input.at:597;String aliases for character tokens;;
16;input.at:618;Symbols;;
17;input.at:677;Numbered tokens;;
18;input.at:715;Unclosed constructs;;
19;input.at:760;%start after first rule;;
20;input.at:781;%prec takes a token;;
21;input.at:802;%prec's token must be defined;;
22;input.at:822;Reject unused %code qualifiers;;
23;input.at:911;%define errors;;
24;input.at:947;%define, --define, --force-define;;
25;input.at:1000;%define Boolean variables;;
26;input.at:1020;%define enum variables;;
27;input.at:1054;%define backward compatibility;;
28;input.at:1106;Unused %define api.pure;;
29;input.at:1139;C++ namespace reference errors;;
30;input.at:1195;Bad character literals;;
31;input.at:1248;Bad escapes in literals;;
32;named-refs.at:20;Tutorial calculator;;
33;named-refs.at:199;Undefined and ambiguous references;;
34;named-refs.at:274;Misleading references;;
35;named-refs.at:291;Many kinds of errors;;
36;named-refs.at:403;Missing identifiers in brackets;;
37;named-refs.at:417;Redundant words in brackets;;
38;named-refs.at:431;Comments in brackets;;
39;named-refs.at:445;Stray symbols in brackets;;
40;named-refs.at:461;Redundant words in LHS brackets;;
41;named-refs.at:474;Unresolved references;;
42;output.at:44;Output files:  -dv ;;
43;output.at:46;Output files:  -dv >&-;;
44;output.at:49;Output files:  -dv -o foo.c ;;
45;output.at:51;Output files:  -dv -o foo.tab.c ;;
46;output.at:53;Output files:  -dv -y ;;
47;output.at:55;Output files:  -dv -b bar ;;
48;output.at:57;Output files:  -dv -g -o foo.c ;;
49;output.at:61;Output files: %defines %verbose  ;;
50;output.at:63;Output files: %defines %verbose %yacc  ;;
51;output.at:66;Output files: %defines %verbose %yacc  ;;
52;output.at:70;Output files: %file-prefix \"bar\" %defines %verbose  ;;
53;output.at:72;Output files: %output=\"bar.c\" %defines %verbose %yacc  ;;
54;output.at:74;Output files: %file-prefix=\"baz\" %output \"bar.c\" %defines %verbose %yacc  ;;
55;output.at:81;Output files: %defines %verbose  ;;
56;output.at:84;Output files: %defines %verbose  -o foo.c ;;
57;output.at:87;Output files:  --defines=foo.hpp -o foo.c++ ;;
58;output.at:91;Output files: %defines \"foo.hpp\" -o foo.c++ ;;
59;output.at:95;Output files:  -o foo.c++ --graph=foo.gph ;;
60;output.at:110;Output files: %skeleton \"lalr1.cc\" %defines %verbose  ;;
61;output.at:113;Output files: %skeleton \"lalr1.cc\" %defines %verbose %locations  ;;
62;output.at:116;Output files: %skeleton \"lalr1.cc\" %defines %verbose  ;;
63;output.at:120;Output files: %skeleton \"lalr1.cc\" %defines %verbose %locations -o subdir/foo.cc ;;
64;output.at:125;Output files: %skeleton \"lalr1.cc\" %defines %verbose %file-prefix \"output_dir/foo\"  ;;
65;output.at:130;Output files: %skeleton \"lalr1.cc\" %defines %locations %verbose %file-prefix \"output_dir/foo\"  ;;
66;output.at:160;Conflicting output files:  --graph=\"foo.tab.c\";;
67;output.at:165;Conflicting output files: %defines \"foo.output\" -v;;
68;output.at:170;Conflicting output files: %skeleton \"lalr1.cc\" %defines %locations --graph=\"location.hh\";;
69;output.at:175;Conflicting output files:  -o foo.y;;
70;output.at:219;Output file name: \`~!@#\$%^&*()-=_+{}[]|\\:;<>, .';c++;
71;output.at:226;Output file name: (;c++;
72;output.at:227;Output file name: );c++;
73;output.at:228;Output file name: #;c++;
74;output.at:229;Output file name: @@;c++;
75;output.at:230;Output file name: @{;c++;
76;output.at:231;Output file name: @};c++;
77;output.at:232;Output file name: [;c++;
78;output.at:233;Output file name: ];c++;
79;skeletons.at:24;Relative skeleton file names;;
80;skeletons.at:84;Installed skeleton file names;;
81;skeletons.at:149;%define Boolean variables: invalid skeleton defaults;;
82;skeletons.at:173;Complaining during macro argument expansion;;
83;skeletons.at:255;Fatal errors make M4 exit immediately;;
84;skeletons.at:309;Fatal errors but M4 continues producing output;;
85;sets.at:66;Nullable;;
86;sets.at:151;Broken Closure;;
87;sets.at:193;Firsts;;
88;sets.at:269;Accept;;
89;reduce.at:26;Useless Terminals;;
90;reduce.at:70;Useless Nonterminals;;
91;reduce.at:125;Useless Rules;report;
92;reduce.at:213;Reduced Automaton;report;
93;reduce.at:303;Underivable Rules;report;
94;reduce.at:345;Empty Language;;
95;reduce.at:396;no %define lr.type: Single State Split;;
96;reduce.at:396;%define lr.type lalr: Single State Split;;
97;reduce.at:396;%define lr.type ielr: Single State Split;;
98;reduce.at:396;%define lr.type canonical-lr: Single State Split;;
99;reduce.at:629;no %define lr.type: Lane Split;;
100;reduce.at:629;%define lr.type lalr: Lane Split;;
101;reduce.at:629;%define lr.type ielr: Lane Split;;
102;reduce.at:629;%define lr.type canonical-lr: Lane Split;;
103;reduce.at:873;no %define lr.type: Complex Lane Split;;
104;reduce.at:873;%define lr.type lalr: Complex Lane Split;;
105;reduce.at:873;%define lr.type ielr: Complex Lane Split;;
106;reduce.at:873;%define lr.type canonical-lr: Complex Lane Split;;
107;reduce.at:1142;no %define lr.type: Split During Added Lookahead Propagation;;
108;reduce.at:1142;%define lr.type lalr: Split During Added Lookahead Propagation;;
109;reduce.at:1142;%define lr.type ielr: Split During Added Lookahead Propagation;;
110;reduce.at:1142;%define lr.type canonical-lr: Split During Added Lookahead Propagation;;
111;reduce.at:1472;no %define lr.default-reductions;;
112;reduce.at:1472;%define lr.default-reductions all;;
113;reduce.at:1472;%define lr.default-reductions consistent;;
114;reduce.at:1472;%define lr.default-reductions accepting;;
115;synclines.at:109;Prologue synch line;;
116;synclines.at:126;%union synch line;;
117;synclines.at:146;Postprologue synch line;;
118;synclines.at:169;Action synch line;;
119;synclines.at:188;Epilogue synch line;;
120;headers.at:27;%union and --defines;;
121;headers.at:77;Invalid CPP guards: input/input;;
122;headers.at:78;Invalid CPP guards: 9foo;;
123;headers.at:87;export YYLTYPE;;
124;actions.at:25;Mid-rule actions;;
125;actions.at:94;Exotic Dollars;;
126;actions.at:571;Printers and Destructors : ;;
127;actions.at:572;Printers and Destructors with union: ;;
128;actions.at:574;Printers and Destructors : %defines %skeleton \"lalr1.cc\";c++;
129;actions.at:575;Printers and Destructors with union: %defines %skeleton \"lalr1.cc\";c++;
130;actions.at:577;Printers and Destructors : %glr-parser;glr;
131;actions.at:578;Printers and Destructors with union: %glr-parser;glr;
132;actions.at:589;Default tagless %printer and %destructor;;
133;actions.at:707;Default tagged and per-type %printer and %destructor;;
134;actions.at:844;Default %printer and %destructor for user-defined end token;;
135;actions.at:958;Default %printer and %destructor are not for error or \$undefined;;
136;actions.at:1068;Default %printer and %destructor are not for \$accept;;
137;actions.at:1145;Default %printer and %destructor for mid-rule values;;
138;actions.at:1301;@\$ in %initial-action implies %locations;;
139;actions.at:1302;@\$ in %destructor implies %locations;;
140;actions.at:1303;@\$ in %printer implies %locations;;
141;actions.at:1310;Fix user actions without a trailing semicolon;;
142;actions.at:1418;Destroying lookahead assigned by semantic action;;
143;conflicts.at:31;S/R in initial;;
144;conflicts.at:51;%nonassoc and eof;;
145;conflicts.at:146;parse.error=verbose and consistent errors;;
146;conflicts.at:270;Unresolved SR Conflicts;report;
147;conflicts.at:377;Resolved SR Conflicts;report;
148;conflicts.at:478;%precedence suffices;;
149;conflicts.at:504;%precedence does not suffice;;
150;conflicts.at:555;Defaulted Conflicted Reduction;report;
151;conflicts.at:674;%expect not enough;;
152;conflicts.at:694;%expect right;;
153;conflicts.at:711;%expect too much;;
154;conflicts.at:731;%expect with reduce conflicts;;
155;conflicts.at:751;%prec with user string;;
156;conflicts.at:768;%no-default-prec without %prec;;
157;conflicts.at:794;%no-default-prec with %prec;;
158;conflicts.at:818;%default-prec;;
159;conflicts.at:842;Unreachable States After Conflict Resolution;;
160;conflicts.at:1053;Solved conflicts report for multiple reductions in a state;;
161;conflicts.at:1133;%nonassoc error actions for multiple reductions in a state;;
162;calc.at:610;Calculator ;;
163;calc.at:612;Calculator %defines;;
164;calc.at:613;Calculator %locations;;
165;calc.at:615;Calculator %name-prefix=\"calc\";;
166;calc.at:616;Calculator %verbose;;
167;calc.at:617;Calculator %yacc;;
168;calc.at:618;Calculator %define parse.error verbose;;
169;calc.at:620;Calculator %define api.pure %locations;;
170;calc.at:621;Calculator %define api.push-pull both %define api.pure %locations;;
171;calc.at:622;Calculator %define parse.error verbose %locations;;
172;calc.at:624;Calculator %define parse.error verbose %locations %defines %name-prefix \"calc\" %verbose %yacc;;
173;calc.at:625;Calculator %define parse.error verbose %locations %defines %name-prefix \"calc\" %define api.tokens.prefix \"TOK_\" %verbose %yacc;;
174;calc.at:627;Calculator %debug;;
175;calc.at:628;Calculator %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;;
176;calc.at:630;Calculator %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;;
177;calc.at:631;Calculator %define api.push-pull both %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;;
178;calc.at:633;Calculator %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};;
179;calc.at:650;Calculator %glr-parser ;glr;
180;calc.at:652;Calculator %glr-parser %defines;glr;
181;calc.at:653;Calculator %glr-parser %locations;glr;
182;calc.at:654;Calculator %glr-parser %name-prefix \"calc\";glr;
183;calc.at:655;Calculator %glr-parser %verbose;glr;
184;calc.at:656;Calculator %glr-parser %yacc;glr;
185;calc.at:657;Calculator %glr-parser %define parse.error verbose;glr;
186;calc.at:659;Calculator %glr-parser %define api.pure %locations;glr;
187;calc.at:660;Calculator %glr-parser %define parse.error verbose %locations;glr;
188;calc.at:662;Calculator %glr-parser %define parse.error verbose %locations %defines %name-prefix \"calc\" %verbose %yacc;glr;
189;calc.at:664;Calculator %glr-parser %debug;glr;
190;calc.at:665;Calculator %glr-parser %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;glr;
191;calc.at:666;Calculator %glr-parser %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %define api.tokens.prefix \"TOK_\" %verbose %yacc;glr;
192;calc.at:668;Calculator %glr-parser %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;glr;
193;calc.at:670;Calculator %glr-parser %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};glr;
194;calc.at:680;Calculator %skeleton \"lalr1.cc\" %defines %locations;c++;
195;calc.at:689;Calculator %language \"C++\" %defines ;c++;
196;calc.at:690;Calculator %language \"C++\" %defines %locations;c++;
197;calc.at:691;Calculator %language \"C++\" %defines %locations %define location_type Span;c++;
198;calc.at:692;Calculator %language \"C++\" %defines %locations %define parse.error verbose %name-prefix \"calc\" %verbose %yacc;c++;
199;calc.at:694;Calculator %language \"C++\" %defines %locations %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc;c++;
200;calc.at:696;Calculator %language \"C++\" %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc;c++;
201;calc.at:697;Calculator %language \"C++\" %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %define api.tokens.prefix \"TOK_\" %verbose %yacc;c++;
202;calc.at:699;Calculator %language \"C++\" %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};c++;
203;calc.at:710;Calculator %skeleton \"glr.cc\" %defines %locations;glr c++;
204;calc.at:719;Calculator %language \"C++\" %glr-parser %defines %locations ;glr c++;
205;calc.at:720;Calculator %language \"C++\" %glr-parser %defines %locations %define location_type Span;glr c++;
206;calc.at:721;Calculator %language \"C++\" %glr-parser %defines %locations %define parse.error verbose %name-prefix \"calc\" %verbose %yacc;glr c++;
207;calc.at:723;Calculator %language \"C++\" %glr-parser %defines %locations %debug;glr c++;
208;calc.at:724;Calculator %language \"C++\" %glr-parser %defines %locations %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc;glr c++;
209;calc.at:726;Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc;glr c++;
210;calc.at:727;Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %define api.tokens.prefix \"TOK_\" %verbose %yacc;glr c++;
211;calc.at:729;Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};glr c++;
212;torture.at:140;Big triangle;;
213;torture.at:233;Big horizontal;;
214;torture.at:373;Many lookahead tokens;;
215;torture.at:474;Exploding the Stack Size with Alloca;;
216;torture.at:520;Exploding the Stack Size with Malloc;;
217;existing.at:76;GNU AWK 3.1.0 Grammar: LALR(1);;
218;existing.at:76;GNU AWK 3.1.0 Grammar: IELR(1);;
219;existing.at:76;GNU AWK 3.1.0 Grammar: Canonical LR(1);;
220;existing.at:780;GNU Cim Grammar: LALR(1);;
221;existing.at:780;GNU Cim Grammar: IELR(1);;
222;existing.at:780;GNU Cim Grammar: Canonical LR(1);;
223;existing.at:1401;GNU pic (Groff 1.18.1) Grammar: LALR(1);;
224;existing.at:1401;GNU pic (Groff 1.18.1) Grammar: IELR(1);;
225;existing.at:1401;GNU pic (Groff 1.18.1) Grammar: Canonical LR(1);;
226;regression.at:26;Trivial grammars;;
227;regression.at:54;YYSTYPE typedef;;
228;regression.at:82;Early token definitions with --yacc;;
229;regression.at:120;Early token definitions without --yacc;;
230;regression.at:163;Braces parsing;;
231;regression.at:185;Duplicate string;;
232;regression.at:211;Rule Line Numbers;report;
233;regression.at:355;Mixing %token styles;;
234;regression.at:378;Invalid inputs;;
235;regression.at:404;Invalid inputs with {};;
236;regression.at:429;Token definitions;;
237;regression.at:499;Characters Escapes;;
238;regression.at:530;Web2c Report;report;
239;regression.at:707;Web2c Actions;report;
240;regression.at:940;Dancer ;;
241;regression.at:941;Dancer %glr-parser;glr;
242;regression.at:942;Dancer %skeleton \"lalr1.cc\";c++;
243;regression.at:1036;Expecting two tokens ;;
244;regression.at:1037;Expecting two tokens %glr-parser;glr;
245;regression.at:1038;Expecting two tokens %skeleton \"lalr1.cc\";c++;
246;regression.at:1046;Braced code in declaration in rules section;;
247;regression.at:1122;String alias declared after use;;
248;regression.at:1145;Extra lookahead sets in report;;
249;regression.at:1186;Token number in precedence declaration;;
250;regression.at:1250;parse-gram.y: LALR = IELR;;
251;regression.at:1270;parse.error=verbose and YYSTACK_USE_ALLOCA;;
252;regression.at:1358;parse.error=verbose overflow;;
253;c++.at:200;Variants ;c++;
254;c++.at:201;Variants %define parse.assert;c++;
255;c++.at:202;Variants %define parse.assert %code {\\n#define ONE_STAGE_BUILD\\n};c++;
256;c++.at:203;Variants %define parse.assert %define lex_symbol %code {\\n#define USE_LEX_SYMBOL\\n};c++;
257;c++.at:204;Variants %define parse.assert %define lex_symbol %code {\\n#define USE_LEX_SYMBOL\\n} %define api.tokens.prefix \"TOK_\";c++;
258;c++.at:287;Doxygen Public Documentation;;
259;c++.at:288;Doxygen Private Documentation;;
260;c++.at:348;Relative namespace references;c++;
261;c++.at:354;Absolute namespace references;c++;
262;c++.at:363;Syntactically invalid namespace references;;
263;c++.at:382;Syntax error discarding no lookahead;c++;
264;java.at:386;Calculator ;java;
265;java.at:386;Calculator %error-verbose ;java;
266;java.at:386;Calculator %locations ;java;
267;java.at:386;Calculator %error-verbose %locations ;java;
268;java.at:395;Calculator %lex-param { InputStream is } ;java;
269;java.at:395;Calculator %error-verbose %lex-param { InputStream is } ;java;
270;java.at:395;Calculator %locations %lex-param { InputStream is } ;java;
271;java.at:395;Calculator %error-verbose %locations %lex-param { InputStream is } ;java;
272;java.at:482;Java parser class and package names;java;
273;java.at:506;Java parser class modifiers;java;
274;java.at:570;Java parser class extends and implements;java;
275;java.at:590;Java %parse-param and %lex-param;java;
276;java.at:664;Java throws specifications;java;
277;java.at:753;Java constructor init and init_throws;java;
278;java.at:775;Java stype, position_class and location_class;java;
279;cxx-type.at:414;GLR: Resolve ambiguity, impure, no locations;;
280;cxx-type.at:421;GLR: Resolve ambiguity, impure, locations;;
281;cxx-type.at:427;GLR: Resolve ambiguity, pure, no locations;;
282;cxx-type.at:434;GLR: Resolve ambiguity, pure, locations;;
283;cxx-type.at:441;GLR: Merge conflicting parses, impure, no locations;;
284;cxx-type.at:448;GLR: Merge conflicting parses, impure, locations;;
285;cxx-type.at:455;GLR: Merge conflicting parses, pure, no locations;;
286;cxx-type.at:461;GLR: Merge conflicting parses, pure, locations;;
287;cxx-type.at:468;GLR: Verbose messages, resolve ambiguity, impure, no locations;;
288;glr-regression.at:25;Badly Collapsed GLR States;;
289;glr-regression.at:120;Improper handling of embedded actions and dollar(-N) in GLR parsers;;
290;glr-regression.at:239;Improper merging of GLR delayed action sets;;
291;glr-regression.at:348;Duplicate representation of merged trees;;
292;glr-regression.at:451;User destructor for unresolved GLR semantic value;;
293;glr-regression.at:524;User destructor after an error during a split parse;;
294;glr-regression.at:591;Duplicated user destructor for lookahead;;
295;glr-regression.at:683;Incorrectly initialized location for empty right-hand side in GLR;;
296;glr-regression.at:781;No users destructors if stack 0 deleted;;
297;glr-regression.at:861;Corrupted semantic options if user action cuts parse;;
298;glr-regression.at:926;Undesirable destructors if user action cuts parse;;
299;glr-regression.at:995;Leaked semantic values if user action cuts parse;;
300;glr-regression.at:1128;Incorrect lookahead during deterministic GLR;;
301;glr-regression.at:1264;Incorrect lookahead during nondeterministic GLR;;
302;glr-regression.at:1484;Leaked semantic values when reporting ambiguity;;
303;glr-regression.at:1577;Leaked lookahead after nondeterministic parse syntax error;;
304;glr-regression.at:1646;Uninitialized location when reporting ambiguity;;
305;glr-regression.at:1733;Missed %merge type warnings when LHS type is declared later;;
306;push.at:24;Memory Leak for Early Deletion;;
307;push.at:85;Multiple impure instances;;
308;push.at:156;Unsupported Skeletons;;
"

# at_fn_validate_ranges NAME...
# -----------------------------
# Validate and normalize the test group number contained in each variable
# NAME. Leading zeroes are treated as decimal.
at_fn_validate_ranges ()
{
  for at_grp
  do
    eval at_value=\$$at_grp
    if test $at_value -lt 1 || test $at_value -gt 308; then
      $as_echo "invalid test group: $at_value" >&2
      exit 1
    fi
    case $at_value in
      0*) # We want to treat leading 0 as decimal, like expr and test, but
	  # AS_VAR_ARITH treats it as octal if it uses $(( )).
	  # With XSI shells, ${at_value#${at_value%%[1-9]*}} avoids the
	  # expr fork, but it is not worth the effort to determine if the
	  # shell supports XSI when the user can just avoid leading 0.
	  eval $at_grp='`expr $at_value + 0`' ;;
    esac
  done
}

at_prev=
for at_option
do
  # If the previous option needs an argument, assign it.
  if test -n "$at_prev"; then
    at_option=$at_prev=$at_option
    at_prev=
  fi

  case $at_option in
  *=?*) at_optarg=`expr "X$at_option" : '[^=]*=\(.*\)'` ;;
  *)    at_optarg= ;;
  esac

  # Accept the important Cygnus configure options, so we can diagnose typos.

  case $at_option in
    --help | -h )
	at_help_p=:
	;;

    --list | -l )
	at_list_p=:
	;;

    --version | -V )
	at_version_p=:
	;;

    --clean | -c )
	at_clean=:
	;;

    --color )
	at_color=always
	;;
    --color=* )
	case $at_optarg in
	no | never | none) at_color=never ;;
	auto | tty | if-tty) at_color=auto ;;
	always | yes | force) at_color=always ;;
	*) at_optname=`echo " $at_option" | sed 's/^ //; s/=.*//'`
	   as_fn_error $? "unrecognized argument to $at_optname: $at_optarg" ;;
	esac
	;;

    --debug | -d )
	at_debug_p=:
	;;

    --errexit | -e )
	at_debug_p=:
	at_errexit_p=:
	;;

    --verbose | -v )
	at_verbose=; at_quiet=:
	;;

    --trace | -x )
	at_traceon='set -x'
	at_trace_echo=echo
	at_check_filter_trace=at_fn_filter_trace
	;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
	at_fn_validate_ranges at_option
	as_fn_append at_groups "$at_option "
	;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
	at_range_start=`echo $at_option |tr -d X-`
	at_fn_validate_ranges at_range_start
	at_range=`$as_echo " $at_groups_all " | \
	  sed -e 's/^.* \('$at_range_start' \)/\1/'`
	as_fn_append at_groups "$at_range "
	;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
	at_range_end=`echo $at_option |tr -d X-`
	at_fn_validate_ranges at_range_end
	at_range=`$as_echo " $at_groups_all " | \
	  sed -e 's/\( '$at_range_end'\) .*$/\1/'`
	as_fn_append at_groups "$at_range "
	;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
	at_range_start=`expr $at_option : '\(.*\)-'`
	at_range_end=`expr $at_option : '.*-\(.*\)'`
	if test $at_range_start -gt $at_range_end; then
	  at_tmp=$at_range_end
	  at_range_end=$at_range_start
	  at_range_start=$at_tmp
	fi
	at_fn_validate_ranges at_range_start at_range_end
	at_range=`$as_echo " $at_groups_all " | \
	  sed -e 's/^.*\( '$at_range_start' \)/\1/' \
	      -e 's/\( '$at_range_end'\) .*$/\1/'`
	as_fn_append at_groups "$at_range "
	;;

    # Directory selection.
    --directory | -C )
	at_prev=--directory
	;;
    --directory=* )
	at_change_dir=:
	at_dir=$at_optarg
	if test x- = "x$at_dir" ; then
	  at_dir=./-
	fi
	;;

    # Parallel execution.
    --jobs | -j )
	at_jobs=0
	;;
    --jobs=* | -j[0-9]* )
	if test -n "$at_optarg"; then
	  at_jobs=$at_optarg
	else
	  at_jobs=`expr X$at_option : 'X-j\(.*\)'`
	fi
	case $at_jobs in *[!0-9]*)
	  at_optname=`echo " $at_option" | sed 's/^ //; s/[0-9=].*//'`
	  as_fn_error $? "non-numeric argument to $at_optname: $at_jobs" ;;
	esac
	;;

    # Keywords.
    --keywords | -k )
	at_prev=--keywords
	;;
    --keywords=* )
	at_groups_selected=$at_help_all
	at_save_IFS=$IFS
	IFS=,
	set X $at_optarg
	shift
	IFS=$at_save_IFS
	for at_keyword
	do
	  at_invert=
	  case $at_keyword in
	  '!'*)
	    at_invert="-v"
	    at_keyword=`expr "X$at_keyword" : 'X!\(.*\)'`
	    ;;
	  esac
	  # It is on purpose that we match the test group titles too.
	  at_groups_selected=`$as_echo "$at_groups_selected" |
	      grep -i $at_invert "^[1-9][^;]*;.*[; ]$at_keyword[ ;]"`
	done
	# Smash the newlines.
	at_groups_selected=`$as_echo "$at_groups_selected" | sed 's/;.*//' |
	  tr "$as_nl" ' '
	`
	as_fn_append at_groups "$at_groups_selected "
	;;
    --recheck)
	at_recheck=:
	;;

    *=*)
	at_envvar=`expr "x$at_option" : 'x\([^=]*\)='`
	# Reject names that are not valid shell variable names.
	case $at_envvar in
	  '' | [0-9]* | *[!_$as_cr_alnum]* )
	    as_fn_error $? "invalid variable name: \`$at_envvar'" ;;
	esac
	at_value=`$as_echo "$at_optarg" | sed "s/'/'\\\\\\\\''/g"`
	# Export now, but save eval for later and for debug scripts.
	export $at_envvar
	as_fn_append at_debug_args " $at_envvar='$at_value'"
	;;

     *) $as_echo "$as_me: invalid option: $at_option" >&2
	$as_echo "Try \`$0 --help' for more information." >&2
	exit 1
	;;
  esac
done

# Verify our last option didn't require an argument
if test -n "$at_prev"; then :
  as_fn_error $? "\`$at_prev' requires an argument"
fi

# The file containing the suite.
at_suite_log=$at_dir/$as_me.log

# Selected test groups.
if test -z "$at_groups$at_recheck"; then
  at_groups=$at_groups_all
else
  if test -n "$at_recheck" && test -r "$at_suite_log"; then
    at_oldfails=`sed -n '
      /^Failed tests:$/,/^Skipped tests:$/{
	s/^[ ]*\([1-9][0-9]*\):.*/\1/p
      }
      /^Unexpected passes:$/,/^## Detailed failed tests/{
	s/^[ ]*\([1-9][0-9]*\):.*/\1/p
      }
      /^## Detailed failed tests/q
      ' "$at_suite_log" | tr "$as_nl" ' '`
    as_fn_append at_groups "$at_oldfails"
  fi
  # Sort the tests, removing duplicates.
  at_groups=`$as_echo "$at_groups" | tr ' ' "$as_nl" | sort -nu`
fi

if test x"$at_color" = xalways \
   || { test x"$at_color" = xauto && test -t 1; }; then
  at_red=`printf '\033[0;31m'`
  at_grn=`printf '\033[0;32m'`
  at_lgn=`printf '\033[1;32m'`
  at_blu=`printf '\033[1;34m'`
  at_std=`printf '\033[m'`
else
  at_red= at_grn= at_lgn= at_blu= at_std=
fi

# Help message.
if $at_help_p; then
  cat <<_ATEOF || at_write_fail=1
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, given by numeric ranges, and
save a detailed log file.  Upon failure, create debugging scripts.

Do not change environment variables directly.  Instead, set them via
command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relative to the top level of this distribution.
E.g., from within the build directory /tmp/foo-1.0, invoking this:

  $ $0 AUTOTEST_PATH=bin

is equivalent to the following, assuming the source directory is /src/foo-1.0:

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH $0
_ATEOF
cat <<_ATEOF || at_write_fail=1

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS
_ATEOF
cat <<_ATEOF || at_write_fail=1

Execution tuning:
  -C, --directory=DIR
                 change to directory DIR before starting
      --color[=never|auto|always]
                 enable colored test results on terminal, or always
  -j, --jobs[=N]
                 Allow N jobs at once; infinite jobs with no arg (default 1)
  -k, --keywords=KEYWORDS
                 select the tests matching all the comma-separated KEYWORDS
                 multiple \`-k' accumulate; prefixed \`!' negates a KEYWORD
      --recheck  select all tests that failed or passed unexpectedly last time
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
                 default for debugging scripts
  -d, --debug    inhibit clean up and top-level logging
                 default for debugging scripts
  -x, --trace    enable tests shell tracing
_ATEOF
cat <<_ATEOF || at_write_fail=1

Report bugs to <bug-bison@gnu.org>.
General help using GNU software: <http://www.gnu.org/gethelp/>.
_ATEOF
  exit $at_write_fail
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF || at_write_fail=1
GNU Bison 2.3b.564-5697 test suite test groups:

 NUM: FILE-NAME:LINE     TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # Passing at_groups is tricky.  We cannot use it to form a literal string
  # or regexp because of the limitation of AIX awk.  And Solaris' awk
  # doesn't grok more than 99 fields in a record, so we have to use `split'.
  # at_groups needs to be space-separated for this script to work.
  case $at_groups in
    *"$as_nl"* )
      at_groups=`$as_echo "$at_groups" | tr "$as_nl" ' '` ;;
  esac
  $as_echo "$at_groups$as_nl$at_help_all" |
    awk 'BEGIN { FS = ";" }
	 NR == 1 {
	   for (n = split ($ 0, a, " "); n; n--)
	     selected[a[n]] = 1
	   next
	 }
	 NF > 0 {
	   if (selected[$ 1]) {
	     printf " %3d: %-18s %s\n", $ 1, $ 2, $ 3
	     if ($ 4) {
	       lmax = 79
	       indent = "     "
	       line = indent
	       len = length (line)
	       n = split ($ 4, a, " ")
	       for (i = 1; i <= n; i++) {
		 l = length (a[i]) + 1
		 if (i > 1 && len + l > lmax) {
		   print line
		   line = indent " " a[i]
		   len = length (line)
		 } else {
		   line = line " " a[i]
		   len += l
		 }
	       }
	       if (n)
		 print line
	     }
	   }
	 }' || at_write_fail=1
  exit $at_write_fail
fi
if $at_version_p; then
  $as_echo "$as_me (GNU Bison 2.3b.564-5697)" &&
  cat <<\_ATEOF || at_write_fail=1

Copyright (C) 2010 Free Software Foundation, Inc.
This test suite is free software; the Free Software Foundation gives
unlimited permission to copy, distribute and modify it.
_ATEOF
  exit $at_write_fail
fi

# Should we print banners?  at_groups is space-separated for entire test,
# newline-separated if only a subset of the testsuite is run.
case $at_groups in
  *' '*' '* | *"$as_nl"*"$as_nl"* )
      at_print_banners=: ;;
  * ) at_print_banners=false ;;
esac
# Text for banner N, set to empty once printed.
# Banner 1. input.at:19
# Category starts at test group 1.
at_banner_text_1="Input Processing."
# Banner 2. named-refs.at:18
# Category starts at test group 32.
at_banner_text_2="Named references tests."
# Banner 3. output.at:19
# Category starts at test group 42.
at_banner_text_3="Output file names."
# Banner 4. skeletons.at:18
# Category starts at test group 79.
at_banner_text_4="Skeleton Support."
# Banner 5. sets.at:59
# Category starts at test group 85.
at_banner_text_5="Grammar Sets (Firsts etc.)."
# Banner 6. reduce.at:19
# Category starts at test group 89.
at_banner_text_6="Grammar Reduction."
# Banner 7. synclines.at:19
# Category starts at test group 115.
at_banner_text_7="User Actions."
# Banner 8. headers.at:19
# Category starts at test group 120.
at_banner_text_8="Parser Headers."
# Banner 9. actions.at:19
# Category starts at test group 124.
at_banner_text_9="User Actions."
# Banner 10. conflicts.at:19
# Category starts at test group 143.
at_banner_text_10="Conflicts."
# Banner 11. calc.at:601
# Category starts at test group 162.
at_banner_text_11="Simple LALR(1) Calculator."
# Banner 12. calc.at:640
# Category starts at test group 179.
at_banner_text_12="Simple GLR Calculator."
# Banner 13. calc.at:677
# Category starts at test group 194.
at_banner_text_13="Simple LALR(1) C++ Calculator."
# Banner 14. calc.at:707
# Category starts at test group 203.
at_banner_text_14="Simple GLR C++ Calculator."
# Banner 15. torture.at:19
# Category starts at test group 212.
at_banner_text_15="Torture Tests."
# Banner 16. existing.at:19
# Category starts at test group 217.
at_banner_text_16="Existing Grammars."
# Banner 17. regression.at:19
# Category starts at test group 226.
at_banner_text_17="Regression tests."
# Banner 18. c++.at:19
# Category starts at test group 253.
at_banner_text_18="C++ Features."
# Banner 19. java.at:18
# Category starts at test group 264.
at_banner_text_19="Java Calculator."
# Banner 20. java.at:408
# Category starts at test group 272.
at_banner_text_20="Java Parameters."
# Banner 21. cxx-type.at:19
# Category starts at test group 279.
at_banner_text_21="C++ Type Syntax (GLR)."
# Banner 22. glr-regression.at:19
# Category starts at test group 288.
at_banner_text_22="GLR Regression Tests"
# Banner 23. push.at:18
# Category starts at test group 306.
at_banner_text_23="Push Parsing Tests"

# Take any -C into account.
if $at_change_dir ; then
  test x != "x$at_dir" && cd "$at_dir" \
    || as_fn_error $? "unable to change directory"
  at_dir=`pwd`
fi

# Load the config files for any default variable assignments.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || as_fn_error $? "invalid content: $at_file"
done

# Autoconf <=2.59b set at_top_builddir instead of at_top_build_prefix:
: ${at_top_build_prefix=$at_top_builddir}

# Perform any assignments requested during argument parsing.
eval "$at_debug_args"

# atconfig delivers names relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir_var in srcdir top_srcdir top_build_prefix
  do
    eval at_val=\$at_$at_dir_var
    case $at_val in
      [\\/$]* | ?:[\\/]* ) at_prefix= ;;
      *) at_prefix=../../ ;;
    esac
    eval "$at_dir_var=\$at_prefix\$at_val"
  done
fi

## -------------------- ##
## Directory structure. ##
## -------------------- ##

# This is the set of directories and files used by this script
# (non-literals are capitalized):
#
# TESTSUITE         - the testsuite
# TESTSUITE.log     - summarizes the complete testsuite run
# TESTSUITE.dir/    - created during a run, remains after -d or failed test
# + at-groups/      - during a run: status of all groups in run
# | + NNN/          - during a run: meta-data about test group NNN
# | | + check-line  - location (source file and line) of current AT_CHECK
# | | + status      - exit status of current AT_CHECK
# | | + stdout      - stdout of current AT_CHECK
# | | + stder1      - stderr, including trace
# | | + stderr      - stderr, with trace filtered out
# | | + test-source - portion of testsuite that defines group
# | | + times       - timestamps for computing duration
# | | + pass        - created if group passed
# | | + xpass       - created if group xpassed
# | | + fail        - created if group failed
# | | + xfail       - created if group xfailed
# | | + skip        - created if group skipped
# + at-stop         - during a run: end the run if this file exists
# + at-source-lines - during a run: cache of TESTSUITE line numbers for extraction
# + 0..NNN/         - created for each group NNN, remains after -d or failed test
# | + TESTSUITE.log - summarizes the group results
# | + ...           - files created during the group

# The directory the whole suite works in.
# Should be absolute to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the suite ($at_dir might have changed since earlier).
at_suite_log=$at_dir/$as_me.log
# The directory containing helper files per test group.
at_helper_dir=$at_suite_dir/at-groups
# Stop file: if it exists, do not start new jobs.
at_stop_file=$at_suite_dir/at-stop
# The fifo used for the job dispatcher.
at_job_fifo=$at_suite_dir/at-job-fifo

if $at_clean; then
  test -d "$at_suite_dir" &&
    find "$at_suite_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
  rm -f -r "$at_suite_dir" "$at_suite_log"
  exit $?
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites (ie. atconfig was not found),
# AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
AUTOTEST_PATH=`$as_echo "$AUTOTEST_PATH" | sed "s|:|$PATH_SEPARATOR|g"`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -n "$at_path" && as_fn_append at_path $PATH_SEPARATOR
case $as_dir in
  [\\/]* | ?:[\\/]* )
    as_fn_append at_path "$as_dir"
    ;;
  * )
    if test -z "$at_top_build_prefix"; then
      # Stand-alone test suite.
      as_fn_append at_path "$as_dir"
    else
      # Embedded test suite.
      as_fn_append at_path "$at_top_build_prefix$as_dir$PATH_SEPARATOR"
      as_fn_append at_path "$at_top_srcdir/$as_dir"
    fi
    ;;
esac
  done
IFS=$as_save_IFS


# Now build and simplify PATH.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
at_new_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -d "$as_dir" || continue
case $as_dir in
  [\\/]* | ?:[\\/]* ) ;;
  * ) as_dir=`(cd "$as_dir" && pwd) 2>/dev/null` ;;
esac
case $PATH_SEPARATOR$at_new_path$PATH_SEPARATOR in
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR*) ;;
  $PATH_SEPARATOR$PATH_SEPARATOR) at_new_path=$as_dir ;;
  *) as_fn_append at_new_path "$PATH_SEPARATOR$as_dir" ;;
esac
  done
IFS=$as_save_IFS

PATH=$at_new_path
export PATH

# Setting up the FDs.



# 5 is the log file.  Not to be overwritten if `-d'.
if $at_debug_p; then
  at_suite_log=/dev/null
else
  : >"$at_suite_log"
fi
exec 5>>"$at_suite_log"

# Banners and logs.
$as_echo "## ----------------------------------- ##
## GNU Bison 2.3b.564-5697 test suite. ##
## ----------------------------------- ##"
{
  $as_echo "## ----------------------------------- ##
## GNU Bison 2.3b.564-5697 test suite. ##
## ----------------------------------- ##"
  echo

  $as_echo "$as_me: command line was:"
  $as_echo "  \$ $0 $at_cli_args"
  echo

  # If ChangeLog exists, list a few lines in case it might help determining
  # the exact version.
  if test -n "$at_top_srcdir" && test -f "$at_top_srcdir/ChangeLog"; then
    $as_echo "## ---------- ##
## ChangeLog. ##
## ---------- ##"
    echo
    sed 's/^/| /;10q' "$at_top_srcdir/ChangeLog"
    echo
  fi

  {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    $as_echo "PATH: $as_dir"
  done
IFS=$as_save_IFS

}
  echo

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    $as_echo "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done
} >&5


## ------------------------- ##
## Autotest shell functions. ##
## ------------------------- ##

# at_fn_banner NUMBER
# -------------------
# Output banner NUMBER, provided the testsuite is running multiple groups and
# this particular banner has not yet been printed.
at_fn_banner ()
{
  $at_print_banners || return 0
  eval at_banner_text=\$at_banner_text_$1
  test "x$at_banner_text" = x && return 0
  eval at_banner_text_$1=
  $as_echo "$as_nl$at_banner_text$as_nl"
} # at_fn_banner

# at_fn_check_prepare_notrace REASON LINE
# ---------------------------------------
# Perform AT_CHECK preparations for the command at LINE for an untraceable
# command; REASON is the reason for disabling tracing.
at_fn_check_prepare_notrace ()
{
  $at_trace_echo "Not enabling shell tracing (command contains $1)"
  $as_echo "$2" >"$at_check_line_file"
  at_check_trace=: at_check_filter=:
  : >"$at_stdout"; : >"$at_stderr"
}

# at_fn_check_prepare_trace LINE
# ------------------------------
# Perform AT_CHECK preparations for the command at LINE for a traceable
# command.
at_fn_check_prepare_trace ()
{
  $as_echo "$1" >"$at_check_line_file"
  at_check_trace=$at_traceon at_check_filter=$at_check_filter_trace
  : >"$at_stdout"; : >"$at_stderr"
}

# at_fn_check_prepare_dynamic COMMAND LINE
# ----------------------------------------
# Decide if COMMAND at LINE is traceable at runtime, and call the appropriate
# preparation function.
at_fn_check_prepare_dynamic ()
{
  case $1 in
    *$as_nl*)
      at_fn_check_prepare_notrace 'an embedded newline' "$2" ;;
    *)
      at_fn_check_prepare_trace "$2" ;;
  esac
}

# at_fn_filter_trace
# ------------------
# Remove the lines in the file "$at_stderr" generated by "set -x" and print
# them to stderr.
at_fn_filter_trace ()
{
  mv "$at_stderr" "$at_stder1"
  grep '^ *+' "$at_stder1" >&2
  grep -v '^ *+' "$at_stder1" >"$at_stderr"
}

# at_fn_log_failure FILE-LIST
# ---------------------------
# Copy the files in the list on stdout with a "> " prefix, and exit the shell
# with a failure exit code.
at_fn_log_failure ()
{
  for file
    do $as_echo "$file:"; sed 's/^/> /' "$file"; done
  echo 1 > "$at_status_file"
  exit 1
}

# at_fn_check_skip EXIT-CODE LINE
# -------------------------------
# Check whether EXIT-CODE is a special exit code (77 or 99), and if so exit
# the test group subshell with that same exit code. Use LINE in any report
# about test failure.
at_fn_check_skip ()
{
  case $1 in
    99) echo 99 > "$at_status_file"; at_failed=:
	$as_echo "$2: hard failure"; exit 99;;
    77) echo 77 > "$at_status_file"; exit 77;;
  esac
}

# at_fn_check_status EXPECTED EXIT-CODE LINE
# ------------------------------------------
# Check whether EXIT-CODE is the EXPECTED exit code, and if so do nothing.
# Otherwise, if it is 77 or 99, exit the test group subshell with that same
# exit code; if it is anything else print an error message referring to LINE,
# and fail the test.
at_fn_check_status ()
{
  case $2 in
    $1 ) ;;
    77) echo 77 > "$at_status_file"; exit 77;;
    99) echo 99 > "$at_status_file"; at_failed=:
	$as_echo "$3: hard failure"; exit 99;;
    *) $as_echo "$3: exit code was $2, expected $1"
      at_failed=:;;
  esac
}

# at_fn_diff_devnull FILE
# -----------------------
# Emit a diff between /dev/null and FILE. Uses "test -s" to avoid useless diff
# invocations.
at_fn_diff_devnull ()
{
  test -s "$1" || return 0
  $at_diff "$at_devnull" "$1"
}

# at_fn_test NUMBER
# -----------------
# Parse out test NUMBER from the tail of this file.
at_fn_test ()
{
  eval at_sed=\$at_sed$1
  sed "$at_sed" "$at_myself" > "$at_test_source"
}

# at_fn_create_debugging_script
# -----------------------------
# Create the debugging script $at_group_dir/run which will reproduce the
# current test group.
at_fn_create_debugging_script ()
{
  {
    echo "#! /bin/sh" &&
    echo 'test "${ZSH_VERSION+set}" = set && alias -g '\''${1+"$@"}'\''='\''"$@"'\''' &&
    $as_echo "cd '$at_dir'" &&
    $as_echo "exec \${CONFIG_SHELL-$SHELL} \"$at_myself\" -v -d $at_debug_args $at_group \${1+\"\$@\"}" &&
    echo 'exit 1'
  } >"$at_group_dir/run" &&
  chmod +x "$at_group_dir/run"
}

## -------------------------------- ##
## End of autotest shell functions. ##
## -------------------------------- ##
{
  $as_echo "## ---------------- ##
## Tested programs. ##
## ---------------- ##"
  echo
} >&5

# Report what programs are being tested.
for at_program in : $at_tested
do
  test "$at_program" = : && continue
  case $at_program in
    [\\/]* | ?:[\\/]* ) $at_program_=$at_program ;;
    * )
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -f "$as_dir/$at_program" && break
  done
IFS=$as_save_IFS

    at_program_=$as_dir/$at_program ;;
  esac
  if test -f "$at_program_"; then
    {
      $as_echo "$at_srcdir/local.at:525: $at_program_ --version"
      "$at_program_" --version </dev/null
      echo
    } >&5 2>&1
  else
    as_fn_error $? "cannot find $at_program" "$LINENO" 5
  fi
done

{
  $as_echo "## ------------------ ##
## Running the tests. ##
## ------------------ ##"
} >&5

at_start_date=`date`
at_start_time=`date +%s 2>/dev/null`
$as_echo "$as_me: starting at: $at_start_date" >&5

# Create the master directory if it doesn't already exist.
as_dir="$at_suite_dir"; as_fn_mkdir_p ||
  as_fn_error $? "cannot create \`$at_suite_dir'" "$LINENO" 5

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  >"$at_devnull"
fi

# Use `diff -u' when possible.
if at_diff=`diff -u "$at_devnull" "$at_devnull" 2>&1` && test -z "$at_diff"
then
  at_diff='diff -u'
else
  at_diff=diff
fi

# Get the last needed group.
for at_group in : $at_groups; do :; done

# Extract the start and end lines of each test group at the tail
# of this file
awk '
BEGIN { FS="" }
/^#AT_START_/ {
  start = NR
}
/^#AT_STOP_/ {
  test = substr ($ 0, 10)
  print "at_sed" test "=\"1," start "d;" (NR-1) "q\""
  if (test == "'"$at_group"'") exit
}' "$at_myself" > "$at_suite_dir/at-source-lines" &&
. "$at_suite_dir/at-source-lines" ||
  as_fn_error $? "cannot create test line number cache" "$LINENO" 5
rm -f "$at_suite_dir/at-source-lines"

# Set number of jobs for `-j'; avoid more jobs than test groups.
set X $at_groups; shift; at_max_jobs=$#
if test $at_max_jobs -eq 0; then
  at_jobs=1
fi
if test $at_jobs -ne 1 &&
   { test $at_jobs -eq 0 || test $at_jobs -gt $at_max_jobs; }; then
  at_jobs=$at_max_jobs
fi

# If parallel mode, don't output banners, don't split summary lines.
if test $at_jobs -ne 1; then
  at_print_banners=false
  at_quiet=:
fi

# Set up helper dirs.
rm -rf "$at_helper_dir" &&
mkdir "$at_helper_dir" &&
cd "$at_helper_dir" &&
{ test -z "$at_groups" || mkdir $at_groups; } ||
as_fn_error $? "testsuite directory setup failed" "$LINENO" 5

# Functions for running a test group.  We leave the actual
# test group execution outside of a shell function in order
# to avoid hitting zsh 4.x exit status bugs.

# at_fn_group_prepare
# -------------------
# Prepare for running a test group.
at_fn_group_prepare ()
{
  # The directory for additional per-group helper files.
  at_job_dir=$at_helper_dir/$at_group
  # The file containing the location of the last AT_CHECK.
  at_check_line_file=$at_job_dir/check-line
  # The file containing the exit status of the last command.
  at_status_file=$at_job_dir/status
  # The files containing the output of the tested commands.
  at_stdout=$at_job_dir/stdout
  at_stder1=$at_job_dir/stder1
  at_stderr=$at_job_dir/stderr
  # The file containing the code for a test group.
  at_test_source=$at_job_dir/test-source
  # The file containing dates.
  at_times_file=$at_job_dir/times

  # Be sure to come back to the top test directory.
  cd "$at_suite_dir"

  # Clearly separate the test groups when verbose.
  $at_first || $at_verbose echo

  at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'


  # Create a fresh directory for the next test group, and enter.
  # If one already exists, the user may have invoked ./run from
  # within that directory; we remove the contents, but not the
  # directory itself, so that we aren't pulling the rug out from
  # under the shell's notion of the current directory.
  at_group_dir=$at_suite_dir/$at_group_normalized
  at_group_log=$at_group_dir/$as_me.log
  if test -d "$at_group_dir"; then
  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx {} \;
  rm -fr "$at_group_dir"/* "$at_group_dir"/.[!.] "$at_group_dir"/.??*
fi ||
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: test directory for $at_group_normalized could not be cleaned" >&5
$as_echo "$as_me: WARNING: test directory for $at_group_normalized could not be cleaned" >&2;}
  # Be tolerant if the above `rm' was not able to remove the directory.
  as_dir="$at_group_dir"; as_fn_mkdir_p

  echo 0 > "$at_status_file"

  # In verbose mode, append to the log file *and* show on
  # the standard output; in quiet mode only write to the log.
  if test -z "$at_verbose"; then
    at_tee_pipe='tee -a "$at_group_log"'
  else
    at_tee_pipe='cat >> "$at_group_log"'
  fi
}

# at_fn_group_banner ORDINAL LINE DESC PAD [BANNER]
# -------------------------------------------------
# Declare the test group ORDINAL, located at LINE with group description DESC,
# and residing under BANNER. Use PAD to align the status column.
at_fn_group_banner ()
{
  at_setup_line="$2"
  test -n "$5" && at_fn_banner $5
  at_desc="$3"
  case $1 in
    [0-9])      at_desc_line="  $1: ";;
    [0-9][0-9]) at_desc_line=" $1: " ;;
    *)          at_desc_line="$1: "  ;;
  esac
  as_fn_append at_desc_line "$3$4"
  $at_quiet $as_echo_n "$at_desc_line"
  echo "#                             -*- compilation -*-" >> "$at_group_log"
}

# at_fn_group_postprocess
# -----------------------
# Perform cleanup after running a test group.
at_fn_group_postprocess ()
{
  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd "$at_suite_dir"

  if test ! -f "$at_check_line_file"; then
    sed "s/^ */$as_me: WARNING: /" <<_ATEOF
      A failure happened in a test group before any test could be
      run. This means that test suite is improperly designed.  Please
      report this failure to <bug-bison@gnu.org>.
_ATEOF
    $as_echo "$at_setup_line" >"$at_check_line_file"
    at_status=99
  fi
  $at_verbose $as_echo_n "$at_group. $at_setup_line: "
  $as_echo_n "$at_group. $at_setup_line: " >> "$at_group_log"
  case $at_xfail:$at_status in
    yes:0)
	at_msg="UNEXPECTED PASS"
	at_res=xpass
	at_errexit=$at_errexit_p
	at_color=$at_red
	;;
    no:0)
	at_msg="ok"
	at_res=pass
	at_errexit=false
	at_color=$at_grn
	;;
    *:77)
	at_msg='skipped ('`cat "$at_check_line_file"`')'
	at_res=skip
	at_errexit=false
	at_color=$at_blu
	;;
    no:* | *:99)
	at_msg='FAILED ('`cat "$at_check_line_file"`')'
	at_res=fail
	at_errexit=$at_errexit_p
	at_color=$at_red
	;;
    yes:*)
	at_msg='expected failure ('`cat "$at_check_line_file"`')'
	at_res=xfail
	at_errexit=false
	at_color=$at_lgn
	;;
  esac
  echo "$at_res" > "$at_job_dir/$at_res"
  # In parallel mode, output the summary line only afterwards.
  if test $at_jobs -ne 1 && test -n "$at_verbose"; then
    $as_echo "$at_desc_line $at_color$at_msg$at_std"
  else
    # Make sure there is a separator even with long titles.
    $as_echo " $at_color$at_msg$at_std"
  fi
  at_log_msg="$at_group. $at_desc ($at_setup_line): $at_msg"
  case $at_status in
    0|77)
      # $at_times_file is only available if the group succeeded.
      # We're not including the group log, so the success message
      # is written in the global log separately.  But we also
      # write to the group log in case they're using -d.
      if test -f "$at_times_file"; then
	at_log_msg="$at_log_msg     ("`sed 1d "$at_times_file"`')'
	rm -f "$at_times_file"
      fi
      $as_echo "$at_log_msg" >> "$at_group_log"
      $as_echo "$at_log_msg" >&5

      # Cleanup the group directory, unless the user wants the files.
      if $at_debug_p; then
	at_fn_create_debugging_script
      else
	if test -d "$at_group_dir"; then
	  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
	  rm -fr "$at_group_dir"
	fi
	rm -f "$at_test_source"
      fi
      ;;
    *)
      # Upon failure, include the log into the testsuite's global
      # log.  The failure message is written in the group log.  It
      # is later included in the global log.
      $as_echo "$at_log_msg" >> "$at_group_log"

      # Upon failure, keep the group directory for autopsy, and create
      # the debugging script.  With -e, do not start any further tests.
      at_fn_create_debugging_script
      if $at_errexit; then
	echo stop > "$at_stop_file"
      fi
      ;;
  esac
}


## ------------ ##
## Driver loop. ##
## ------------ ##


if (set -m && set +m && set +b) >/dev/null 2>&1; then
  set +b
  at_job_control_on='set -m' at_job_control_off='set +m' at_job_group=-
else
  at_job_control_on=: at_job_control_off=: at_job_group=
fi

for at_signal in 1 2 15; do
  trap 'set +x; set +e
	$at_job_control_off
	at_signal='"$at_signal"'
	echo stop > "$at_stop_file"
	trap "" $at_signal
	at_pgids=
	for at_pgid in `jobs -p 2>/dev/null`; do
	  at_pgids="$at_pgids $at_job_group$at_pgid"
	done
	test -z "$at_pgids" || kill -$at_signal $at_pgids 2>/dev/null
	wait
	if test "$at_jobs" -eq 1 || test -z "$at_verbose"; then
	  echo >&2
	fi
	at_signame=`kill -l $at_signal 2>&1 || echo $at_signal`
	set x $at_signame
	test 0 -gt 2 && at_signame=$at_signal
	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: caught signal $at_signame, bailing out" >&5
$as_echo "$as_me: WARNING: caught signal $at_signame, bailing out" >&2;}
	as_fn_arith 128 + $at_signal && exit_status=$as_val
	as_fn_exit $exit_status' $at_signal
done

rm -f "$at_stop_file"
at_first=:

if test $at_jobs -ne 1 &&
     rm -f "$at_job_fifo" &&
     test -n "$at_job_group" &&
     ( mkfifo "$at_job_fifo" && trap 'exit 1' PIPE STOP TSTP ) 2>/dev/null
then
  # FIFO job dispatcher.

  trap 'at_pids=
	for at_pid in `jobs -p`; do
	  at_pids="$at_pids $at_job_group$at_pid"
	done
	if test -n "$at_pids"; then
	  at_sig=TSTP
	  test "${TMOUT+set}" = set && at_sig=STOP
	  kill -$at_sig $at_pids 2>/dev/null
	fi
	kill -STOP $$
	test -z "$at_pids" || kill -CONT $at_pids 2>/dev/null' TSTP

  echo
  # Turn jobs into a list of numbers, starting from 1.
  at_joblist=`$as_echo " $at_groups_all " | \
    sed 's/\( '$at_jobs'\) .*/\1/'`

  set X $at_joblist
  shift
  for at_group in $at_groups; do
    $at_job_control_on 2>/dev/null
    (
      # Start one test group.
      $at_job_control_off
      if $at_first; then
	exec 7>"$at_job_fifo"
      else
	exec 6<&-
      fi
      trap 'set +x; set +e
	    trap "" PIPE
	    echo stop > "$at_stop_file"
	    echo >&7
	    as_fn_exit 141' PIPE
      at_fn_group_prepare
      if cd "$at_group_dir" &&
	 at_fn_test $at_group &&
	 . "$at_test_source"
      then :; else
	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unable to parse test group: $at_group" >&5
$as_echo "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
	at_failed=:
      fi
      at_fn_group_postprocess
      echo >&7
    ) &
    $at_job_control_off
    if $at_first; then
      at_first=false
      exec 6<"$at_job_fifo" 7>"$at_job_fifo"
    fi
    shift # Consume one token.
    if test $# -gt 0; then :; else
      read at_token <&6 || break
      set x $*
    fi
    test -f "$at_stop_file" && break
  done
  exec 7>&-
  # Read back the remaining ($at_jobs - 1) tokens.
  set X $at_joblist
  shift
  if test $# -gt 0; then
    shift
    for at_job
    do
      read at_token
    done <&6
  fi
  exec 6<&-
  wait
else
  # Run serially, avoid forks and other potential surprises.
  for at_group in $at_groups; do
    at_fn_group_prepare
    if cd "$at_group_dir" &&
       at_fn_test $at_group &&
       . "$at_test_source"; then :; else
      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unable to parse test group: $at_group" >&5
$as_echo "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
      at_failed=:
    fi
    at_fn_group_postprocess
    test -f "$at_stop_file" && break
    at_first=false
  done
fi

# Wrap up the test suite with summary statistics.
cd "$at_helper_dir"

# Use ?..???? when the list must remain sorted, the faster * otherwise.
at_pass_list=`for f in */pass; do echo $f; done | sed '/\*/d; s,/pass,,'`
at_skip_list=`for f in */skip; do echo $f; done | sed '/\*/d; s,/skip,,'`
at_xfail_list=`for f in */xfail; do echo $f; done | sed '/\*/d; s,/xfail,,'`
at_xpass_list=`for f in ?/xpass ??/xpass ???/xpass ????/xpass; do
		 echo $f; done | sed '/?/d; s,/xpass,,'`
at_fail_list=`for f in ?/fail ??/fail ???/fail ????/fail; do
		echo $f; done | sed '/?/d; s,/fail,,'`

set X $at_pass_list $at_xpass_list $at_xfail_list $at_fail_list $at_skip_list
shift; at_group_count=$#
set X $at_xpass_list; shift; at_xpass_count=$#; at_xpass_list=$*
set X $at_xfail_list; shift; at_xfail_count=$#
set X $at_fail_list; shift; at_fail_count=$#; at_fail_list=$*
set X $at_skip_list; shift; at_skip_count=$#

as_fn_arith $at_group_count - $at_skip_count && at_run_count=$as_val
as_fn_arith $at_xpass_count + $at_fail_count && at_unexpected_count=$as_val
as_fn_arith $at_xfail_count + $at_fail_count && at_total_fail_count=$as_val

# Back to the top directory.
cd "$at_dir"
rm -rf "$at_helper_dir"

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`date +%s 2>/dev/null`
$as_echo "$as_me: ending at: $at_stop_date" >&5
case $at_start_time,$at_stop_time in
  [0-9]*,[0-9]*)
    as_fn_arith $at_stop_time - $at_start_time && at_duration_s=$as_val
    as_fn_arith $at_duration_s / 60 && at_duration_m=$as_val
    as_fn_arith $at_duration_m / 60 && at_duration_h=$as_val
    as_fn_arith $at_duration_s % 60 && at_duration_s=$as_val
    as_fn_arith $at_duration_m % 60 && at_duration_m=$as_val
    at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
    $as_echo "$as_me: test suite duration: $at_duration" >&5
    ;;
esac

echo
$as_echo "## ------------- ##
## Test results. ##
## ------------- ##"
echo
{
  echo
  $as_echo "## ------------- ##
## Test results. ##
## ------------- ##"
  echo
} >&5

if test $at_run_count = 1; then
  at_result="1 test"
  at_were=was
else
  at_result="$at_run_count tests"
  at_were=were
fi
if $at_errexit_p && test $at_unexpected_count != 0; then
  if test $at_xpass_count = 1; then
    at_result="$at_result $at_were run, one passed"
  else
    at_result="$at_result $at_were run, one failed"
  fi
  at_result="$at_result unexpectedly and inhibited subsequent tests."
  at_color=$at_red
else
  # Don't you just love exponential explosion of the number of cases?
  at_color=$at_red
  case $at_xpass_count:$at_fail_count:$at_xfail_count in
    # So far, so good.
    0:0:0) at_result="$at_result $at_were successful." at_color=$at_grn ;;
    0:0:*) at_result="$at_result behaved as expected." at_color=$at_lgn ;;

    # Some unexpected failures
    0:*:0) at_result="$at_result $at_were run,
$at_fail_count failed unexpectedly." ;;

    # Some failures, both expected and unexpected
    0:*:1) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    0:*:*) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;

    # No unexpected failures, but some xpasses
    *:0:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly." ;;

    # No expected failures, but failures and xpasses
    *:1:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failure)." ;;
    *:*:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failures)." ;;

    # All of them.
    *:*:1) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    *:*:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;
  esac

  if test $at_skip_count = 0 && test $at_run_count -gt 1; then
    at_result="All $at_result"
  fi
fi

# Now put skips in the mix.
case $at_skip_count in
  0) ;;
  1) at_result="$at_result
1 test was skipped." ;;
  *) at_result="$at_result
$at_skip_count tests were skipped." ;;
esac

if test $at_unexpected_count = 0; then
  echo "$at_color$at_result$at_std"
  echo "$at_result" >&5
else
  echo "${at_color}ERROR: $at_result$at_std" >&2
  echo "ERROR: $at_result" >&5
  {
    echo
    $as_echo "## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##"

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL "$at_myself" $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL "$at_myself" $at_skip_list --list
      echo
    fi
    if test $at_xpass_count != 0; then
      echo "Unexpected passes:"
      $SHELL "$at_myself" $at_xpass_list --list
      echo
    fi
    if test $at_fail_count != 0; then
      $as_echo "## ---------------------- ##
## Detailed failed tests. ##
## ---------------------- ##"
      echo
      for at_group in $at_fail_list
      do
	at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'

	cat "$at_suite_dir/$at_group_normalized/$as_me.log"
	echo
      done
      echo
    fi
    if test -n "$at_top_srcdir"; then
      sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## ${at_top_build_prefix}config.log ##
_ASBOX
      sed 's/^/| /' ${at_top_build_prefix}config.log
      echo
    fi
  } >&5

  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log was created. ##
_ASBOX

  echo
  if $at_debug_p; then
    at_msg='per-test log files'
  else
    at_msg="\`${at_testdir+${at_testdir}/}$as_me.log'"
  fi
  $as_echo "Please send $at_msg and all information you think might help:

   To: <bug-bison@gnu.org>
   Subject: [GNU Bison 2.3b.564-5697] $as_me: $at_fail_list${at_fail_list:+ failed${at_xpass_list:+, }}$at_xpass_list${at_xpass_list:+ passed unexpectedly}

You may investigate any problem if you feel able to do so, in which
case the test suite provides a good starting point.  Its output may
be found below \`${at_testdir+${at_testdir}/}$as_me.dir'.
"
  exit 1
fi

exit 0

## ------------- ##
## Actual tests. ##
## ------------- ##
#AT_START_1
at_fn_group_banner 1 'input.at:28' \
  "Invalid \$n and @n" "                              " 1
at_xfail=no
(
  $as_echo "1. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%%
exp: { $$ = $1 ; };
exp: { @$ = @1 ; };
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:36: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:36"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:2.13-14: integer out of range: \`\$1'
input.y:3.13-14: integer out of range: \`@1'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:36"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_1
#AT_START_2
at_fn_group_banner 2 'input.at:48' \
  "Type Clashes" "                                   " 1
at_xfail=no
(
  $as_echo "2. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%union { int bar; }
%token foo
%type <bar> exp
%%
exp: foo { $$; } foo { $2; } foo
   | foo
   | /* Empty. */
   ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:61: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:61"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:5.12-13: \$\$ for the midrule at \$2 of \`exp' has no declared type
input.y:5.24-25: \$2 of \`exp' has no declared type
input.y:5.6-32: warning: type clash on default action: <bar> != <>
input.y:6.6-8: warning: type clash on default action: <bar> != <>
input.y:7.5: warning: empty rule for typed nonterminal, and no action
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:61"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_2
#AT_START_3
at_fn_group_banner 3 'input.at:157' \
  "Unused values" "                                  " 1
at_xfail=no
(
  $as_echo "3. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >input.y <<'_ATEOF'
%token <integer> INT;
%type <integer> a b c d e f g h i j k l;
%destructor { destroy ($$); } INT a b c d e f g h i j k l;
%%
start:
  'a' a { $2; } | 'b' b { $2; } | 'c' c { $2; } | 'd' d { $2; }
| 'e' e { $2; } | 'f' f { $2; } | 'g' g { $2; } | 'h' h { $2; }
| 'i' i { $2; } | 'j' j { $2; } | 'k' k { $2; } | 'l' l { $2; }
;

a: INT | INT { } INT { } INT { };
b: INT | /* empty */;
c: INT | INT { $1; } INT { $<integer>2; } INT { $<integer>4; };
d: INT | INT { } INT { $1; } INT { $<integer>2; };
e: INT | INT { } INT {  } INT { $1; };
f: INT | INT { } INT {  } INT { $$ = $1 + $3 + $5; };
g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };
h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };
i: INT | INT INT { } { $$ = $1 + $2; };
j: INT | INT INT { $<integer>$ = 1; } { $$ = $1 + $2; };
k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };
l: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:158: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:158"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:158"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:158: bison --xml=xml-tests/test.xml  input.y"
at_fn_check_prepare_trace "input.at:158"
( $at_check_trace; bison --xml=xml-tests/test.xml  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:158"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:158: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:158"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:158"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:158: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:158"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:158"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:158: bison  input.y"
at_fn_check_prepare_trace "input.at:158"
( $at_check_trace; bison  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:11.10-32: warning: unset value: \$\$
input.y:11.10-32: warning: unused value: \$1
input.y:11.10-32: warning: unused value: \$3
input.y:11.10-32: warning: unused value: \$5
input.y:12.9: warning: empty rule for typed nonterminal, and no action
input.y:13.10-62: warning: unset value: \$\$
input.y:13.10-62: warning: unused value: \$3
input.y:13.10-62: warning: unused value: \$5
input.y:14.10-49: warning: unset value: \$\$
input.y:14.10-49: warning: unused value: \$3
input.y:14.10-49: warning: unused value: \$5
input.y:15.10-37: warning: unset value: \$\$
input.y:15.10-37: warning: unused value: \$3
input.y:15.10-37: warning: unused value: \$5
input.y:17.10-58: warning: unset value: \$\$
input.y:17.10-58: warning: unused value: \$1
input.y:17.10-58: warning: unused value: \$3
input.y:17.10-58: warning: unused value: \$5
input.y:18.10-72: warning: unset value: \$\$
input.y:18.10-72: warning: unused value: \$1
input.y:18.10-72: warning: unused value: \$3
input.y:18.10-72: warning: unused value: \$5
input.y:21.10-68: warning: unset value: \$\$
input.y:21.10-68: warning: unused value: \$1
input.y:21.10-68: warning: unused value: \$2
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:158"
$at_failed && at_fn_log_failure
$at_traceon; }

cat >input.y <<'_ATEOF'
%token <integer> INT;
%type <integer> a b c d e f g h i j k l;
%destructor { destroy ($$); } INT a b c d e f g h i j k l;
%%
start:
  'a' a { $2; } | 'b' b { $2; } | 'c' c { $2; } | 'd' d { $2; }
| 'e' e { $2; } | 'f' f { $2; } | 'g' g { $2; } | 'h' h { $2; }
| 'i' i { $2; } | 'j' j { $2; } | 'k' k { $2; } | 'l' l { $2; }
;

a: INT | INT { } INT { } INT { };
b: INT | /* empty */;
c: INT | INT { $1; } INT { $<integer>2; } INT { $<integer>4; };
d: INT | INT { } INT { $1; } INT { $<integer>2; };
e: INT | INT { } INT {  } INT { $1; };
f: INT | INT { } INT {  } INT { $$ = $1 + $3 + $5; };
g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };
h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };
i: INT | INT INT { } { $$ = $1 + $2; };
j: INT | INT INT { $<integer>$ = 1; } { $$ = $1 + $2; };
k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };
l: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:159: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:159"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:159"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:159: bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y"
at_fn_check_prepare_trace "input.at:159"
( $at_check_trace; bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:159"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:159: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:159"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:159"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:159: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:159"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:159"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:159: bison  --warnings=midrule-values  input.y"
at_fn_check_prepare_trace "input.at:159"
( $at_check_trace; bison  --warnings=midrule-values  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:11.10-32: warning: unset value: \$\$
input.y:11.10-32: warning: unused value: \$1
input.y:11.10-32: warning: unused value: \$3
input.y:11.10-32: warning: unused value: \$5
input.y:12.9: warning: empty rule for typed nonterminal, and no action
input.y:13.14-20: warning: unset value: \$\$
input.y:13.26-41: warning: unset value: \$\$
input.y:13.10-62: warning: unset value: \$\$
input.y:13.10-62: warning: unused value: \$3
input.y:13.10-62: warning: unused value: \$5
input.y:14.14-16: warning: unset value: \$\$
input.y:14.10-49: warning: unset value: \$\$
input.y:14.10-49: warning: unused value: \$3
input.y:14.10-49: warning: unused value: \$5
input.y:15.10-37: warning: unset value: \$\$
input.y:15.10-37: warning: unused value: \$3
input.y:15.10-37: warning: unused value: \$5
input.y:17.10-58: warning: unset value: \$\$
input.y:17.10-58: warning: unused value: \$1
input.y:17.10-58: warning: unused value: \$2
input.y:17.10-58: warning: unused value: \$3
input.y:17.10-58: warning: unused value: \$4
input.y:17.10-58: warning: unused value: \$5
input.y:18.10-72: warning: unset value: \$\$
input.y:18.10-72: warning: unused value: \$1
input.y:18.10-72: warning: unused value: \$3
input.y:18.10-72: warning: unused value: \$4
input.y:18.10-72: warning: unused value: \$5
input.y:20.10-55: warning: unused value: \$3
input.y:21.10-68: warning: unset value: \$\$
input.y:21.10-68: warning: unused value: \$1
input.y:21.10-68: warning: unused value: \$2
input.y:21.10-68: warning: unused value: \$4
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:159"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_3
#AT_START_4
at_fn_group_banner 4 'input.at:167' \
  "Unused values before symbol declarations" "       " 1
at_xfail=no
(
  $as_echo "4. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >input.y <<'_ATEOF'



%%
start:
  'a' a { $2; } | 'b' b { $2; } | 'c' c { $2; } | 'd' d { $2; }
| 'e' e { $2; } | 'f' f { $2; } | 'g' g { $2; } | 'h' h { $2; }
| 'i' i { $2; } | 'j' j { $2; } | 'k' k { $2; } | 'l' l { $2; }
;

a: INT | INT { } INT { } INT { };
b: INT | /* empty */;
c: INT | INT { $1; } INT { $<integer>2; } INT { $<integer>4; };
d: INT | INT { } INT { $1; } INT { $<integer>2; };
e: INT | INT { } INT {  } INT { $1; };
f: INT | INT { } INT {  } INT { $$ = $1 + $3 + $5; };
g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };
h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };
i: INT | INT INT { } { $$ = $1 + $2; };
j: INT | INT INT { $<integer>$ = 1; } { $$ = $1 + $2; };
k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };
l: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };
%token <integer> INT;
%type <integer> a b c d e f g h i j k l;
%destructor { destroy ($$); } INT a b c d e f g h i j k l;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:168: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:168"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:168"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:168: bison --xml=xml-tests/test.xml  input.y"
at_fn_check_prepare_trace "input.at:168"
( $at_check_trace; bison --xml=xml-tests/test.xml  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:168"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:168: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:168"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:168"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:168: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:168"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:168"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:168: bison  input.y"
at_fn_check_prepare_trace "input.at:168"
( $at_check_trace; bison  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:11.10-32: warning: unset value: \$\$
input.y:11.10-32: warning: unused value: \$1
input.y:11.10-32: warning: unused value: \$3
input.y:11.10-32: warning: unused value: \$5
input.y:12.9: warning: empty rule for typed nonterminal, and no action
input.y:13.10-62: warning: unset value: \$\$
input.y:13.10-62: warning: unused value: \$3
input.y:13.10-62: warning: unused value: \$5
input.y:14.10-49: warning: unset value: \$\$
input.y:14.10-49: warning: unused value: \$3
input.y:14.10-49: warning: unused value: \$5
input.y:15.10-37: warning: unset value: \$\$
input.y:15.10-37: warning: unused value: \$3
input.y:15.10-37: warning: unused value: \$5
input.y:17.10-58: warning: unset value: \$\$
input.y:17.10-58: warning: unused value: \$1
input.y:17.10-58: warning: unused value: \$3
input.y:17.10-58: warning: unused value: \$5
input.y:18.10-72: warning: unset value: \$\$
input.y:18.10-72: warning: unused value: \$1
input.y:18.10-72: warning: unused value: \$3
input.y:18.10-72: warning: unused value: \$5
input.y:21.10-68: warning: unset value: \$\$
input.y:21.10-68: warning: unused value: \$1
input.y:21.10-68: warning: unused value: \$2
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:168"
$at_failed && at_fn_log_failure
$at_traceon; }

cat >input.y <<'_ATEOF'



%%
start:
  'a' a { $2; } | 'b' b { $2; } | 'c' c { $2; } | 'd' d { $2; }
| 'e' e { $2; } | 'f' f { $2; } | 'g' g { $2; } | 'h' h { $2; }
| 'i' i { $2; } | 'j' j { $2; } | 'k' k { $2; } | 'l' l { $2; }
;

a: INT | INT { } INT { } INT { };
b: INT | /* empty */;
c: INT | INT { $1; } INT { $<integer>2; } INT { $<integer>4; };
d: INT | INT { } INT { $1; } INT { $<integer>2; };
e: INT | INT { } INT {  } INT { $1; };
f: INT | INT { } INT {  } INT { $$ = $1 + $3 + $5; };
g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };
h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };
i: INT | INT INT { } { $$ = $1 + $2; };
j: INT | INT INT { $<integer>$ = 1; } { $$ = $1 + $2; };
k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };
l: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };
%token <integer> INT;
%type <integer> a b c d e f g h i j k l;
%destructor { destroy ($$); } INT a b c d e f g h i j k l;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:169: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:169"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:169: bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y"
at_fn_check_prepare_trace "input.at:169"
( $at_check_trace; bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:169: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:169"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:169: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:169"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:169: bison  --warnings=midrule-values  input.y"
at_fn_check_prepare_trace "input.at:169"
( $at_check_trace; bison  --warnings=midrule-values  input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:11.10-32: warning: unset value: \$\$
input.y:11.10-32: warning: unused value: \$1
input.y:11.10-32: warning: unused value: \$3
input.y:11.10-32: warning: unused value: \$5
input.y:12.9: warning: empty rule for typed nonterminal, and no action
input.y:13.14-20: warning: unset value: \$\$
input.y:13.26-41: warning: unset value: \$\$
input.y:13.10-62: warning: unset value: \$\$
input.y:13.10-62: warning: unused value: \$3
input.y:13.10-62: warning: unused value: \$5
input.y:14.14-16: warning: unset value: \$\$
input.y:14.10-49: warning: unset value: \$\$
input.y:14.10-49: warning: unused value: \$3
input.y:14.10-49: warning: unused value: \$5
input.y:15.10-37: warning: unset value: \$\$
input.y:15.10-37: warning: unused value: \$3
input.y:15.10-37: warning: unused value: \$5
input.y:17.10-58: warning: unset value: \$\$
input.y:17.10-58: warning: unused value: \$1
input.y:17.10-58: warning: unused value: \$2
input.y:17.10-58: warning: unused value: \$3
input.y:17.10-58: warning: unused value: \$4
input.y:17.10-58: warning: unused value: \$5
input.y:18.10-72: warning: unset value: \$\$
input.y:18.10-72: warning: unused value: \$1
input.y:18.10-72: warning: unused value: \$3
input.y:18.10-72: warning: unused value: \$4
input.y:18.10-72: warning: unused value: \$5
input.y:20.10-55: warning: unused value: \$3
input.y:21.10-68: warning: unset value: \$\$
input.y:21.10-68: warning: unused value: \$1
input.y:21.10-68: warning: unused value: \$2
input.y:21.10-68: warning: unused value: \$4
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_4
#AT_START_5
at_fn_group_banner 5 'input.at:177' \
  "Default %printer and %destructor redeclared" "    " 1
at_xfail=no
(
  $as_echo "5. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <*> <*>
%printer { destroy ($$); } <*> <*>

%destructor { destroy ($$); } <*>
%printer { destroy ($$); } <*>

%destructor { destroy ($$); } <> <>
%printer { destroy ($$); } <> <>

%destructor { destroy ($$); } <>
%printer { destroy ($$); } <>

%%

start: ;

%destructor { destroy ($$); } <*>;
%printer { destroy ($$); } <*>;

%destructor { destroy ($$); } <>;
%printer { destroy ($$); } <>;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:203: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:203"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.13-29: redeclaration for default tagged %destructor
input.y:1.13-29: previous declaration
input.y:2.10-26: redeclaration for default tagged %printer
input.y:2.10-26: previous declaration
input.y:4.13-29: redeclaration for default tagged %destructor
input.y:1.13-29: previous declaration
input.y:5.10-26: redeclaration for default tagged %printer
input.y:2.10-26: previous declaration
input.y:7.13-29: redeclaration for default tagless %destructor
input.y:7.13-29: previous declaration
input.y:8.10-26: redeclaration for default tagless %printer
input.y:8.10-26: previous declaration
input.y:10.13-29: redeclaration for default tagless %destructor
input.y:7.13-29: previous declaration
input.y:11.10-26: redeclaration for default tagless %printer
input.y:8.10-26: previous declaration
input.y:17.13-29: redeclaration for default tagged %destructor
input.y:4.13-29: previous declaration
input.y:18.10-26: redeclaration for default tagged %printer
input.y:5.10-26: previous declaration
input.y:20.13-29: redeclaration for default tagless %destructor
input.y:10.13-29: previous declaration
input.y:21.10-26: redeclaration for default tagless %printer
input.y:11.10-26: previous declaration
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:203"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_5
#AT_START_6
at_fn_group_banner 6 'input.at:237' \
  "Per-type %printer and %destructor redeclared" "   " 1
at_xfail=no
(
  $as_echo "6. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <field1> <field2>
%printer { destroy ($$); } <field1> <field2>

%destructor { destroy ($$); } <field1> <field1>
%printer { destroy ($$); } <field2> <field2>

%%

start: ;

%destructor { destroy ($$); } <field2> <field1>;
%printer { destroy ($$); } <field2> <field1>;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:254: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:254"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:4.13-29: %destructor redeclaration for <field1>
input.y:1.13-29: previous declaration
input.y:4.13-29: %destructor redeclaration for <field1>
input.y:4.13-29: previous declaration
input.y:5.10-26: %printer redeclaration for <field2>
input.y:2.10-26: previous declaration
input.y:5.10-26: %printer redeclaration for <field2>
input.y:5.10-26: previous declaration
input.y:11.13-29: %destructor redeclaration for <field1>
input.y:4.13-29: previous declaration
input.y:11.13-29: %destructor redeclaration for <field2>
input.y:1.13-29: previous declaration
input.y:12.10-26: %printer redeclaration for <field1>
input.y:2.10-26: previous declaration
input.y:12.10-26: %printer redeclaration for <field2>
input.y:5.10-26: previous declaration
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:254"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_6
#AT_START_7
at_fn_group_banner 7 'input.at:280' \
  "Unused values with default %destructor" "         " 1
at_xfail=no
(
  $as_echo "7. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <>
%type <tag> tagged

%%

start: end end tagged tagged { $<tag>1; $3; } ;
end: { } ;
tagged: { } ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:293: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:293"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:293"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:293: bison --xml=xml-tests/test.xml input.y"
at_fn_check_prepare_trace "input.at:293"
( $at_check_trace; bison --xml=xml-tests/test.xml input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:293"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:293: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:293"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:293"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:293: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:293"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:293"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:293: bison input.y"
at_fn_check_prepare_trace "input.at:293"
( $at_check_trace; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:6.8-45: warning: unset value: \$\$
input.y:6.8-45: warning: unused value: \$2
input.y:7.6-8: warning: unset value: \$\$
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:293"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <*>
%type <tag> tagged

%%

start: end end tagged tagged { $<tag>1; $3; } ;
end: { } ;
tagged: { } ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:310: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:310"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:310"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:310: bison --xml=xml-tests/test.xml input.y"
at_fn_check_prepare_trace "input.at:310"
( $at_check_trace; bison --xml=xml-tests/test.xml input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:310"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:310: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:310"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:310"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:310: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:310"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:310"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:310: bison input.y"
at_fn_check_prepare_trace "input.at:310"
( $at_check_trace; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:6.8-45: warning: unused value: \$4
input.y:8.9-11: warning: unset value: \$\$
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:310"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_7
#AT_START_8
at_fn_group_banner 8 'input.at:322' \
  "Unused values with per-type %destructor" "        " 1
at_xfail=no
(
  $as_echo "8. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <field1>
%type <field1> start end

%%

start: end end { $1; } ;
end: { }  ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:334: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:334"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:334"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:334: bison --xml=xml-tests/test.xml input.y"
at_fn_check_prepare_trace "input.at:334"
( $at_check_trace; bison --xml=xml-tests/test.xml input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:334"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:334: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:334"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:334"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:334: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:334"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:334"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:334: bison input.y"
at_fn_check_prepare_trace "input.at:334"
( $at_check_trace; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:6.8-22: warning: unset value: \$\$
input.y:6.8-22: warning: unused value: \$2
input.y:7.6-8: warning: unset value: \$\$
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:334"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_8
#AT_START_9
at_fn_group_banner 9 'input.at:347' \
  "Incompatible Aliases" "                           " 1
at_xfail=no
(
  $as_echo "9. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token foo "foo"

%type <bar>       foo
%printer {bar}    foo
%destructor {bar} foo
%left             foo

%type <baz>       "foo"
%printer {baz}    "foo"
%destructor {baz} "foo"
%left             "foo"

%%
exp: foo;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:366: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:366"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:8.7-11: %type redeclaration for foo
input.y:3.7-11: previous declaration
input.y:10.13-17: %destructor redeclaration for foo
input.y:5.13-17: previous declaration
input.y:9.10-14: %printer redeclaration for foo
input.y:4.10-14: previous declaration
input.y:11.1-5: %left redeclaration for foo
input.y:6.1-5: previous declaration
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:366"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_9
#AT_START_10
at_fn_group_banner 10 'input.at:388' \
  "Torturing the Scanner" "                          " 1
at_xfail=no
(
  $as_echo "10. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >input.y <<'_ATEOF'
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:392: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:392"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.1: syntax error, unexpected end of file
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:392"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
{}
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:400: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:400"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.1-2: syntax error, unexpected {...}
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:400"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
/* This is seen in GCC: a %{ and %} in middle of a comment. */
const char *foo = "So %{ and %} can be here too.";

#if 0
/* These examples test Bison while not stressing C compilers too much.
   Many C compilers mishandle backslash-newlines, so this part of the
   test is inside "#if 0".  The comment and string are written so that
   the "#endif" will be seen regardless of the C compiler bugs that we
   know about, namely:

     HP C (as of late 2002) mishandles *\[newline]\[newline]/ within a
     comment.

     The Apple Darwin compiler (as of late 2002) mishandles
     \\[newline]' within a character constant.

   */

/\
* A comment with backslash-newlines in it. %} *\
\
/
/* { Close the above comment, if the C compiler mishandled it.  */

char str[] = "\\
" A string with backslash-newlines in it %{ %} \\
\
"";

char apostrophe = '\'';
#endif

#include <stdio.h>
#include <stdlib.h>
%}
/* %{ and %} can be here too. */

%{
/* Exercise pre-prologue dependency to %union.  */
typedef int value;
%}

/* Exercise M4 quoting: ']]', 0.  */

/* Also exercise %union. */
%union
{
  value ival; /* A comment to exercise an old bug. */
};


/* Exercise post-prologue dependency to %union.  */
%{
static YYSTYPE value_as_yystype (value val);

/* Exercise quotes in declarations.  */
char quote[] = "]],";
%}

%{
static void yyerror (const char *s);
static int yylex (void);
%}

%type <ival> '['

/* Exercise quotes in strings.  */
%token FAKE "fake [] \a\b\f\n\r\t\v\"\'\?\\\u005B\U0000005c ??!??'??(??)??-??/??<??=??> \x1\1"

%%
/* Exercise M4 quoting: ']]', [, 1.  */
exp: '[' '\1' two '$' '@' '{' oline output.or.oline.opt
  {
    /* Exercise quotes in braces.  */
    char tmp[] = "[%c],\n";
    printf (tmp, $1);
  }
;

two: '\x000000000000000000000000000000000000000000000000000000000000000000002';
oline: '@' 'o' 'l' 'i' 'n' 'e' '@' '_' '_' 'o' 'l' 'i' 'n' 'e' '_' '_';
output.or.oline.opt: ;|oline;;|output;;;
output: '#' 'o' 'u' 't' 'p' 'u' 't' ' ';
%%
/* Exercise M4 quoting: ']]', [, 2.  */

static YYSTYPE
value_as_yystype (value val)
{
  YYSTYPE res;
  res.ival = val;
  return res;
}

static int
yylex (void)
{
  static char const input[] = "[\1\2$@{@oline@__oline__\
#output "; /* "
  */
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylval = value_as_yystype (input[toknum]);
  return input[toknum++];
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}
_ATEOF



# Pacify Emacs'font-lock-mode: "

cat >main.c <<'_ATEOF'
typedef int value;
#include "input.h"

int yyparse (void);

int
main (void)
{
  return yyparse ();
}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:536: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -d -v -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:536"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -d -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:536"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:536: bison --xml=xml-tests/test.xml -d -v -o input.c input.y"
at_fn_check_prepare_trace "input.at:536"
( $at_check_trace; bison --xml=xml-tests/test.xml -d -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:536"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:536: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:536"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:536"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:536: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:536"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:536"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:536: bison -d -v -o input.c input.y"
at_fn_check_prepare_trace "input.at:536"
( $at_check_trace; bison -d -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:536"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/input.at:537: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c" "input.at:537"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:537"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/input.at:538: \$CC \$CFLAGS \$CPPFLAGS -o main.o -c main.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o main.o -c main.c" "input.at:538"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o main.o -c main.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:538"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/input.at:539: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.o main.o \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.o main.o $LIBS" "input.at:539"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.o main.o $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:539"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/input.at:540:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "input.at:540"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "[[],
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_10
#AT_START_11
at_fn_group_banner 11 'input.at:551' \
  "Typed symbol aliases" "                           " 1
at_xfail=no
(
  $as_echo "11. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison 2.0 broke typed symbol aliases - ensure they work.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%union
{
  int val;
};
%token <val> MY_TOKEN "MY TOKEN"
%type <val> exp
%%
exp: "MY TOKEN";
%%
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:567: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:567"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:567"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:567: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "input.at:567"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:567"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:567: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:567"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:567"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:567: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:567"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:567"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:567: bison -o input.c input.y"
at_fn_check_prepare_trace "input.at:567"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:567"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_11
#AT_START_12
at_fn_group_banner 12 'input.at:587' \
  "Require 1.0" "                                    " 1
at_xfail=no
(
  $as_echo "12. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%require "1.0";
%%
empty_file:;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:587: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:587"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:587"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:587: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "input.at:587"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:587"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:587: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:587"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:587"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:587: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:587"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:587"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:587: bison -o input.c input.y"
at_fn_check_prepare_trace "input.at:587"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:587"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_12
#AT_START_13
at_fn_group_banner 13 'input.at:588' \
  "Require 2.3b.564-5697" "                          " 1
at_xfail=no
(
  $as_echo "13. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%require "2.3b.564-5697";
%%
empty_file:;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:588: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:588"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:588"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:588: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "input.at:588"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:588"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:588: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:588"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:588"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:588: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:588"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:588"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:588: bison -o input.c input.y"
at_fn_check_prepare_trace "input.at:588"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:588"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_13
#AT_START_14
at_fn_group_banner 14 'input.at:590' \
  "Require 100.0" "                                  " 1
at_xfail=no
(
  $as_echo "14. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%require "100.0";
%%
empty_file:;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:590: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y" "input.at:590"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 63 $at_status "$at_srcdir/input.at:590"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_14
#AT_START_15
at_fn_group_banner 15 'input.at:597' \
  "String aliases for character tokens" "            " 1
at_xfail=no
(
  $as_echo "15. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison once thought a character token and its alias were different
# symbols with the same user token number.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%token 'a' "a"
%%
start: 'a';
%%
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:609: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:609"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:609: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "input.at:609"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:609: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:609"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:609: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:609"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:609: bison -o input.c input.y"
at_fn_check_prepare_trace "input.at:609"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_15
#AT_START_16
at_fn_group_banner 16 'input.at:618' \
  "Symbols" "                                        " 1
at_xfail=no
(
  $as_echo "16. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%token WITH-DASH
%token WITHOUT_DASH "WITHOUT-DASH"
%token WITH.PERIOD
%token WITHOUT_PERIOD "WITHOUT.PERIOD"
%code {
  void yyerror (char const *);
  int yylex (void);
}
%%
start: with-dash without_dash with.period without_period;
with-dash: WITH-DASH;
without_dash: "WITHOUT-DASH";
with.period: WITH.PERIOD;
without_period: "WITHOUT.PERIOD";
%%
_ATEOF



# POSIX Yacc accept periods, but not dashes.

{ set +x
$as_echo "$at_srcdir/input.at:639: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --yacc input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --yacc input.y" "input.at:639"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --yacc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:9.8-16: POSIX Yacc forbids dashes in symbol names: WITH-DASH
input.y:18.8-16: POSIX Yacc forbids dashes in symbol names: with-dash
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:639"
$at_failed && at_fn_log_failure
$at_traceon; }


# So warn about them.
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:645: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -Wyacc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:645"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -Wyacc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:645"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:645: bison --xml=xml-tests/test.xml -Wyacc input.y"
at_fn_check_prepare_trace "input.at:645"
( $at_check_trace; bison --xml=xml-tests/test.xml -Wyacc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:645"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:645: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:645"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:645"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:645: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:645"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:645"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:645: bison -Wyacc input.y"
at_fn_check_prepare_trace "input.at:645"
( $at_check_trace; bison -Wyacc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:9.8-16: warning: POSIX Yacc forbids dashes in symbol names: WITH-DASH
input.y:18.8-16: warning: POSIX Yacc forbids dashes in symbol names: with-dash
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:645"
$at_failed && at_fn_log_failure
$at_traceon; }


# Dashes are fine for GNU Bison.
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:651: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:651"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:651"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:651: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "input.at:651"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:651"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:651: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:651"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:651"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:651: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:651"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:651"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:651: bison -o input.c input.y"
at_fn_check_prepare_trace "input.at:651"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:651"
$at_failed && at_fn_log_failure
$at_traceon; }


# Make sure we don't export silly token identifiers with periods or dashes.
{ set +x
$as_echo "$at_srcdir/input.at:654: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c" "input.at:654"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }



# Periods and dashes are genuine letters, they can start identifiers.
# Digits cannot.
cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%token .GOOD
         -GOOD
         1NV4L1D
%%
start: .GOOD -GOOD
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:666: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y" "input.at:666"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:11.10-16: invalid identifier: \`1NV4L1D'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_16
#AT_START_17
at_fn_group_banner 17 'input.at:677' \
  "Numbered tokens" "                                " 1
at_xfail=no
(
  $as_echo "17. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >redecl.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%token DECIMAL_1     11259375
         HEXADECIMAL_1 0xabcdef
         HEXADECIMAL_2 0xFEDCBA
         DECIMAL_2     16702650
%%
start: DECIMAL_1 HEXADECIMAL_2;
_ATEOF




{ set +x
$as_echo "$at_srcdir/input.at:688: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison redecl.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison redecl.y" "input.at:688"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison redecl.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "redecl.y:10.10-22: user token number 11259375 redeclaration for HEXADECIMAL_1
redecl.y:9.8-16: previous declaration for DECIMAL_1
redecl.y:12.10-18: user token number 16702650 redeclaration for DECIMAL_2
redecl.y:11.10-22: previous declaration for HEXADECIMAL_2
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:688"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >too-large.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%token TOO_LARGE_DEC 999999999999999999999
         TOO_LARGE_HEX 0xFFFFFFFFFFFFFFFFFFF
%%
start: TOO_LARGE_DEC TOO_LARGE_HEX
%%
_ATEOF




{ set +x
$as_echo "$at_srcdir/input.at:703: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison too-large.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison too-large.y" "input.at:703"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison too-large.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "too-large.y:9.22-42: integer out of range: \`999999999999999999999'
too-large.y:10.24-44: integer out of range: \`0xFFFFFFFFFFFFFFFFFFF'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:703"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_17
#AT_START_18
at_fn_group_banner 18 'input.at:715' \
  "Unclosed constructs" "                            " 1
at_xfail=no
(
  $as_echo "18. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison's scan-gram.l once forgot to STRING_FINISH some unclosed
# constructs, so they were prepended to whatever it STRING_GROW'ed
# next.  It also threw them away rather than returning them to the
# parser.  The effect was confusing subsequent error messages.

cat >input.y <<'_ATEOF'
%token A "a
%token B "b"
%token AB "ab" // Used to complain that "ab" was already used.
%token C '1
%token TWO "2"
%token TICK_TWELVE "'12" // Used to complain that "'12" was already used.

%%

start: ;

// Used to report a syntax error because it didn't see any kind of symbol
// identifier.
%type <f> 'a
;
%type <f> "a
;
// Used to report a syntax error because it didn't see braced code.
%destructor { free ($$)
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:744: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y" "input.at:744"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.10-2.0: missing \`\"' at end of line
input.y:4.10-5.0: missing \`'' at end of line
input.y:14.11-15.0: missing \`'' at end of line
input.y:16.11-17.0: missing \`\"' at end of line
input.y:19.13-20.0: missing \`}' at end of file
input.y:20.1: syntax error, unexpected end of file
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:744"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_18
#AT_START_19
at_fn_group_banner 19 'input.at:760' \
  "%start after first rule" "                        " 1
at_xfail=no
(
  $as_echo "19. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison once complained that a %start after the first rule was a
# redeclaration of the start symbol.

cat >input.y <<'_ATEOF'
%%
false_start: ;
start: false_start ;
%start start;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:772: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:772"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:772"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:772: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "input.at:772"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:772"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:772: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:772"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:772"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:772: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:772"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:772"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:772: bison -o input.c input.y"
at_fn_check_prepare_trace "input.at:772"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:772"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_19
#AT_START_20
at_fn_group_banner 20 'input.at:781' \
  "%prec takes a token" "                            " 1
at_xfail=no
(
  $as_echo "20. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison once allowed %prec sym where sym was a nonterminal.

cat >input.y <<'_ATEOF'
%%
start: PREC %prec PREC ;
PREC: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:791: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:791"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.1-4: rule given for PREC, which is a token
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:791"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_20
#AT_START_21
at_fn_group_banner 21 'input.at:802' \
  "%prec's token must be defined" "                  " 1
at_xfail=no
(
  $as_echo "21. $at_setup_line: testing $at_desc ..."
  $at_traceon


# According to POSIX, a %prec token must be defined separately.

cat >input.y <<'_ATEOF'
%%
start: %prec PREC ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:811: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:811"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:811"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:811: bison --xml=xml-tests/test.xml input.y"
at_fn_check_prepare_trace "input.at:811"
( $at_check_trace; bison --xml=xml-tests/test.xml input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:811"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:811: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:811"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:811"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:811: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:811"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:811"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:811: bison input.y"
at_fn_check_prepare_trace "input.at:811"
( $at_check_trace; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:2.8-17: warning: token for %prec is not defined: PREC
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:811"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_21
#AT_START_22
at_fn_group_banner 22 'input.at:822' \
  "Reject unused %code qualifiers" "                 " 1
at_xfail=no
(
  $as_echo "22. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input-c.y <<'_ATEOF'
%code q {}
%code bad {}
%code bad {}
%code format {}
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:832: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-c.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-c.y" "input.at:832"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input-c.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input-c.y:1.7: %code qualifier \`q' is not used
input-c.y:2.7-9: %code qualifier \`bad' is not used
input-c.y:3.7-9: %code qualifier \`bad' is not used
input-c.y:4.7-12: %code qualifier \`format' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:832"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input-c-glr.y <<'_ATEOF'
%code q {}
%code bad {}
 %code bad {}
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:846: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-c-glr.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-c-glr.y" "input.at:846"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input-c-glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input-c-glr.y:1.7: %code qualifier \`q' is not used
input-c-glr.y:2.7-9: %code qualifier \`bad' is not used
input-c-glr.y:3.8-10: %code qualifier \`bad' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:846"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input-c++.y <<'_ATEOF'
%code q {}
%code bad {}
 %code q {}
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:859: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-c++.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-c++.y" "input.at:859"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input-c++.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input-c++.y:1.7: %code qualifier \`q' is not used
input-c++.y:2.7-9: %code qualifier \`bad' is not used
input-c++.y:3.8: %code qualifier \`q' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:859"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input-c++-glr.y <<'_ATEOF'
%code bad {}
%code q {}
%code q {}
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:872: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-c++-glr.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-c++-glr.y" "input.at:872"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input-c++-glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input-c++-glr.y:1.7-9: %code qualifier \`bad' is not used
input-c++-glr.y:2.7: %code qualifier \`q' is not used
input-c++-glr.y:3.7: %code qualifier \`q' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:872"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >special-char-@@.y <<'_ATEOF'
%code bad {}
%code q {}
%code q {}
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:885: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison special-char-@@.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison special-char-@@.y" "input.at:885"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison special-char-@@.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "special-char-@@.y:1.7-9: %code qualifier \`bad' is not used
special-char-@@.y:2.7: %code qualifier \`q' is not used
special-char-@@.y:3.7: %code qualifier \`q' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:885"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >special-char-].y <<'_ATEOF'
%code bad {}
%code q {}
%code q {}
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:898: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison special-char-].y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison special-char-].y" "input.at:898"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison special-char-].y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "special-char-].y:1.7-9: %code qualifier \`bad' is not used
special-char-].y:2.7: %code qualifier \`q' is not used
special-char-].y:3.7: %code qualifier \`q' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:898"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_22
#AT_START_23
at_fn_group_banner 23 'input.at:911' \
  "%define errors" "                                 " 1
at_xfail=no
(
  $as_echo "23. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input-redefined.y <<'_ATEOF'
%define var "value1"
%define var "value1"
 %define var "value2"
%define special1 "]"
%define special2 "["
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:923: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-redefined.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-redefined.y" "input.at:923"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input-redefined.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input-redefined.y:2.9-11: %define variable \`var' redefined
input-redefined.y:1.9-11: previous definition
input-redefined.y:3.10-12: %define variable \`var' redefined
input-redefined.y:2.9-11: previous definition
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:923"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input-unused.y <<'_ATEOF'
%define var "value"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:936: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-unused.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input-unused.y" "input.at:936"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input-unused.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input-unused.y:1.9-11: %define variable \`var' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:936"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_23
#AT_START_24
at_fn_group_banner 24 'input.at:947' \
  "%define, --define, --force-define" "              " 1
at_xfail=no
(
  $as_echo "24. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >skel.c <<'_ATEOF'
m4_divert_push(0)@
@output(b4_parser_file_name@)@
[var-dd: ]b4_percent_define_get([[var-dd]])[
var-ff: ]b4_percent_define_get([[var-ff]])[
var-dfg: ]b4_percent_define_get([[var-dfg]])[
var-fd: ]b4_percent_define_get([[var-fd]])
m4_divert_pop(0)
_ATEOF

cat >input.y <<'_ATEOF'
%define var-dfg "gram"
%%
start: ;
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/input.at:963: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -Dvar-dd=cmd-d1 -Dvar-dd=cmd-d2 \\
                 -Fvar-ff=cmd-f1 -Fvar-ff=cmd-f2 \\
                 -Dvar-dfg=cmd-d -Fvar-dfg=cmd-f \\
                 -Fvar-fd=cmd-f -Dvar-fd=cmd-d   \\
                 --skeleton ./skel.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:963"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -Dvar-dd=cmd-d1 -Dvar-dd=cmd-d2 \
                 -Fvar-ff=cmd-f1 -Fvar-ff=cmd-f2 \
                 -Dvar-dfg=cmd-d -Fvar-dfg=cmd-f \
                 -Fvar-fd=cmd-f -Dvar-fd=cmd-d   \
                 --skeleton ./skel.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:963"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/input.at:963: bison --xml=xml-tests/test.xml -Dvar-dd=cmd-d1 -Dvar-dd=cmd-d2 \\
                 -Fvar-ff=cmd-f1 -Fvar-ff=cmd-f2 \\
                 -Dvar-dfg=cmd-d -Fvar-dfg=cmd-f \\
                 -Fvar-fd=cmd-f -Dvar-fd=cmd-d   \\
                 --skeleton ./skel.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:963"
( $at_check_trace; bison --xml=xml-tests/test.xml -Dvar-dd=cmd-d1 -Dvar-dd=cmd-d2 \
                 -Fvar-ff=cmd-f1 -Fvar-ff=cmd-f2 \
                 -Dvar-dfg=cmd-d -Fvar-dfg=cmd-f \
                 -Fvar-fd=cmd-f -Dvar-fd=cmd-d   \
                 --skeleton ./skel.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/input.at:963"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/input.at:963: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:963"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:963"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/input.at:963: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "input.at:963"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:963"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/input.at:963: bison -Dvar-dd=cmd-d1 -Dvar-dd=cmd-d2 \\
                 -Fvar-ff=cmd-f1 -Fvar-ff=cmd-f2 \\
                 -Dvar-dfg=cmd-d -Fvar-dfg=cmd-f \\
                 -Fvar-fd=cmd-f -Dvar-fd=cmd-d   \\
                 --skeleton ./skel.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:963"
( $at_check_trace; bison -Dvar-dd=cmd-d1 -Dvar-dd=cmd-d2 \
                 -Fvar-ff=cmd-f1 -Fvar-ff=cmd-f2 \
                 -Dvar-dfg=cmd-d -Fvar-dfg=cmd-f \
                 -Fvar-fd=cmd-f -Dvar-fd=cmd-d   \
                 --skeleton ./skel.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:963"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/input.at:968: cat input.tab.c"
at_fn_check_prepare_trace "input.at:968"
( $at_check_trace; cat input.tab.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "var-dd: cmd-d2
var-ff: cmd-f2
var-dfg: cmd-f
var-fd: cmd-d
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:968"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input-dg.y <<'_ATEOF'
%define var "gram"
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:980: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -Dvar=cmd-d input-dg.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -Dvar=cmd-d input-dg.y" "input.at:980"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -Dvar=cmd-d input-dg.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input-dg.y:1.9-11: %define variable \`var' redefined
<command line>:2: previous definition
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:980"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input-unused.y <<'_ATEOF'
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:989: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -Dunused-d -Funused-f input-unused.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -Dunused-d -Funused-f input-unused.y" "input.at:989"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -Dunused-d -Funused-f input-unused.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "<command line>:2: %define variable \`unused-d' is not used
<command line>:3: %define variable \`unused-f' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:989"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_24
#AT_START_25
at_fn_group_banner 25 'input.at:1000' \
  "%define Boolean variables" "                      " 1
at_xfail=no
(
  $as_echo "25. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >Input.y <<'_ATEOF'
%language "Java"
%define public "maybe"
%define parser_class_name "Input"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1010: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison Input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison Input.y" "input.at:1010"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison Input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "Input.y:2.9-14: invalid value for %define Boolean variable \`public'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1010"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_25
#AT_START_26
at_fn_group_banner 26 'input.at:1020' \
  "%define enum variables" "                         " 1
at_xfail=no
(
  $as_echo "26. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Front-end.
cat >input.y <<'_ATEOF'
%define lr.default-reductions bogus
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:1028: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1028"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-29: invalid value for %define variable \`lr.default-reductions': \`bogus'
input.y:1.9-29: accepted value: \`all'
input.y:1.9-29: accepted value: \`consistent'
input.y:1.9-29: accepted value: \`accepting'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1028"
$at_failed && at_fn_log_failure
$at_traceon; }


# Back-end.
cat >input.y <<'_ATEOF'
%define api.push-pull neither
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:1041: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1041"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-21: invalid value for %define variable \`api.push-pull': \`neither'
input.y:1.9-21: accepted value: \`pull'
input.y:1.9-21: accepted value: \`push'
input.y:1.9-21: accepted value: \`both'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1041"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_26
#AT_START_27
at_fn_group_banner 27 'input.at:1054' \
  "%define backward compatibility" "                 " 1
at_xfail=no
(
  $as_echo "27. $at_setup_line: testing $at_desc ..."
  $at_traceon


# The error messages tell us whether underscores in these variables are
# being converted to dashes.

cat >input.y <<'_ATEOF'
%define api.push_pull "neither"
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:1064: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1064"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-21: invalid value for %define variable \`api.push-pull': \`neither'
input.y:1.9-21: accepted value: \`pull'
input.y:1.9-21: accepted value: \`push'
input.y:1.9-21: accepted value: \`both'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1064"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%define lr.keep_unreachable_states maybe
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:1076: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1076"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-34: invalid value for %define Boolean variable \`lr.keep-unreachable-states'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1076"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%define namespace "foo"
%define api.namespace "foo"
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:1086: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1086"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:2.9-21: %define variable \`api.namespace' redefined
input.y:1.9-17: previous definition
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1086"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%define foo_bar "baz"
%%
start: ;
_ATEOF


{ set +x
$as_echo "$at_srcdir/input.at:1096: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1096"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-15: %define variable \`foo_bar' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1096"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_27
#AT_START_28
at_fn_group_banner 28 'input.at:1106' \
  "Unused %define api.pure" "                        " 1
at_xfail=no
(
  $as_echo "28. $at_setup_line: testing $at_desc ..."
  $at_traceon


# AT_CHECK_API_PURE(DECLS, VALUE)
# -------------------------------
# Make sure Bison reports that `%define api.pure VALUE' is unused when DECLS
# are specified.



cat >input.y <<'_ATEOF'
%define api.pure
%language "c++" %defines
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1126: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1126"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1126"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure false
%language "c++" %defines
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1127: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1127"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1127"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure ""
%language "c++" %defines %glr-parser
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1128: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1128"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1128"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure false
%language "c++" %defines %glr-parser
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1129: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1129"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1129"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure true
%language "java"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1130: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1130"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1130"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure false
%language "java"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1131: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1131"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1131"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_28
#AT_START_29
at_fn_group_banner 29 'input.at:1139' \
  "C++ namespace reference errors" "                 " 1
at_xfail=no
(
  $as_echo "29. $at_setup_line: testing $at_desc ..."
  $at_traceon


# AT_CHECK_NAMESPACE_ERROR(NAMESPACE-DECL, ERROR, [ERROR], ...)
# -------------------------------------------------------------
# Make sure Bison reports all ERROR's for %define namespace "NAMESPACE-DECL".



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace ""
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1160: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1160"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference is empty
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1160"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace " 		  	 	"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1162: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1162"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference is empty
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1162"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace "foo::::bar"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1164: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1164"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference has consecutive \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1164"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace "foo:: 	::bar"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1166: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1166"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference has consecutive \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1166"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace "::::bar"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1168: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1168"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference has consecutive \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1168"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace ":: ::bar"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1170: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1170"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference has consecutive \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1170"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace "foo::bar::	::"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1172: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1172"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference has consecutive \"::\"
input.y:3.9-21: namespace reference has a trailing \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1172"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace "foo::bar::"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1175: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1175"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference has a trailing \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1175"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace "foo::bar:: 	"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1177: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1177"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference has a trailing \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1177"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define api.namespace "::"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/input.at:1179: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1179"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.9-21: namespace reference has a trailing \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1179"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_29
#AT_START_30
at_fn_group_banner 30 'input.at:1195' \
  "Bad character literals" "                         " 1
at_xfail=no
(
  $as_echo "30. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >empty.y <<'_ATEOF'
%%
start: '';
start: '
_ATEOF

{ set +x
$as_echo "$at_srcdir/input.at:1202: perl -e \"print 'start: \\'';\" >> empty.y || exit 77"
at_fn_check_prepare_trace "input.at:1202"
( $at_check_trace; perl -e "print 'start: \'';" >> empty.y || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:1202"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/input.at:1204: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison empty.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison empty.y" "input.at:1204"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison empty.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "empty.y:2.8-9: warning: empty character literal
empty.y:3.8-4.0: warning: empty character literal
empty.y:3.8-4.0: missing \`'' at end of line
empty.y:4.8: warning: empty character literal
empty.y:4.8: missing \`'' at end of file
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1204"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >two.y <<'_ATEOF'
%%
start: 'ab';
start: 'ab
_ATEOF

{ set +x
$as_echo "$at_srcdir/input.at:1217: perl -e \"print 'start: \\'ab';\" >> two.y || exit 77"
at_fn_check_prepare_trace "input.at:1217"
( $at_check_trace; perl -e "print 'start: \'ab';" >> two.y || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:1217"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/input.at:1219: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison two.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison two.y" "input.at:1219"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison two.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "two.y:2.8-11: warning: extra characters in character literal
two.y:3.8-4.0: warning: extra characters in character literal
two.y:3.8-4.0: missing \`'' at end of line
two.y:4.8-10: warning: extra characters in character literal
two.y:4.8-10: missing \`'' at end of file
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1219"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >three.y <<'_ATEOF'
%%
start: 'abc';
start: 'abc
_ATEOF

{ set +x
$as_echo "$at_srcdir/input.at:1232: perl -e \"print 'start: \\'abc';\" >> three.y || exit 77"
at_fn_check_prepare_trace "input.at:1232"
( $at_check_trace; perl -e "print 'start: \'abc';" >> three.y || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:1232"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/input.at:1234: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison three.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison three.y" "input.at:1234"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison three.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "three.y:2.8-12: warning: extra characters in character literal
three.y:3.8-4.0: warning: extra characters in character literal
three.y:3.8-4.0: missing \`'' at end of line
three.y:4.8-11: warning: extra characters in character literal
three.y:4.8-11: missing \`'' at end of file
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1234"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_30
#AT_START_31
at_fn_group_banner 31 'input.at:1248' \
  "Bad escapes in literals" "                        " 1
at_xfail=no
(
  $as_echo "31. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%%
start: '\777' '\0' '\xfff' '\x0'
       '\uffff' '\u0000' '\Uffffffff' '\U00000000'
       '\ ' '\A';
_ATEOF


# It is not easy to create special characters, we cannot even trust tr.
# Beside we cannot even expect "echo '\0'" to output two characters
# (well three with \n): at least Bash 3.2 converts the two-character
# sequence "\0" into a single NUL character.
{ set +x
$as_echo "$at_srcdir/input.at:1261: perl -e 'print \"start: \\\"\\\\\\t\\\\\\f\\\\\\0\\\\\\1\\\" ;\";' >> input.y \\
           || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "input.at:1261"
( $at_check_trace; perl -e 'print "start: \"\\\t\\\f\\\0\\\1\" ;";' >> input.y \
           || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/input.at:1261"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/input.at:1264: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "input.at:1264"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:2.9-12: invalid number after \\-escape: 777
input.y:2.8-13: warning: empty character literal
input.y:2.16-17: invalid number after \\-escape: 0
input.y:2.15-18: warning: empty character literal
input.y:2.21-25: invalid number after \\-escape: xfff
input.y:2.20-26: warning: empty character literal
input.y:2.29-31: invalid number after \\-escape: x0
input.y:2.28-32: warning: empty character literal
input.y:3.9-14: invalid number after \\-escape: uffff
input.y:3.8-15: warning: empty character literal
input.y:3.18-23: invalid number after \\-escape: u0000
input.y:3.17-24: warning: empty character literal
input.y:3.27-36: invalid number after \\-escape: Uffffffff
input.y:3.26-37: warning: empty character literal
input.y:3.40-49: invalid number after \\-escape: U00000000
input.y:3.39-50: warning: empty character literal
input.y:4.9-10: invalid character after \\-escape: \` '
input.y:4.8-11: warning: empty character literal
input.y:4.14-15: invalid character after \\-escape: A
input.y:4.13-16: warning: empty character literal
input.y:5.9-16: invalid character after \\-escape: \\t
input.y:5.17: invalid character after \\-escape: \\f
input.y:5.18: invalid character after \\-escape: \\0
input.y:5.19: invalid character after \\-escape: \\001
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/input.at:1264"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_31
#AT_START_32
at_fn_group_banner 32 'named-refs.at:20' \
  "Tutorial calculator" "                            " 2
at_xfail=no
(
  $as_echo "32. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
typedef int semantic_value;
FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
static void yyerror (const char *s);
int yylex (void);
%}

%union
{
  semantic_value ival;
};

%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $NUM; }
| exp[l] '=' exp[r]
  {
    if ($l != $r)
      fprintf (stderr, "calc: error: %d != %d\n", $l, $r);
   $$ = $l;
  }
| exp[x] '+' { $<ival>$ = $x; } [l] exp[r]  { $$ = $<ival>l + $r;    }
| exp[l] '-' exp[r]        { $$ = $l - $r;        }
| exp[l] '*' exp[r]        { $$ = $l * $r;        }
| exp[l] '/' exp[r]  { $$ = $l / $r;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp[l] '^' exp[r]        { $$ = power ($l, $r); }
| '(' exp[e] ')'        { $$ = $e;           }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int get_char (void)
{
  int res = getc (input);
  return res;
}

static void unget_char (int c)
{
  ungetc (c, input);
}

static int read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }
  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }
  unget_char ( c);
  return sign * n;
}

int yylex (void)
{
  int c;
  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t') {}

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;
  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;
  if (!input)
    {
      perror (argv[1]);
      return 3;
    }
  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF



cat >input.txt <<'_ATEOF'

1 + 2 * 3 = 7
1 + 2 * -3 = -5
-1^2 = -1
(-1)^2 = 1
---1 = -1
1 - 2 - 3 = -4
1 - (2 - 3) = 2
2^2^3 = 256
(2^2)^3 = 64
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/named-refs.at:189: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o test.c test.y"
at_fn_check_prepare_notrace 'an embedded newline' "named-refs.at:189"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:189"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/named-refs.at:189: bison --xml=xml-tests/test.xml -o test.c test.y"
at_fn_check_prepare_trace "named-refs.at:189"
( $at_check_trace; bison --xml=xml-tests/test.xml -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:189"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/named-refs.at:189: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "named-refs.at:189"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:189"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/named-refs.at:189: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "named-refs.at:189"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:189"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/named-refs.at:189: bison -o test.c test.y"
at_fn_check_prepare_trace "named-refs.at:189"
( $at_check_trace; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:189"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/named-refs.at:190: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o test test.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o test test.c $LIBS" "named-refs.at:190"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o test test.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:190"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/named-refs.at:191:  \$PREPARSER ./test input.txt"
at_fn_check_prepare_dynamic " $PREPARSER ./test input.txt" "named-refs.at:191"
( $at_check_trace;  $PREPARSER ./test input.txt
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:191"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_32
#AT_START_33
at_fn_group_banner 33 'named-refs.at:199' \
  "Undefined and ambiguous references" "             " 2
at_xfail=no
(
  $as_echo "33. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
static int power (int base, int exponent);
static void yyerror (const char *s);
int yylex (void);
%}

%union
{
  int ival;
};

%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM { $$ = $NUM; }
| exp[l] '=' exp[r]
  {
    if ($l != $r)
      fprintf (stderr, "calc: error: %d != %d\n", $l, $r);
   $$ = $l;
  }
| exp[x] '+' { $<ival>$ = $x; } [l] exp[r] { $$ = $<ival>lo9 + $r; }
| exp[x] '-' { $<ival>$ = $x; } [l] exp[r] { $$ = $<ival>exp - $r; }
| exp[x] '*' { $<ival>$ = $x; } [l] exp[r] { $$ = $l * $r; }
| exp[l] '/' exp[r]  { $$ = $l / $r;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp[l] '^' exp[r]        { $$ = power ($l, $r12); }
| '(' exp ')'        { $$ = $expo;           }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%
_ATEOF




{ set +x
$as_echo "$at_srcdir/named-refs.at:257: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y" "named-refs.at:257"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "test.y:50.51-60: invalid reference: \`\$<ival>lo9'
test.y:50.3-68:      symbol not found in production: lo9
test.y:51.51-60: warning: misleading reference: \`\$<ival>exp'
test.y:42.1-3:       warning: refers to: \$exp at \$\$
test.y:51.7:         warning: possibly meant: \$x, hiding \$exp at \$1
test.y:51.41:        warning: possibly meant: \$r, hiding \$exp at \$4
test.y:52.51-52: \$l of \`exp' has no declared type
test.y:55.46-49: invalid reference: \`\$r12'
test.y:55.3-53:      symbol not found in production: r12
test.y:56.29-33: invalid reference: \`\$expo'
test.y:56.3-46:      symbol not found in production: expo
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/named-refs.at:257"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_33
#AT_START_34
at_fn_group_banner 34 'named-refs.at:274' \
  "Misleading references" "                          " 2
at_xfail=no
(
  $as_echo "34. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%%
start: foo foo.bar { $foo.bar; }
foo: '1'
foo.bar: '2'
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/named-refs.at:282: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o test.c test.y"
at_fn_check_prepare_notrace 'an embedded newline' "named-refs.at:282"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:282"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/named-refs.at:282: bison --xml=xml-tests/test.xml -o test.c test.y"
at_fn_check_prepare_trace "named-refs.at:282"
( $at_check_trace; bison --xml=xml-tests/test.xml -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:282"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/named-refs.at:282: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "named-refs.at:282"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:282"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/named-refs.at:282: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "named-refs.at:282"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:282"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/named-refs.at:282: bison -o test.c test.y"
at_fn_check_prepare_trace "named-refs.at:282"
( $at_check_trace; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "test.y:11.22-29: warning: misleading reference: \`\$foo.bar'
test.y:11.8-10:      warning: refers to: \$foo at \$1
test.y:11.12-18:     warning: possibly meant: \$[foo.bar] at \$2
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/named-refs.at:282"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_34
#AT_START_35
at_fn_group_banner 35 'named-refs.at:291' \
  "Many kinds of errors" "                           " 2
at_xfail=no
(
  $as_echo "35. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%token IDENT
%token NUMBER
%token ASSIGNOP
%token IF
%token IF1
%token THEN
%token ELSE
%token FI
%token WHILE
%token DO
%token OD
%start program
%%
if_stmt1: IF expr[cond] THEN stmt[then] ELSE stmt.list[else] FI
          { $if_stmt1 = new IfStmt($cond1, $then.f1, $else); };
if_stmt2: IF expr[cond] THEN stmt[then] FI
          { $if_stmt2 = new IfStmt($cond, $stmt.field, 0); };
if_stmt3: IF expr[cond] THEN stmt.list FI
          { $if_stmt3 = new IfStmt($cond, $stmt.list, 0); };
if_stmt4: IF expr[cond] THEN stmt[xyz] ELSE stmt[xyz] FI
          { $if_stmt4 = new IfStmt($cond, $xyz, $cond); };
if_stmt5: IF expr[cond] THEN stmt.list[then] ELSE stmt.list[else] FI
          { $if_stmt5 = new IfStmt($cond, $stmt.list, $else); };
if_stmt6: IF expr[cond] THEN stmt.list[then] ELSE stmt.list[else] FI
          { $if_stmt6 = new IfStmt($cond, $stmt.list.field, $else); };
if_stmt7: IF expr[cond] THEN stmt.list[then] ELSE stmt.list[else] FI
          { $if_stmt7 = new IfStmt($cond, $[stmt.list].field, $else); };
if_stmt8: IF expr[cond] THEN stmt.list[then.1] ELSE stmt.list[else] FI
          { $if_stmt8 = new IfStmt($cond, $then.1, $else); };
if_stmt9: IF expr[cond] THEN stmt.list[then.1] ELSE stmt.list[else] FI
          { $if_stmt9 = new IfStmt($cond, $then.1.field, $else); };
if_stmt10: IF expr[cond] THEN stmt[stmt.x] FI
          { $if_stmt10 = new IfStmt($cond, $stmt.x, 0); };
if-stmt-a: IF expr[cond] THEN stmt.list[then] ELSE stmt.list[else] FI
          { $if-stmt-a = new IfStmt($cond, $then, $else); };
if-stmt-b: IF expr[cond] THEN if-stmt-a[then-a] ELSE stmt.list[else] FI
          { $[if-stmt-b] = new IfStmt($cond, $then-a.f, $else); };
program: stmt.list;
stmt.list:  stmt ';' stmt.list { $3->insert($stmt); $$ = $3; }
        |   stmt ';' { SL = new StmtList();  SL->insert($1); $$ = SL; }
        ;
stmt:  assign_stmt { $$ = $1; }
    |  if_stmt { $$ = $1; }
    |  if_stmt1 { $$ = $1; }
    |  while_stmt { $$ = $1; }
    ;
assign_stmt: IDENT ASSIGNOP expr
       { $$ = new AssignStmt(string($1),$3); };
if_stmt: IF expr[cond] THEN stmt.list FI
       { $if_stmt = new IfStmt($cond, $[stmt.list], 0); };
while_stmt[res]: WHILE expr DO stmt.list OD
       { $res = new WhileStmt($[expr], $[stmt.list]); };
expr: expr '+' term   { $$ = new Plus($1,$3); }
    | expr '-' term   { $$ = new Minus($1,$3); }
    | term            { $$ = $1; }
    ;
term: term '*' factor   { $$ = new Times($1,$3); }
    | factor            { $$ = $1; }
    ;
factor:     '(' expr ')'  { $$ = $2; }
    |       NUMBER { $$ = new Number($1); }
    |       IDENT { $$ = new Ident(string($1)); }
    ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/named-refs.at:358: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y" "named-refs.at:358"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "test.y:24.36-41: invalid reference: \`\$cond1'
test.y:23.11-24.62:  symbol not found in production: cond1
test.y:26.43-53: invalid reference: \`\$stmt.field'
test.y:25.11-26.60:  symbol not found in production: stmt
test.y:25.35-38:     possibly meant: \$then.field, hiding \$stmt.field at \$4
test.y:28.43-52: invalid reference: \`\$stmt.list'
test.y:27.11-28.59:  symbol not found in production: stmt
test.y:27.30-38:     possibly meant: \$[stmt.list] at \$4
test.y:30.43-46: ambiguous reference: \`\$xyz'
test.y:29.35-37:     refers to: \$xyz at \$4
test.y:29.50-52:     refers to: \$xyz at \$6
test.y:32.43-52: invalid reference: \`\$stmt.list'
test.y:31.11-32.63:  symbol not found in production: stmt
test.y:31.40-43:     possibly meant: \$then, hiding \$[stmt.list] at \$4
test.y:31.61-64:     possibly meant: \$else, hiding \$[stmt.list] at \$6
test.y:34.43-58: invalid reference: \`\$stmt.list.field'
test.y:33.11-34.69:  symbol not found in production: stmt
test.y:33.40-43:     possibly meant: \$then.field, hiding \$[stmt.list].field at \$4
test.y:33.61-64:     possibly meant: \$else.field, hiding \$[stmt.list].field at \$6
test.y:36.43-54: invalid reference: \`\$[stmt.list]'
test.y:35.11-36.71:  symbol not found in production: stmt.list
test.y:35.40-43:     possibly meant: \$then, hiding \$[stmt.list] at \$4
test.y:35.61-64:     possibly meant: \$else, hiding \$[stmt.list] at \$6
test.y:38.43-49: invalid reference: \`\$then.1'
test.y:37.11-38.60:  symbol not found in production: then
test.y:37.40-45:     possibly meant: \$[then.1] at \$4
test.y:40.43-55: invalid reference: \`\$then.1.field'
test.y:39.11-40.66:  symbol not found in production: then
test.y:39.40-45:     possibly meant: \$[then.1].field at \$4
test.y:42.44-50: invalid reference: \`\$stmt.x'
test.y:41.12-42.57:  symbol not found in production: stmt
test.y:41.36-41:     possibly meant: \$[stmt.x].x, hiding \$stmt.x at \$4
test.y:41.36-41:     possibly meant: \$[stmt.x] at \$4
test.y:44.13-22: invalid reference: \`\$if-stmt-a'
test.y:43.12-44.59:  symbol not found in production: if
test.y:43.1-9:       possibly meant: \$[if-stmt-a] at \$\$
test.y:46.46-54: invalid reference: \`\$then-a.f'
test.y:45.12-46.65:  symbol not found in production: then
test.y:45.41-46:     possibly meant: \$[then-a].f at \$4
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/named-refs.at:358"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_35
#AT_START_36
at_fn_group_banner 36 'named-refs.at:403' \
  "Missing identifiers in brackets" "                " 2
at_xfail=no
(
  $as_echo "36. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%%
start: foo[] bar
  { s = $foo; }
_ATEOF



{ set +x
$as_echo "$at_srcdir/named-refs.at:410: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y" "named-refs.at:410"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "test.y:11.12: an identifier expected
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/named-refs.at:410"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_36
#AT_START_37
at_fn_group_banner 37 'named-refs.at:417' \
  "Redundant words in brackets" "                    " 2
at_xfail=no
(
  $as_echo "37. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%%
start: foo[ a d ] bar
  { s = $foo; }
_ATEOF



{ set +x
$as_echo "$at_srcdir/named-refs.at:424: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y" "named-refs.at:424"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "test.y:11.15: unexpected identifier in bracketed name: \`d'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/named-refs.at:424"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_37
#AT_START_38
at_fn_group_banner 38 'named-refs.at:431' \
  "Comments in brackets" "                           " 2
at_xfail=no
(
  $as_echo "38. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%%
start: foo[/* comment */] bar
  { s = $foo; }
_ATEOF



{ set +x
$as_echo "$at_srcdir/named-refs.at:438: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y" "named-refs.at:438"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "test.y:11.25: an identifier expected
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/named-refs.at:438"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_38
#AT_START_39
at_fn_group_banner 39 'named-refs.at:445' \
  "Stray symbols in brackets" "                      " 2
at_xfail=no
(
  $as_echo "39. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%%
start: foo[ /* aaa */ *&-+ ] bar
  { s = $foo; }
_ATEOF



{ set +x
$as_echo "$at_srcdir/named-refs.at:452: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y" "named-refs.at:452"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "test.y:11.23: invalid character in bracketed name: \`*'
test.y:11.24: invalid character in bracketed name: \`&'
test.y:11.26: invalid character in bracketed name: \`+'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/named-refs.at:452"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_39
#AT_START_40
at_fn_group_banner 40 'named-refs.at:461' \
  "Redundant words in LHS brackets" "                " 2
at_xfail=no
(
  $as_echo "40. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%%
start[a s]: foo
_ATEOF



{ set +x
$as_echo "$at_srcdir/named-refs.at:467: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y" "named-refs.at:467"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "test.y:11.9: unexpected identifier in bracketed name: \`s'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/named-refs.at:467"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_40
#AT_START_41
at_fn_group_banner 41 'named-refs.at:474' \
  "Unresolved references" "                          " 2
at_xfail=no
(
  $as_echo "41. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >test.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%%
stat:
sym_a sym_b
{ func($sym.field); }
|
sym_a sym_b
{ func($<aa>sym.field); }
|
sym_a sym_b
{ func($[sym.field]); }
|
sym_a sym_b
{ func($<aa>[sym.field]); }
|
sym_a sym_b
{ func($sym); }
|
sym_a sym_b
{ func($<aa>sym); }
|
sym_a sym_b
{ func($[sym]); }
sym_a sym_b
{ func($<aa>[sym]); }
;
stat1:
sym_a sym_b
{ func($sym-field); }
|
sym_a sym_b
{ func($<aa>sym-field); }
|
sym_a sym_b
{ func($[sym-field]); }
|
sym_a sym_b
{ func($<aa>[sym-field]); }
|
sym_a sym_b
{ func($sym); }
|
sym_a sym_b
{ func($<aa>sym); }
|
sym_a sym_b
{ func($[sym]); }
sym_a sym_b
{ func($<aa>[sym]); }
;
sym_a : 'a';
sym_b : 'b';
_ATEOF



{ set +x
$as_echo "$at_srcdir/named-refs.at:529: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o test.c test.y" "named-refs.at:529"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o test.c test.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "test.y:13.8-17: invalid reference: \`\$sym.field'
test.y:12.1-13.21:  symbol not found in production: sym
test.y:16.8-21: invalid reference: \`\$<aa>sym.field'
test.y:15.1-16.25:  symbol not found in production: sym
test.y:19.8-19: invalid reference: \`\$[sym.field]'
test.y:18.1-19.23:  symbol not found in production: sym.field
test.y:22.8-23: invalid reference: \`\$<aa>[sym.field]'
test.y:21.1-22.27:  symbol not found in production: sym.field
test.y:25.8-11: invalid reference: \`\$sym'
test.y:24.1-25.15:  symbol not found in production: sym
test.y:28.8-15: invalid reference: \`\$<aa>sym'
test.y:27.1-28.19:  symbol not found in production: sym
test.y:31.8-13: invalid reference: \`\$[sym]'
test.y:30.1-33.21:  symbol not found in production before \$3: sym
test.y:33.8-17: invalid reference: \`\$<aa>[sym]'
test.y:30.1-33.21:  symbol not found in production: sym
test.y:37.8-17: invalid reference: \`\$sym-field'
test.y:36.1-37.21:  symbol not found in production: sym
test.y:40.8-21: invalid reference: \`\$<aa>sym-field'
test.y:39.1-40.25:  symbol not found in production: sym
test.y:43.8-19: invalid reference: \`\$[sym-field]'
test.y:42.1-43.23:  symbol not found in production: sym-field
test.y:46.8-23: invalid reference: \`\$<aa>[sym-field]'
test.y:45.1-46.27:  symbol not found in production: sym-field
test.y:49.8-11: invalid reference: \`\$sym'
test.y:48.1-49.15:  symbol not found in production: sym
test.y:52.8-15: invalid reference: \`\$<aa>sym'
test.y:51.1-52.19:  symbol not found in production: sym
test.y:55.8-13: invalid reference: \`\$[sym]'
test.y:54.1-57.21:  symbol not found in production before \$3: sym
test.y:57.8-17: invalid reference: \`\$<aa>[sym]'
test.y:54.1-57.21:  symbol not found in production: sym
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/named-refs.at:529"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_41
#AT_START_42
at_fn_group_banner 42 'output.at:44' \
  "Output files:  -dv " "                            " 3
at_xfail=no
(
  $as_echo "42. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y foo.output foo.tab.c foo.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:44: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:44"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:44"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:44: bison --xml=xml-tests/test.xml -dv foo.y "
at_fn_check_prepare_trace "output.at:44"
( $at_check_trace; bison --xml=xml-tests/test.xml -dv foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:44"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:44: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:44"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:44"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:44: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:44"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:44"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:44: bison -dv foo.y "
at_fn_check_prepare_trace "output.at:44"
( $at_check_trace; bison -dv foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:44"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:44: ls foo.output foo.tab.c foo.tab.h"
at_fn_check_prepare_trace "output.at:44"
( $at_check_trace; ls foo.output foo.tab.c foo.tab.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:44"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_42
#AT_START_43
at_fn_group_banner 43 'output.at:46' \
  "Output files:  -dv >&-" "                         " 3
at_xfail=no
(
  $as_echo "43. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y foo.output foo.tab.c foo.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:46: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv foo.y >&-"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:46"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv foo.y >&-
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:46"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:46: bison --xml=xml-tests/test.xml -dv foo.y >&-"
at_fn_check_prepare_trace "output.at:46"
( $at_check_trace; bison --xml=xml-tests/test.xml -dv foo.y >&-
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:46"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:46: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:46"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:46"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:46: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:46"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:46"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:46: bison -dv foo.y >&-"
at_fn_check_prepare_trace "output.at:46"
( $at_check_trace; bison -dv foo.y >&-
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:46"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:46: ls foo.output foo.tab.c foo.tab.h"
at_fn_check_prepare_trace "output.at:46"
( $at_check_trace; ls foo.output foo.tab.c foo.tab.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:46"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_43
#AT_START_44
at_fn_group_banner 44 'output.at:49' \
  "Output files:  -dv -o foo.c " "                   " 3
at_xfail=no
(
  $as_echo "44. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y foo.c foo.h foo.output; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:49: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -o foo.c foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:49"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -o foo.c foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:49"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:49: bison --xml=xml-tests/test.xml -dv -o foo.c foo.y "
at_fn_check_prepare_trace "output.at:49"
( $at_check_trace; bison --xml=xml-tests/test.xml -dv -o foo.c foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:49"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:49: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:49"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:49"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:49: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:49"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:49"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:49: bison -dv -o foo.c foo.y "
at_fn_check_prepare_trace "output.at:49"
( $at_check_trace; bison -dv -o foo.c foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:49"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:49: ls foo.c foo.h foo.output"
at_fn_check_prepare_trace "output.at:49"
( $at_check_trace; ls foo.c foo.h foo.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:49"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_44
#AT_START_45
at_fn_group_banner 45 'output.at:51' \
  "Output files:  -dv -o foo.tab.c " "               " 3
at_xfail=no
(
  $as_echo "45. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y foo.output foo.tab.c foo.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:51: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -o foo.tab.c foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:51"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -o foo.tab.c foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:51"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:51: bison --xml=xml-tests/test.xml -dv -o foo.tab.c foo.y "
at_fn_check_prepare_trace "output.at:51"
( $at_check_trace; bison --xml=xml-tests/test.xml -dv -o foo.tab.c foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:51"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:51: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:51"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:51"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:51: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:51"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:51"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:51: bison -dv -o foo.tab.c foo.y "
at_fn_check_prepare_trace "output.at:51"
( $at_check_trace; bison -dv -o foo.tab.c foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:51"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:51: ls foo.output foo.tab.c foo.tab.h"
at_fn_check_prepare_trace "output.at:51"
( $at_check_trace; ls foo.output foo.tab.c foo.tab.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:51"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_45
#AT_START_46
at_fn_group_banner 46 'output.at:53' \
  "Output files:  -dv -y " "                         " 3
at_xfail=no
(
  $as_echo "46. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y y.output y.tab.c y.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:53: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -y foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:53"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -y foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:53"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:53: bison --xml=xml-tests/test.xml -dv -y foo.y "
at_fn_check_prepare_trace "output.at:53"
( $at_check_trace; bison --xml=xml-tests/test.xml -dv -y foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:53"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:53: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:53"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:53"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:53: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:53"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:53"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:53: bison -dv -y foo.y "
at_fn_check_prepare_trace "output.at:53"
( $at_check_trace; bison -dv -y foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:53"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:53: ls y.output y.tab.c y.tab.h"
at_fn_check_prepare_trace "output.at:53"
( $at_check_trace; ls y.output y.tab.c y.tab.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:53"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_46
#AT_START_47
at_fn_group_banner 47 'output.at:55' \
  "Output files:  -dv -b bar " "                     " 3
at_xfail=no
(
  $as_echo "47. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y bar.output bar.tab.c bar.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:55: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -b bar foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:55"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -b bar foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:55"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:55: bison --xml=xml-tests/test.xml -dv -b bar foo.y "
at_fn_check_prepare_trace "output.at:55"
( $at_check_trace; bison --xml=xml-tests/test.xml -dv -b bar foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:55"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:55: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:55"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:55"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:55: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:55"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:55"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:55: bison -dv -b bar foo.y "
at_fn_check_prepare_trace "output.at:55"
( $at_check_trace; bison -dv -b bar foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:55"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:55: ls bar.output bar.tab.c bar.tab.h"
at_fn_check_prepare_trace "output.at:55"
( $at_check_trace; ls bar.output bar.tab.c bar.tab.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:55"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_47
#AT_START_48
at_fn_group_banner 48 'output.at:57' \
  "Output files:  -dv -g -o foo.c " "                " 3
at_xfail=no
(
  $as_echo "48. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y foo.c foo.dot foo.h foo.output; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:57: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -g -o foo.c foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:57"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -g -o foo.c foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:57"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:57: bison --xml=xml-tests/test.xml -dv -g -o foo.c foo.y "
at_fn_check_prepare_trace "output.at:57"
( $at_check_trace; bison --xml=xml-tests/test.xml -dv -g -o foo.c foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:57"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:57: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:57"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:57"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:57: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:57"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:57"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:57: bison -dv -g -o foo.c foo.y "
at_fn_check_prepare_trace "output.at:57"
( $at_check_trace; bison -dv -g -o foo.c foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:57"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:57: ls foo.c foo.dot foo.h foo.output"
at_fn_check_prepare_trace "output.at:57"
( $at_check_trace; ls foo.c foo.dot foo.h foo.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:57"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_48
#AT_START_49
at_fn_group_banner 49 'output.at:61' \
  "Output files: %defines %verbose  " "              " 3
at_xfail=no
(
  $as_echo "49. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y foo.output foo.tab.c foo.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:61: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:61"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:61"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:61: bison --xml=xml-tests/test.xml  foo.y "
at_fn_check_prepare_trace "output.at:61"
( $at_check_trace; bison --xml=xml-tests/test.xml  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:61"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:61: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:61"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:61"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:61: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:61"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:61"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:61: bison  foo.y "
at_fn_check_prepare_trace "output.at:61"
( $at_check_trace; bison  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:61"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:61: ls foo.output foo.tab.c foo.tab.h"
at_fn_check_prepare_trace "output.at:61"
( $at_check_trace; ls foo.output foo.tab.c foo.tab.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:61"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_49
#AT_START_50
at_fn_group_banner 50 'output.at:63' \
  "Output files: %defines %verbose %yacc  " "        " 3
at_xfail=no
(
  $as_echo "50. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y y.output y.tab.c y.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:63: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:63"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:63"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:63: bison --xml=xml-tests/test.xml  foo.y "
at_fn_check_prepare_trace "output.at:63"
( $at_check_trace; bison --xml=xml-tests/test.xml  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:63"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:63: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:63"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:63"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:63: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:63"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:63"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:63: bison  foo.y "
at_fn_check_prepare_trace "output.at:63"
( $at_check_trace; bison  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:63"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:63: ls y.output y.tab.c y.tab.h"
at_fn_check_prepare_trace "output.at:63"
( $at_check_trace; ls y.output y.tab.c y.tab.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:63"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_50
#AT_START_51
at_fn_group_banner 51 'output.at:66' \
  "Output files: %defines %verbose %yacc  " "        " 3
at_xfail=no
(
  $as_echo "51. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.yy y.output y.tab.c y.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:66: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:66"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:66"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:66: bison --xml=xml-tests/test.xml  foo.yy "
at_fn_check_prepare_trace "output.at:66"
( $at_check_trace; bison --xml=xml-tests/test.xml  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:66"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:66: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:66"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:66"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:66: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:66"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:66"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:66: bison  foo.yy "
at_fn_check_prepare_trace "output.at:66"
( $at_check_trace; bison  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:66"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:66: ls y.output y.tab.c y.tab.h"
at_fn_check_prepare_trace "output.at:66"
( $at_check_trace; ls y.output y.tab.c y.tab.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:66"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_51
#AT_START_52
at_fn_group_banner 52 'output.at:70' \
  "Output files: %file-prefix \"bar\" %defines %verbose  " "" 3
at_xfail=no
(
  $as_echo "52. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y bar.output bar.tab.c bar.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%file-prefix "bar" %defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:70: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:70"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:70: bison --xml=xml-tests/test.xml  foo.y "
at_fn_check_prepare_trace "output.at:70"
( $at_check_trace; bison --xml=xml-tests/test.xml  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:70: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:70"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:70: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:70"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:70: bison  foo.y "
at_fn_check_prepare_trace "output.at:70"
( $at_check_trace; bison  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:70: ls bar.output bar.tab.c bar.tab.h"
at_fn_check_prepare_trace "output.at:70"
( $at_check_trace; ls bar.output bar.tab.c bar.tab.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_52
#AT_START_53
at_fn_group_banner 53 'output.at:72' \
  "Output files: %output=\"bar.c\" %defines %verbose %yacc  " "" 3
at_xfail=no
(
  $as_echo "53. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y bar.output bar.c bar.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%output="bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:72: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:72"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:72: bison --xml=xml-tests/test.xml  foo.y "
at_fn_check_prepare_trace "output.at:72"
( $at_check_trace; bison --xml=xml-tests/test.xml  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:72: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:72"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:72: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:72"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:72: bison  foo.y "
at_fn_check_prepare_trace "output.at:72"
( $at_check_trace; bison  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:72: ls bar.output bar.c bar.h"
at_fn_check_prepare_trace "output.at:72"
( $at_check_trace; ls bar.output bar.c bar.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_53
#AT_START_54
at_fn_group_banner 54 'output.at:74' \
  "Output files: %file-prefix=\"baz\" %output \"bar.c\" %defines %verbose %yacc  " "" 3
at_xfail=no
(
  $as_echo "54. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.y bar.output bar.c bar.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%file-prefix="baz" %output "bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:74: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:74"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:74"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:74: bison --xml=xml-tests/test.xml  foo.y "
at_fn_check_prepare_trace "output.at:74"
( $at_check_trace; bison --xml=xml-tests/test.xml  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:74"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:74: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:74"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:74"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:74: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:74"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:74"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:74: bison  foo.y "
at_fn_check_prepare_trace "output.at:74"
( $at_check_trace; bison  foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:74"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:74: ls bar.output bar.c bar.h"
at_fn_check_prepare_trace "output.at:74"
( $at_check_trace; ls bar.output bar.c bar.h
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:74"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_54
#AT_START_55
at_fn_group_banner 55 'output.at:81' \
  "Output files: %defines %verbose  " "              " 3
at_xfail=no
(
  $as_echo "55. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.yy foo.output foo.tab.cc foo.tab.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:81: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:81"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:81: bison --xml=xml-tests/test.xml  foo.yy "
at_fn_check_prepare_trace "output.at:81"
( $at_check_trace; bison --xml=xml-tests/test.xml  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:81: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:81"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:81: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:81"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:81: bison  foo.yy "
at_fn_check_prepare_trace "output.at:81"
( $at_check_trace; bison  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:81: ls foo.output foo.tab.cc foo.tab.hh"
at_fn_check_prepare_trace "output.at:81"
( $at_check_trace; ls foo.output foo.tab.cc foo.tab.hh
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_55
#AT_START_56
at_fn_group_banner 56 'output.at:84' \
  "Output files: %defines %verbose  -o foo.c " "     " 3
at_xfail=no
(
  $as_echo "56. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.yy foo.c foo.h foo.output; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:84: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o foo.c foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:84"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o foo.c foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:84"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:84: bison --xml=xml-tests/test.xml -o foo.c foo.yy "
at_fn_check_prepare_trace "output.at:84"
( $at_check_trace; bison --xml=xml-tests/test.xml -o foo.c foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:84"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:84: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:84"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:84"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:84: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:84"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:84"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:84: bison -o foo.c foo.yy "
at_fn_check_prepare_trace "output.at:84"
( $at_check_trace; bison -o foo.c foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:84"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:84: ls foo.c foo.h foo.output"
at_fn_check_prepare_trace "output.at:84"
( $at_check_trace; ls foo.c foo.h foo.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:84"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_56
#AT_START_57
at_fn_group_banner 57 'output.at:87' \
  "Output files:  --defines=foo.hpp -o foo.c++ " "   " 3
at_xfail=no
(
  $as_echo "57. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.yy foo.c++ foo.hpp; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:87: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines=foo.hpp -o foo.c++ foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:87"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines=foo.hpp -o foo.c++ foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:87"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:87: bison --xml=xml-tests/test.xml --defines=foo.hpp -o foo.c++ foo.yy "
at_fn_check_prepare_trace "output.at:87"
( $at_check_trace; bison --xml=xml-tests/test.xml --defines=foo.hpp -o foo.c++ foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:87"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:87: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:87"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:87"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:87: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:87"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:87"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:87: bison --defines=foo.hpp -o foo.c++ foo.yy "
at_fn_check_prepare_trace "output.at:87"
( $at_check_trace; bison --defines=foo.hpp -o foo.c++ foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:87"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:87: ls foo.c++ foo.hpp"
at_fn_check_prepare_trace "output.at:87"
( $at_check_trace; ls foo.c++ foo.hpp
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:87"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_57
#AT_START_58
at_fn_group_banner 58 'output.at:91' \
  "Output files: %defines \"foo.hpp\" -o foo.c++ " "   " 3
at_xfail=no
(
  $as_echo "58. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.yy foo.c++ foo.hpp; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%defines "foo.hpp"
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:91: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o foo.c++ foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:91"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o foo.c++ foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:91: bison --xml=xml-tests/test.xml -o foo.c++ foo.yy "
at_fn_check_prepare_trace "output.at:91"
( $at_check_trace; bison --xml=xml-tests/test.xml -o foo.c++ foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:91: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:91"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:91: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:91"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:91: bison -o foo.c++ foo.yy "
at_fn_check_prepare_trace "output.at:91"
( $at_check_trace; bison -o foo.c++ foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:91: ls foo.c++ foo.hpp"
at_fn_check_prepare_trace "output.at:91"
( $at_check_trace; ls foo.c++ foo.hpp
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_58
#AT_START_59
at_fn_group_banner 59 'output.at:95' \
  "Output files:  -o foo.c++ --graph=foo.gph " "     " 3
at_xfail=no
(
  $as_echo "59. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.yy foo.c++ foo.gph; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:95: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o foo.c++  foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:95"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o foo.c++  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:95"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:95: bison --xml=xml-tests/test.xml -o foo.c++  foo.yy "
at_fn_check_prepare_trace "output.at:95"
( $at_check_trace; bison --xml=xml-tests/test.xml -o foo.c++  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:95"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:95: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:95"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:95"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:95: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:95"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:95"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:95: bison -o foo.c++ --graph=foo.gph foo.yy "
at_fn_check_prepare_trace "output.at:95"
( $at_check_trace; bison -o foo.c++ --graph=foo.gph foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:95"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:95: ls foo.c++ foo.gph"
at_fn_check_prepare_trace "output.at:95"
( $at_check_trace; ls foo.c++ foo.gph
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:95"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_59
#AT_START_60
at_fn_group_banner 60 'output.at:110' \
  "Output files: %skeleton \"lalr1.cc\" %defines %verbose  " "" 3
at_xfail=no
(
  $as_echo "60. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.yy foo.tab.cc foo.tab.hh foo.output stack.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:110: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:110"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:110"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:110: bison --xml=xml-tests/test.xml  foo.yy "
at_fn_check_prepare_trace "output.at:110"
( $at_check_trace; bison --xml=xml-tests/test.xml  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:110"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:110: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:110"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:110"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:110: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:110"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:110"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:110: bison  foo.yy "
at_fn_check_prepare_trace "output.at:110"
( $at_check_trace; bison  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:110"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:110: ls foo.tab.cc foo.tab.hh foo.output stack.hh"
at_fn_check_prepare_trace "output.at:110"
( $at_check_trace; ls foo.tab.cc foo.tab.hh foo.output stack.hh
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:110"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_60
#AT_START_61
at_fn_group_banner 61 'output.at:113' \
  "Output files: %skeleton \"lalr1.cc\" %defines %verbose %locations  " "" 3
at_xfail=no
(
  $as_echo "61. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in foo.yy foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %verbose %locations
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:113: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:113"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:113"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:113: bison --xml=xml-tests/test.xml  foo.yy "
at_fn_check_prepare_trace "output.at:113"
( $at_check_trace; bison --xml=xml-tests/test.xml  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:113"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:113: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:113"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:113"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:113: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:113"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:113"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:113: bison  foo.yy "
at_fn_check_prepare_trace "output.at:113"
( $at_check_trace; bison  foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:113"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:113: ls foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh"
at_fn_check_prepare_trace "output.at:113"
( $at_check_trace; ls foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:113"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_61
#AT_START_62
at_fn_group_banner 62 'output.at:116' \
  "Output files: %skeleton \"lalr1.cc\" %defines %verbose  " "" 3
at_xfail=no
(
  $as_echo "62. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in subdir/foo.yy foo.tab.cc foo.tab.hh foo.output stack.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >subdir/foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:116: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  subdir/foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:116"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  subdir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:116: bison --xml=xml-tests/test.xml  subdir/foo.yy "
at_fn_check_prepare_trace "output.at:116"
( $at_check_trace; bison --xml=xml-tests/test.xml  subdir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:116: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:116"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:116: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:116"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:116: bison  subdir/foo.yy "
at_fn_check_prepare_trace "output.at:116"
( $at_check_trace; bison  subdir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:116: ls foo.tab.cc foo.tab.hh foo.output stack.hh"
at_fn_check_prepare_trace "output.at:116"
( $at_check_trace; ls foo.tab.cc foo.tab.hh foo.output stack.hh
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }

# Also make sure that the includes do not refer to the subdirectory.
{ set +x
$as_echo "$at_srcdir/output.at:116: grep 'include .subdir/' foo.tab.cc"
at_fn_check_prepare_trace "output.at:116"
( $at_check_trace; grep 'include .subdir/' foo.tab.cc
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/output.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:116: grep 'include .subdir/' foo.tab.hh"
at_fn_check_prepare_trace "output.at:116"
( $at_check_trace; grep 'include .subdir/' foo.tab.hh
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/output.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_62
#AT_START_63
at_fn_group_banner 63 'output.at:120' \
  "Output files: %skeleton \"lalr1.cc\" %defines %verbose %locations -o subdir/foo.cc " "" 3
at_xfail=no
(
  $as_echo "63. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in subdir/foo.yy subdir/foo.cc subdir/foo.hh subdir/foo.output subdir/location.hh subdir/stack.hh subdir/position.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >subdir/foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %verbose %locations
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:120: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o subdir/foo.cc subdir/foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:120"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o subdir/foo.cc subdir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:120"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:120: bison --xml=xml-tests/test.xml -o subdir/foo.cc subdir/foo.yy "
at_fn_check_prepare_trace "output.at:120"
( $at_check_trace; bison --xml=xml-tests/test.xml -o subdir/foo.cc subdir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:120"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:120: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:120"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:120"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:120: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:120"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:120"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:120: bison -o subdir/foo.cc subdir/foo.yy "
at_fn_check_prepare_trace "output.at:120"
( $at_check_trace; bison -o subdir/foo.cc subdir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:120"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:120: ls subdir/foo.cc subdir/foo.hh subdir/foo.output subdir/location.hh subdir/stack.hh subdir/position.hh"
at_fn_check_prepare_trace "output.at:120"
( $at_check_trace; ls subdir/foo.cc subdir/foo.hh subdir/foo.output subdir/location.hh subdir/stack.hh subdir/position.hh
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:120"
$at_failed && at_fn_log_failure
$at_traceon; }

# Also make sure that the includes do not refer to the subdirectory.
{ set +x
$as_echo "$at_srcdir/output.at:120: grep 'include .subdir/' subdir/foo.cc"
at_fn_check_prepare_trace "output.at:120"
( $at_check_trace; grep 'include .subdir/' subdir/foo.cc
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/output.at:120"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:120: grep 'include .subdir/' subdir/foo.hh"
at_fn_check_prepare_trace "output.at:120"
( $at_check_trace; grep 'include .subdir/' subdir/foo.hh
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/output.at:120"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_63
#AT_START_64
at_fn_group_banner 64 'output.at:125' \
  "Output files: %skeleton \"lalr1.cc\" %defines %verbose %file-prefix \"output_dir/foo\"  " "" 3
at_xfail=no
(
  $as_echo "64. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in gram_dir/foo.yy output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/stack.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >gram_dir/foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %verbose %file-prefix "output_dir/foo"
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:125: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  gram_dir/foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:125"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  gram_dir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:125"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:125: bison --xml=xml-tests/test.xml  gram_dir/foo.yy "
at_fn_check_prepare_trace "output.at:125"
( $at_check_trace; bison --xml=xml-tests/test.xml  gram_dir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:125"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:125: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:125"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:125"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:125: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:125"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:125"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:125: bison  gram_dir/foo.yy "
at_fn_check_prepare_trace "output.at:125"
( $at_check_trace; bison  gram_dir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:125"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:125: ls output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/stack.hh"
at_fn_check_prepare_trace "output.at:125"
( $at_check_trace; ls output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/stack.hh
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:125"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_64
#AT_START_65
at_fn_group_banner 65 'output.at:130' \
  "Output files: %skeleton \"lalr1.cc\" %defines %locations %verbose %file-prefix \"output_dir/foo\"  " "" 3
at_xfail=no
(
  $as_echo "65. $at_setup_line: testing $at_desc ..."
  $at_traceon

for file in gram_dir/foo.yy output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/location.hh output_dir/stack.hh output_dir/position.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >gram_dir/foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %locations %verbose %file-prefix "output_dir/foo"
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:130: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  gram_dir/foo.yy "
at_fn_check_prepare_notrace 'an embedded newline' "output.at:130"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  gram_dir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:130: bison --xml=xml-tests/test.xml  gram_dir/foo.yy "
at_fn_check_prepare_trace "output.at:130"
( $at_check_trace; bison --xml=xml-tests/test.xml  gram_dir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:130: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:130"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:130: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:130"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:130: bison  gram_dir/foo.yy "
at_fn_check_prepare_trace "output.at:130"
( $at_check_trace; bison  gram_dir/foo.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:130: ls output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/location.hh output_dir/stack.hh output_dir/position.hh"
at_fn_check_prepare_trace "output.at:130"
( $at_check_trace; ls output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/location.hh output_dir/stack.hh output_dir/position.hh
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_65
#AT_START_66
at_fn_group_banner 66 'output.at:160' \
  "Conflicting output files:  --graph=\"foo.tab.c\"" " " 3
at_xfail=no
(
  $as_echo "66. $at_setup_line: testing $at_desc ..."
  $at_traceon

case "foo.y" in
  */*) mkdir `echo "foo.y" | sed 's,/.*,,'`;;
esac
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


cp foo.y expout
# Because an output file name conflict is still a warning, Bison exits
# with status 0, so AT_BISON_CHECK does not realize that there may be no
# output file against which to check the XML.  AT_BISON_CHECK_NO_XML
# avoids that problem.
{ set +x
$as_echo "$at_srcdir/output.at:160: bison --graph=\"foo.tab.c\" foo.y"
at_fn_check_prepare_trace "output.at:160"
( $at_check_trace; bison --graph="foo.tab.c" foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "foo.y: warning: conflicting outputs to file \`foo.tab.c'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:160"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:160: cat foo.y"
at_fn_check_prepare_trace "output.at:160"
( $at_check_trace; cat foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:160"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_66
#AT_START_67
at_fn_group_banner 67 'output.at:165' \
  "Conflicting output files: %defines \"foo.output\" -v" "" 3
at_xfail=no
(
  $as_echo "67. $at_setup_line: testing $at_desc ..."
  $at_traceon

case "foo.y" in
  */*) mkdir `echo "foo.y" | sed 's,/.*,,'`;;
esac
cat >foo.y <<'_ATEOF'
%defines "foo.output"
%%
foo: {};
_ATEOF


cp foo.y expout
# Because an output file name conflict is still a warning, Bison exits
# with status 0, so AT_BISON_CHECK does not realize that there may be no
# output file against which to check the XML.  AT_BISON_CHECK_NO_XML
# avoids that problem.
{ set +x
$as_echo "$at_srcdir/output.at:165: bison -v foo.y"
at_fn_check_prepare_trace "output.at:165"
( $at_check_trace; bison -v foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "foo.y: warning: conflicting outputs to file \`foo.output'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:165"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:165: cat foo.y"
at_fn_check_prepare_trace "output.at:165"
( $at_check_trace; cat foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:165"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_67
#AT_START_68
at_fn_group_banner 68 'output.at:170' \
  "Conflicting output files: %skeleton \"lalr1.cc\" %defines %locations --graph=\"location.hh\"" "" 3
at_xfail=no
(
  $as_echo "68. $at_setup_line: testing $at_desc ..."
  $at_traceon

case "foo.y" in
  */*) mkdir `echo "foo.y" | sed 's,/.*,,'`;;
esac
cat >foo.y <<'_ATEOF'
%skeleton "lalr1.cc" %defines %locations
%%
foo: {};
_ATEOF


cp foo.y expout
# Because an output file name conflict is still a warning, Bison exits
# with status 0, so AT_BISON_CHECK does not realize that there may be no
# output file against which to check the XML.  AT_BISON_CHECK_NO_XML
# avoids that problem.
{ set +x
$as_echo "$at_srcdir/output.at:170: bison --graph=\"location.hh\" foo.y"
at_fn_check_prepare_trace "output.at:170"
( $at_check_trace; bison --graph="location.hh" foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "foo.y: warning: conflicting outputs to file \`location.hh'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:170"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:170: cat foo.y"
at_fn_check_prepare_trace "output.at:170"
( $at_check_trace; cat foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:170"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_68
#AT_START_69
at_fn_group_banner 69 'output.at:175' \
  "Conflicting output files:  -o foo.y" "            " 3
at_xfail=no
(
  $as_echo "69. $at_setup_line: testing $at_desc ..."
  $at_traceon

case "foo.y" in
  */*) mkdir `echo "foo.y" | sed 's,/.*,,'`;;
esac
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


cp foo.y expout
# Because an output file name conflict is still a warning, Bison exits
# with status 0, so AT_BISON_CHECK does not realize that there may be no
# output file against which to check the XML.  AT_BISON_CHECK_NO_XML
# avoids that problem.
{ set +x
$as_echo "$at_srcdir/output.at:175: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o foo.y foo.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o foo.y foo.y" "output.at:175"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o foo.y foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "foo.y: refusing to overwrite the input file \`foo.y'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/output.at:175"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:175: cat foo.y"
at_fn_check_prepare_trace "output.at:175"
( $at_check_trace; cat foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:175"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_69
#AT_START_70
at_fn_group_banner 70 'output.at:219' \
  "Output file name: \`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'" "" 3
at_xfail=no
(
  $as_echo "70. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Skip if platform doesn't support file name.  For example, Cygwin
# doesn't support file names containing ":" or "\".
{ set +x
$as_echo "$at_srcdir/output.at:219: touch \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.tmp\" || exit 77"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; touch "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.tmp" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:219: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" glr.y"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:219: bison --xml=xml-tests/test.xml -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" glr.y"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:219: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:219: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:219: bison -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" glr.y"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; bison -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:219: ls \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\""
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; ls "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:219: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\""
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o glr.o -c "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:219: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" cxx.y"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:219: bison --xml=xml-tests/test.xml -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" cxx.y"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:219: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:219: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:219: bison -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" cxx.y"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; bison -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:219: ls \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\""
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; ls "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/output.at:219: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "output.at:219"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:219: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\""
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:219"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_70
#AT_START_71
at_fn_group_banner 71 'output.at:226' \
  "Output file name: (" "                            " 3
at_xfail=no
(
  $as_echo "71. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Skip if platform doesn't support file name.  For example, Cygwin
# doesn't support file names containing ":" or "\".
{ set +x
$as_echo "$at_srcdir/output.at:226: touch \"(.tmp\" || exit 77"
at_fn_check_prepare_trace "output.at:226"
( $at_check_trace; touch "(.tmp" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:226: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"(.c\" --defines=\"(.h\" glr.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:226"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "(.c" --defines="(.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:226: bison --xml=xml-tests/test.xml -o \"(.c\" --defines=\"(.h\" glr.y"
at_fn_check_prepare_trace "output.at:226"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "(.c" --defines="(.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:226: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:226"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:226: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:226"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:226: bison -o \"(.c\" --defines=\"(.h\" glr.y"
at_fn_check_prepare_trace "output.at:226"
( $at_check_trace; bison -o "(.c" --defines="(.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:226: ls \"(.c\" \"(.h\""
at_fn_check_prepare_trace "output.at:226"
( $at_check_trace; ls "(.c" "(.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:226: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"(.c\""
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"(.c\"" "output.at:226"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o glr.o -c "(.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:226: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"(.c\" --defines=\"(.h\" cxx.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:226"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "(.c" --defines="(.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:226: bison --xml=xml-tests/test.xml -o \"(.c\" --defines=\"(.h\" cxx.y"
at_fn_check_prepare_trace "output.at:226"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "(.c" --defines="(.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:226: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:226"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:226: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:226"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:226: bison -o \"(.c\" --defines=\"(.h\" cxx.y"
at_fn_check_prepare_trace "output.at:226"
( $at_check_trace; bison -o "(.c" --defines="(.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:226: ls \"(.c\" \"(.h\""
at_fn_check_prepare_trace "output.at:226"
( $at_check_trace; ls "(.c" "(.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/output.at:226: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "output.at:226"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:226: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"(.c\""
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"(.c\"" "output.at:226"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "(.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:226"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_71
#AT_START_72
at_fn_group_banner 72 'output.at:227' \
  "Output file name: )" "                            " 3
at_xfail=no
(
  $as_echo "72. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Skip if platform doesn't support file name.  For example, Cygwin
# doesn't support file names containing ":" or "\".
{ set +x
$as_echo "$at_srcdir/output.at:227: touch \").tmp\" || exit 77"
at_fn_check_prepare_trace "output.at:227"
( $at_check_trace; touch ").tmp" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:227: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \").c\" --defines=\").h\" glr.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:227"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o ").c" --defines=").h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:227: bison --xml=xml-tests/test.xml -o \").c\" --defines=\").h\" glr.y"
at_fn_check_prepare_trace "output.at:227"
( $at_check_trace; bison --xml=xml-tests/test.xml -o ").c" --defines=").h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:227: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:227"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:227: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:227"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:227: bison -o \").c\" --defines=\").h\" glr.y"
at_fn_check_prepare_trace "output.at:227"
( $at_check_trace; bison -o ").c" --defines=").h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:227: ls \").c\" \").h\""
at_fn_check_prepare_trace "output.at:227"
( $at_check_trace; ls ").c" ").h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:227: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \").c\""
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o glr.o -c \").c\"" "output.at:227"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o glr.o -c ").c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:227: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \").c\" --defines=\").h\" cxx.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:227"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o ").c" --defines=").h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:227: bison --xml=xml-tests/test.xml -o \").c\" --defines=\").h\" cxx.y"
at_fn_check_prepare_trace "output.at:227"
( $at_check_trace; bison --xml=xml-tests/test.xml -o ").c" --defines=").h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:227: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:227"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:227: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:227"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:227: bison -o \").c\" --defines=\").h\" cxx.y"
at_fn_check_prepare_trace "output.at:227"
( $at_check_trace; bison -o ").c" --defines=").h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:227: ls \").c\" \").h\""
at_fn_check_prepare_trace "output.at:227"
( $at_check_trace; ls ").c" ").h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/output.at:227: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "output.at:227"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:227: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \").c\""
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \").c\"" "output.at:227"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c ").c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:227"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_72
#AT_START_73
at_fn_group_banner 73 'output.at:228' \
  "Output file name: #" "                            " 3
at_xfail=no
(
  $as_echo "73. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Skip if platform doesn't support file name.  For example, Cygwin
# doesn't support file names containing ":" or "\".
{ set +x
$as_echo "$at_srcdir/output.at:228: touch \"#.tmp\" || exit 77"
at_fn_check_prepare_trace "output.at:228"
( $at_check_trace; touch "#.tmp" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:228: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"#.c\" --defines=\"#.h\" glr.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:228"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "#.c" --defines="#.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:228: bison --xml=xml-tests/test.xml -o \"#.c\" --defines=\"#.h\" glr.y"
at_fn_check_prepare_trace "output.at:228"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "#.c" --defines="#.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:228: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:228"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:228: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:228"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:228: bison -o \"#.c\" --defines=\"#.h\" glr.y"
at_fn_check_prepare_trace "output.at:228"
( $at_check_trace; bison -o "#.c" --defines="#.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:228: ls \"#.c\" \"#.h\""
at_fn_check_prepare_trace "output.at:228"
( $at_check_trace; ls "#.c" "#.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:228: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"#.c\""
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"#.c\"" "output.at:228"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o glr.o -c "#.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:228: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"#.c\" --defines=\"#.h\" cxx.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:228"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "#.c" --defines="#.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:228: bison --xml=xml-tests/test.xml -o \"#.c\" --defines=\"#.h\" cxx.y"
at_fn_check_prepare_trace "output.at:228"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "#.c" --defines="#.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:228: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:228"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:228: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:228"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:228: bison -o \"#.c\" --defines=\"#.h\" cxx.y"
at_fn_check_prepare_trace "output.at:228"
( $at_check_trace; bison -o "#.c" --defines="#.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:228: ls \"#.c\" \"#.h\""
at_fn_check_prepare_trace "output.at:228"
( $at_check_trace; ls "#.c" "#.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/output.at:228: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "output.at:228"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:228: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"#.c\""
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"#.c\"" "output.at:228"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "#.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_73
#AT_START_74
at_fn_group_banner 74 'output.at:229' \
  "Output file name: @@" "                           " 3
at_xfail=no
(
  $as_echo "74. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Skip if platform doesn't support file name.  For example, Cygwin
# doesn't support file names containing ":" or "\".
{ set +x
$as_echo "$at_srcdir/output.at:229: touch \"@@.tmp\" || exit 77"
at_fn_check_prepare_trace "output.at:229"
( $at_check_trace; touch "@@.tmp" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:229: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@@.c\" --defines=\"@@.h\" glr.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:229"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@@.c" --defines="@@.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:229: bison --xml=xml-tests/test.xml -o \"@@.c\" --defines=\"@@.h\" glr.y"
at_fn_check_prepare_trace "output.at:229"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "@@.c" --defines="@@.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:229: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:229"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:229: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:229"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:229: bison -o \"@@.c\" --defines=\"@@.h\" glr.y"
at_fn_check_prepare_trace "output.at:229"
( $at_check_trace; bison -o "@@.c" --defines="@@.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:229: ls \"@@.c\" \"@@.h\""
at_fn_check_prepare_trace "output.at:229"
( $at_check_trace; ls "@@.c" "@@.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:229: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"@@.c\""
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"@@.c\"" "output.at:229"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o glr.o -c "@@.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:229: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@@.c\" --defines=\"@@.h\" cxx.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:229"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@@.c" --defines="@@.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:229: bison --xml=xml-tests/test.xml -o \"@@.c\" --defines=\"@@.h\" cxx.y"
at_fn_check_prepare_trace "output.at:229"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "@@.c" --defines="@@.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:229: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:229"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:229: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:229"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:229: bison -o \"@@.c\" --defines=\"@@.h\" cxx.y"
at_fn_check_prepare_trace "output.at:229"
( $at_check_trace; bison -o "@@.c" --defines="@@.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:229: ls \"@@.c\" \"@@.h\""
at_fn_check_prepare_trace "output.at:229"
( $at_check_trace; ls "@@.c" "@@.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/output.at:229: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "output.at:229"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:229: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"@@.c\""
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"@@.c\"" "output.at:229"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "@@.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:229"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_74
#AT_START_75
at_fn_group_banner 75 'output.at:230' \
  "Output file name: @{" "                           " 3
at_xfail=no
(
  $as_echo "75. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Skip if platform doesn't support file name.  For example, Cygwin
# doesn't support file names containing ":" or "\".
{ set +x
$as_echo "$at_srcdir/output.at:230: touch \"@{.tmp\" || exit 77"
at_fn_check_prepare_trace "output.at:230"
( $at_check_trace; touch "@{.tmp" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:230: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@{.c\" --defines=\"@{.h\" glr.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:230"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@{.c" --defines="@{.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:230: bison --xml=xml-tests/test.xml -o \"@{.c\" --defines=\"@{.h\" glr.y"
at_fn_check_prepare_trace "output.at:230"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "@{.c" --defines="@{.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:230: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:230"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:230: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:230"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:230: bison -o \"@{.c\" --defines=\"@{.h\" glr.y"
at_fn_check_prepare_trace "output.at:230"
( $at_check_trace; bison -o "@{.c" --defines="@{.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:230: ls \"@{.c\" \"@{.h\""
at_fn_check_prepare_trace "output.at:230"
( $at_check_trace; ls "@{.c" "@{.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:230: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"@{.c\""
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"@{.c\"" "output.at:230"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o glr.o -c "@{.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:230: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@{.c\" --defines=\"@{.h\" cxx.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:230"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@{.c" --defines="@{.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:230: bison --xml=xml-tests/test.xml -o \"@{.c\" --defines=\"@{.h\" cxx.y"
at_fn_check_prepare_trace "output.at:230"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "@{.c" --defines="@{.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:230: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:230"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:230: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:230"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:230: bison -o \"@{.c\" --defines=\"@{.h\" cxx.y"
at_fn_check_prepare_trace "output.at:230"
( $at_check_trace; bison -o "@{.c" --defines="@{.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:230: ls \"@{.c\" \"@{.h\""
at_fn_check_prepare_trace "output.at:230"
( $at_check_trace; ls "@{.c" "@{.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/output.at:230: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "output.at:230"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:230: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"@{.c\""
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"@{.c\"" "output.at:230"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "@{.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_75
#AT_START_76
at_fn_group_banner 76 'output.at:231' \
  "Output file name: @}" "                           " 3
at_xfail=no
(
  $as_echo "76. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Skip if platform doesn't support file name.  For example, Cygwin
# doesn't support file names containing ":" or "\".
{ set +x
$as_echo "$at_srcdir/output.at:231: touch \"@}.tmp\" || exit 77"
at_fn_check_prepare_trace "output.at:231"
( $at_check_trace; touch "@}.tmp" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:231: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@}.c\" --defines=\"@}.h\" glr.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:231"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@}.c" --defines="@}.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:231: bison --xml=xml-tests/test.xml -o \"@}.c\" --defines=\"@}.h\" glr.y"
at_fn_check_prepare_trace "output.at:231"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "@}.c" --defines="@}.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:231: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:231"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:231: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:231"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:231: bison -o \"@}.c\" --defines=\"@}.h\" glr.y"
at_fn_check_prepare_trace "output.at:231"
( $at_check_trace; bison -o "@}.c" --defines="@}.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:231: ls \"@}.c\" \"@}.h\""
at_fn_check_prepare_trace "output.at:231"
( $at_check_trace; ls "@}.c" "@}.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:231: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"@}.c\""
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"@}.c\"" "output.at:231"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o glr.o -c "@}.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:231: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@}.c\" --defines=\"@}.h\" cxx.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:231"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@}.c" --defines="@}.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:231: bison --xml=xml-tests/test.xml -o \"@}.c\" --defines=\"@}.h\" cxx.y"
at_fn_check_prepare_trace "output.at:231"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "@}.c" --defines="@}.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:231: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:231"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:231: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:231"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:231: bison -o \"@}.c\" --defines=\"@}.h\" cxx.y"
at_fn_check_prepare_trace "output.at:231"
( $at_check_trace; bison -o "@}.c" --defines="@}.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:231: ls \"@}.c\" \"@}.h\""
at_fn_check_prepare_trace "output.at:231"
( $at_check_trace; ls "@}.c" "@}.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/output.at:231: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "output.at:231"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:231: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"@}.c\""
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"@}.c\"" "output.at:231"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "@}.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:231"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_76
#AT_START_77
at_fn_group_banner 77 'output.at:232' \
  "Output file name: [" "                            " 3
at_xfail=no
(
  $as_echo "77. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Skip if platform doesn't support file name.  For example, Cygwin
# doesn't support file names containing ":" or "\".
{ set +x
$as_echo "$at_srcdir/output.at:232: touch \"[.tmp\" || exit 77"
at_fn_check_prepare_trace "output.at:232"
( $at_check_trace; touch "[.tmp" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:232: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"[.c\" --defines=\"[.h\" glr.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:232"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "[.c" --defines="[.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:232: bison --xml=xml-tests/test.xml -o \"[.c\" --defines=\"[.h\" glr.y"
at_fn_check_prepare_trace "output.at:232"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "[.c" --defines="[.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:232: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:232"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:232: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:232"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:232: bison -o \"[.c\" --defines=\"[.h\" glr.y"
at_fn_check_prepare_trace "output.at:232"
( $at_check_trace; bison -o "[.c" --defines="[.h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:232: ls \"[.c\" \"[.h\""
at_fn_check_prepare_trace "output.at:232"
( $at_check_trace; ls "[.c" "[.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:232: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"[.c\""
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"[.c\"" "output.at:232"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o glr.o -c "[.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:232: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"[.c\" --defines=\"[.h\" cxx.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:232"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "[.c" --defines="[.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:232: bison --xml=xml-tests/test.xml -o \"[.c\" --defines=\"[.h\" cxx.y"
at_fn_check_prepare_trace "output.at:232"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "[.c" --defines="[.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:232: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:232"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:232: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:232"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:232: bison -o \"[.c\" --defines=\"[.h\" cxx.y"
at_fn_check_prepare_trace "output.at:232"
( $at_check_trace; bison -o "[.c" --defines="[.h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:232: ls \"[.c\" \"[.h\""
at_fn_check_prepare_trace "output.at:232"
( $at_check_trace; ls "[.c" "[.h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/output.at:232: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "output.at:232"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:232: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"[.c\""
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"[.c\"" "output.at:232"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "[.c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:232"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_77
#AT_START_78
at_fn_group_banner 78 'output.at:233' \
  "Output file name: ]" "                            " 3
at_xfail=no
(
  $as_echo "78. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Skip if platform doesn't support file name.  For example, Cygwin
# doesn't support file names containing ":" or "\".
{ set +x
$as_echo "$at_srcdir/output.at:233: touch \"].tmp\" || exit 77"
at_fn_check_prepare_trace "output.at:233"
( $at_check_trace; touch "].tmp" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:233: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"].c\" --defines=\"].h\" glr.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:233"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "].c" --defines="].h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:233: bison --xml=xml-tests/test.xml -o \"].c\" --defines=\"].h\" glr.y"
at_fn_check_prepare_trace "output.at:233"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "].c" --defines="].h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:233: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:233"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:233: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:233"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:233: bison -o \"].c\" --defines=\"].h\" glr.y"
at_fn_check_prepare_trace "output.at:233"
( $at_check_trace; bison -o "].c" --defines="].h" glr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:233: ls \"].c\" \"].h\""
at_fn_check_prepare_trace "output.at:233"
( $at_check_trace; ls "].c" "].h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:233: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"].c\""
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"].c\"" "output.at:233"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o glr.o -c "].c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/output.at:233: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"].c\" --defines=\"].h\" cxx.y"
at_fn_check_prepare_notrace 'an embedded newline' "output.at:233"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "].c" --defines="].h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/output.at:233: bison --xml=xml-tests/test.xml -o \"].c\" --defines=\"].h\" cxx.y"
at_fn_check_prepare_trace "output.at:233"
( $at_check_trace; bison --xml=xml-tests/test.xml -o "].c" --defines="].h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/output.at:233: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:233"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/output.at:233: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "output.at:233"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/output.at:233: bison -o \"].c\" --defines=\"].h\" cxx.y"
at_fn_check_prepare_trace "output.at:233"
( $at_check_trace; bison -o "].c" --defines="].h" cxx.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:233: ls \"].c\" \"].h\""
at_fn_check_prepare_trace "output.at:233"
( $at_check_trace; ls "].c" "].h"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/output.at:233: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "output.at:233"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/output.at:233: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"].c\""
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"].c\"" "output.at:233"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "].c"
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/output.at:233"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_78
#AT_START_79
at_fn_group_banner 79 'skeletons.at:24' \
  "Relative skeleton file names" "                   " 4
at_xfail=no
(
  $as_echo "79. $at_setup_line: testing $at_desc ..."
  $at_traceon


{ set +x
$as_echo "$at_srcdir/skeletons.at:26: mkdir tmp"
at_fn_check_prepare_trace "skeletons.at:26"
( $at_check_trace; mkdir tmp
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:26"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >tmp/skel.c <<'_ATEOF'
m4_divert_push(0)dnl
@output(b4_parser_file_name@)dnl
b4_percent_define_get([[test]])
m4_divert_pop(0)
_ATEOF


cat >skel.c <<'_ATEOF'
m4_divert_push(0)dnl
@output(b4_parser_file_name@)dnl
b4_percent_define_get([[test]]) -- Local
m4_divert_pop(0)
_ATEOF


cat >tmp/input-gram.y <<'_ATEOF'
%skeleton "./skel.c"
%define test "Hello World"
%%
start: ;
_ATEOF


cat >input-gram.y <<'_ATEOF'
%skeleton "./skel.c"
%define test "Hello World"
%%
start: ;
_ATEOF


cat >tmp/input-cmd-line.y <<'_ATEOF'
%define test "Hello World"
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/skeletons.at:62: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot tmp/input-gram.y"
at_fn_check_prepare_notrace 'an embedded newline' "skeletons.at:62"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot tmp/input-gram.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:62"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/skeletons.at:62: bison --xml=xml-tests/test.xml tmp/input-gram.y"
at_fn_check_prepare_trace "skeletons.at:62"
( $at_check_trace; bison --xml=xml-tests/test.xml tmp/input-gram.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:62"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:62: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:62"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:62"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:62: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:62"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:62"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/skeletons.at:62: bison tmp/input-gram.y"
at_fn_check_prepare_trace "skeletons.at:62"
( $at_check_trace; bison tmp/input-gram.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:62"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/skeletons.at:63: cat input-gram.tab.c"
at_fn_check_prepare_trace "skeletons.at:63"
( $at_check_trace; cat input-gram.tab.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Hello World
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:63"
$at_failed && at_fn_log_failure
$at_traceon; }


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/skeletons.at:67: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input-gram.y"
at_fn_check_prepare_notrace 'an embedded newline' "skeletons.at:67"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-gram.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:67"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/skeletons.at:67: bison --xml=xml-tests/test.xml input-gram.y"
at_fn_check_prepare_trace "skeletons.at:67"
( $at_check_trace; bison --xml=xml-tests/test.xml input-gram.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:67"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:67: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:67"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:67"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:67: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:67"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:67"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/skeletons.at:67: bison input-gram.y"
at_fn_check_prepare_trace "skeletons.at:67"
( $at_check_trace; bison input-gram.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:67"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/skeletons.at:68: cat input-gram.tab.c"
at_fn_check_prepare_trace "skeletons.at:68"
( $at_check_trace; cat input-gram.tab.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Hello World -- Local
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:68"
$at_failed && at_fn_log_failure
$at_traceon; }


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/skeletons.at:72: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --skeleton=tmp/skel.c tmp/input-cmd-line.y"
at_fn_check_prepare_notrace 'an embedded newline' "skeletons.at:72"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --skeleton=tmp/skel.c tmp/input-cmd-line.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/skeletons.at:72: bison --xml=xml-tests/test.xml --skeleton=tmp/skel.c tmp/input-cmd-line.y"
at_fn_check_prepare_trace "skeletons.at:72"
( $at_check_trace; bison --xml=xml-tests/test.xml --skeleton=tmp/skel.c tmp/input-cmd-line.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:72: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:72"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:72: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:72"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/skeletons.at:72: bison --skeleton=tmp/skel.c tmp/input-cmd-line.y"
at_fn_check_prepare_trace "skeletons.at:72"
( $at_check_trace; bison --skeleton=tmp/skel.c tmp/input-cmd-line.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/skeletons.at:73: cat input-cmd-line.tab.c"
at_fn_check_prepare_trace "skeletons.at:73"
( $at_check_trace; cat input-cmd-line.tab.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Hello World
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:73"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_79
#AT_START_80
at_fn_group_banner 80 'skeletons.at:84' \
  "Installed skeleton file names" "                  " 4
at_xfail=no
(
  $as_echo "80. $at_setup_line: testing $at_desc ..."
  $at_traceon




cat >input-cmd-line.y <<'_ATEOF'
%{
  #include <stdio.h>
  void yyerror (char const *msg);
  int yylex (void);
%}

%error-verbose
%token 'a'

%%

start: ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  return 'a';
}

int
main (void)
{
  return yyparse ();
}
_ATEOF


cat >input-gram.y <<'_ATEOF'
%skeleton "yacc.c"
%{
  #include <stdio.h>
  void yyerror (char const *msg);
  int yylex (void);
%}

%error-verbose
%token 'a'

%%

start: ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  return 'a';
}

int
main (void)
{
  return yyparse ();
}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/skeletons.at:128: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y"
at_fn_check_prepare_notrace 'an embedded newline' "skeletons.at:128"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:128"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/skeletons.at:128: bison --xml=xml-tests/test.xml --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y"
at_fn_check_prepare_trace "skeletons.at:128"
( $at_check_trace; bison --xml=xml-tests/test.xml --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:128"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:128: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:128"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:128"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:128: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:128"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:128"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/skeletons.at:128: bison --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y"
at_fn_check_prepare_trace "skeletons.at:128"
( $at_check_trace; bison --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:128"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/skeletons.at:129: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input-cmd-line input-cmd-line.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-cmd-line input-cmd-line.c $LIBS" "skeletons.at:129"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-cmd-line input-cmd-line.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:129"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/skeletons.at:130:  \$PREPARSER ./input-cmd-line"
at_fn_check_prepare_dynamic " $PREPARSER ./input-cmd-line" "skeletons.at:130"
( $at_check_trace;  $PREPARSER ./input-cmd-line
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected 'a', expecting \$end
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/skeletons.at:134: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input-gram.c input-gram.y"
at_fn_check_prepare_notrace 'an embedded newline' "skeletons.at:134"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input-gram.c input-gram.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:134"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/skeletons.at:134: bison --xml=xml-tests/test.xml -o input-gram.c input-gram.y"
at_fn_check_prepare_trace "skeletons.at:134"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input-gram.c input-gram.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:134"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:134: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:134"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:134"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/skeletons.at:134: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "skeletons.at:134"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:134"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/skeletons.at:134: bison -o input-gram.c input-gram.y"
at_fn_check_prepare_trace "skeletons.at:134"
( $at_check_trace; bison -o input-gram.c input-gram.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:134"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/skeletons.at:135: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input-gram input-gram.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-gram input-gram.c $LIBS" "skeletons.at:135"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-gram input-gram.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:135"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/skeletons.at:136:  \$PREPARSER ./input-gram"
at_fn_check_prepare_dynamic " $PREPARSER ./input-gram" "skeletons.at:136"
( $at_check_trace;  $PREPARSER ./input-gram
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected 'a', expecting \$end
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:136"
$at_failed && at_fn_log_failure
$at_traceon; }




  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_80
#AT_START_81
at_fn_group_banner 81 'skeletons.at:149' \
  "%define Boolean variables: invalid skeleton defaults" "" 4
at_xfail=no
(
  $as_echo "81. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >skel.c <<'_ATEOF'
b4_percent_define_default([[foo]], [[bogus value]])
b4_percent_define_flag_if([[foo]])
_ATEOF


cat >input.y <<'_ATEOF'
%skeleton "./skel.c"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/skeletons.at:162: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "skeletons.at:162"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "<skeleton default value>: invalid value for %define Boolean variable \`foo'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:162"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_81
#AT_START_82
at_fn_group_banner 82 'skeletons.at:173' \
  "Complaining during macro argument expansion" "    " 4
at_xfail=no
(
  $as_echo "82. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >skel1.c <<'_ATEOF'
m4_define([foow], [b4_warn([[foow fubar]])])
m4_define([foowat], [b4_warn_at([[foow.y:2.3]],
                                    [[foow.y:5.4]], [[foowat fubar]])])
m4_define([fooc], [b4_complain([[fooc fubar]])])
m4_define([foocat], [b4_complain_at([[fooc.y:1.1]],
                                        [[fooc.y:10.6]], [[foocat fubar]])])
m4_define([foof], [b4_fatal([[foof fubar]])])
m4_if(foow, [1], [yes])
m4_if(foowat, [1], [yes])
m4_if(fooc, [1], [yes])
m4_if(foocat, [1], [yes])
m4_if(foof, [1], [yes])
_ATEOF


cat >input1.y <<'_ATEOF'
%skeleton "./skel1.c"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/skeletons.at:196: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input1.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input1.y" "skeletons.at:196"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input1.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input1.y: warning: foow fubar
foow.y:2.3-5.3: warning: foowat fubar
input1.y: fooc fubar
fooc.y:1.1-10.5: foocat fubar
input1.y: fatal error: foof fubar
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:196"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >skel2.c <<'_ATEOF'
m4_define([foofat], [b4_fatal_at([[foof.y:12.11]],
                                       [[foof.y:100.123]], [[foofat fubar]])])
m4_if(foofat, [1], [yes])
_ATEOF


cat >input2.y <<'_ATEOF'
%skeleton "./skel2.c"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/skeletons.at:216: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input2.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input2.y" "skeletons.at:216"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "foof.y:12.11-100.122: fatal error: foofat fubar
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:216"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >skel3.c <<'_ATEOF'
b4_complain_at(b4_percent_define_get_loc([[bogus]]), [[bad value]])
_ATEOF


cat >input3.y <<'_ATEOF'
%skeleton "./skel3.c"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/skeletons.at:230: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input3.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input3.y" "skeletons.at:230"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input3.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input3.y: fatal error: undefined %define variable \`bogus' passed to b4_percent_define_get_loc
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:230"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >skel4.c <<'_ATEOF'
b4_warn_at(b4_percent_define_get_syncline([[bogus]]), [[bad value]])
_ATEOF


cat >input4.y <<'_ATEOF'
%skeleton "./skel4.c"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/skeletons.at:244: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input4.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input4.y" "skeletons.at:244"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input4.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input4.y: fatal error: undefined %define variable \`bogus' passed to b4_percent_define_get_syncline
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:244"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_82
#AT_START_83
at_fn_group_banner 83 'skeletons.at:255' \
  "Fatal errors make M4 exit immediately" "          " 4
at_xfail=no
(
  $as_echo "83. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >skel1.c <<'_ATEOF'
b4_complain([[non-fatal error]])
b4_fatal([[M4 should exit immediately here]])
m4_fatal([this should never be evaluated])
_ATEOF


cat >input1.y <<'_ATEOF'
%skeleton "./skel1.c"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/skeletons.at:269: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input1.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input1.y" "skeletons.at:269"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input1.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input1.y: non-fatal error
input1.y: fatal error: M4 should exit immediately here
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:269"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >skel2.c <<'_ATEOF'
b4_warn([[morning]])
b4_fatal_at([[foo.y:1.5]], [[foo.y:1.7]], [[M4 should exit immediately here]])
m4_fatal([this should never be evaluated])
_ATEOF


cat >input2.y <<'_ATEOF'
%skeleton "./skel2.c"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/skeletons.at:286: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input2.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input2.y" "skeletons.at:286"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input2.y: warning: morning
foo.y:1.5-6: fatal error: M4 should exit immediately here
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:286"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_83
#AT_START_84
at_fn_group_banner 84 'skeletons.at:309' \
  "Fatal errors but M4 continues producing output" " " 4
at_xfail=no
(
  $as_echo "84. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >gen-skel.pl <<'_ATEOF'
use warnings;
use strict;
my $M4 = "m4";
my $DNL = "d"."nl";
print "${M4}_divert_push(0)$DNL\n";
print '@output(@,@)', "\n";
(print "garbage"x10, "\n") for (1..1000);
print "${M4}_divert_pop(0)\n";
_ATEOF

{ set +x
$as_echo "$at_srcdir/skeletons.at:321: perl gen-skel.pl > skel.c || exit 77"
at_fn_check_prepare_trace "skeletons.at:321"
( $at_check_trace; perl gen-skel.pl > skel.c || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/skeletons.at:321"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%skeleton "./skel.c"
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/skeletons.at:329: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "skeletons.at:329"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: fatal error: too many arguments for @output directive in skeleton
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/skeletons.at:329"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_84
#AT_START_85
at_fn_group_banner 85 'sets.at:66' \
  "Nullable" "                                       " 5
at_xfail=no
(
  $as_echo "85. $at_setup_line: testing $at_desc ..."
  $at_traceon


# At some point, nullable had been smoking grass, and managed to say:
#
# Entering set_nullable
# NULLABLE
#         'e': yes
#         (null): no
# ...

cat >input.y <<'_ATEOF'
%%
e: 'e' | /* Nothing */;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/sets.at:81: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --trace=sets input.y"
at_fn_check_prepare_notrace 'an embedded newline' "sets.at:81"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --trace=sets input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/sets.at:81: bison --xml=xml-tests/test.xml --trace=sets input.y"
at_fn_check_prepare_trace "sets.at:81"
( $at_check_trace; bison --xml=xml-tests/test.xml --trace=sets input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/sets.at:81: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "sets.at:81"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/sets.at:81: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "sets.at:81"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/sets.at:81: bison --trace=sets input.y"
at_fn_check_prepare_trace "sets.at:81"
( $at_check_trace; bison --trace=sets input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

cat >extract.sed <<'_ATEOF'
#n
/^NULLABLE$/ {
   :null
   p
   n
   /^[	 ]*$/ !b null
}
/^FIRSTS$/ {
   :firsts
   p
   n
   /^[	 ]*$/ !b firsts
}
/^FDERIVES$/ {
   :fderiv
   p
   n
   /^[	 ]*$/ !b fderiv
}
/^DERIVES$/ {
   :deriv
   p
   n
   /^[	 ]*$/ !b deriv
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/sets.at:82: sed -f extract.sed stderr"
at_fn_check_prepare_trace "sets.at:82"
( $at_check_trace; sed -f extract.sed stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:82"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/sets.at:82: mv stdout sets"
at_fn_check_prepare_trace "sets.at:82"
( $at_check_trace; mv stdout sets
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:82"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/sets.at:83: cat sets"
at_fn_check_prepare_trace "sets.at:83"
( $at_check_trace; cat sets
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "DERIVES
	\$accept derives
		  0  e \$end
	e derives
		  1  'e'
		  2  /* empty */
NULLABLE
	\$accept: no
	e: yes
FIRSTS
	\$accept firsts
		\$accept
		e
	e firsts
		e
FDERIVES
	\$accept derives
		  0  e \$end
		  1  'e'
		  2  /* empty */
	e derives
		  1  'e'
		  2  /* empty */
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:83"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_85
#AT_START_86
at_fn_group_banner 86 'sets.at:151' \
  "Broken Closure" "                                 " 5
at_xfail=no
(
  $as_echo "86. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%%
a: b;
b: c;
c: d;
d: e;
e: f;
f: g;
g: h;
h: 'h';
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/sets.at:165: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --trace=sets input.y"
at_fn_check_prepare_notrace 'an embedded newline' "sets.at:165"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --trace=sets input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:165"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/sets.at:165: bison --xml=xml-tests/test.xml --trace=sets input.y"
at_fn_check_prepare_trace "sets.at:165"
( $at_check_trace; bison --xml=xml-tests/test.xml --trace=sets input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:165"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/sets.at:165: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "sets.at:165"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:165"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/sets.at:165: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "sets.at:165"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:165"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/sets.at:165: bison --trace=sets input.y"
at_fn_check_prepare_trace "sets.at:165"
( $at_check_trace; bison --trace=sets input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:165"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/sets.at:167: sed -n 's/[	 ]*\$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr"
at_fn_check_prepare_dynamic "sed -n 's/[	 ]*$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr" "sets.at:167"
( $at_check_trace; sed -n 's/[	 ]*$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "RTC: Firsts Output BEGIN

   012345678
  .---------.
 0|111111111|
 1| 11111111|
 2|  1111111|
 3|   111111|
 4|    11111|
 5|     1111|
 6|      111|
 7|       11|
 8|        1|
  \`---------'
RTC: Firsts Output END
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:167"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_86
#AT_START_87
at_fn_group_banner 87 'sets.at:193' \
  "Firsts" "                                         " 5
at_xfail=no
(
  $as_echo "87. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%nonassoc '<' '>'
%left '+' '-'
%right '^' '='
%%
exp:
   exp '<' exp
 | exp '>' exp
 | exp '+' exp
 | exp '-' exp
 | exp '^' exp
 | exp '=' exp
 | "exp"
 ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/sets.at:211: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --trace=sets input.y"
at_fn_check_prepare_notrace 'an embedded newline' "sets.at:211"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --trace=sets input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:211"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/sets.at:211: bison --xml=xml-tests/test.xml --trace=sets input.y"
at_fn_check_prepare_trace "sets.at:211"
( $at_check_trace; bison --xml=xml-tests/test.xml --trace=sets input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:211"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/sets.at:211: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "sets.at:211"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:211"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/sets.at:211: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "sets.at:211"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:211"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/sets.at:211: bison --trace=sets input.y"
at_fn_check_prepare_trace "sets.at:211"
( $at_check_trace; bison --trace=sets input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:211"
$at_failed && at_fn_log_failure
$at_traceon; }

cat >extract.sed <<'_ATEOF'
#n
/^NULLABLE$/ {
   :null
   p
   n
   /^[	 ]*$/ !b null
}
/^FIRSTS$/ {
   :firsts
   p
   n
   /^[	 ]*$/ !b firsts
}
/^FDERIVES$/ {
   :fderiv
   p
   n
   /^[	 ]*$/ !b fderiv
}
/^DERIVES$/ {
   :deriv
   p
   n
   /^[	 ]*$/ !b deriv
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/sets.at:212: sed -f extract.sed stderr"
at_fn_check_prepare_trace "sets.at:212"
( $at_check_trace; sed -f extract.sed stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:212"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/sets.at:212: mv stdout sets"
at_fn_check_prepare_trace "sets.at:212"
( $at_check_trace; mv stdout sets
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:212"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/sets.at:213: cat sets"
at_fn_check_prepare_trace "sets.at:213"
( $at_check_trace; cat sets
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "DERIVES
	\$accept derives
		  0  exp \$end
	exp derives
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
NULLABLE
	\$accept: no
	exp: no
FIRSTS
	\$accept firsts
		\$accept
		exp
	exp firsts
		exp
FDERIVES
	\$accept derives
		  0  exp \$end
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
	exp derives
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:213"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_87
#AT_START_88
at_fn_group_banner 88 'sets.at:269' \
  "Accept" "                                         " 5
at_xfail=no
(
  $as_echo "88. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token END 0
%%
input:
  'a'
| '(' input ')'
| '(' error END
;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/sets.at:281: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "sets.at:281"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:281"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/sets.at:281: bison --xml=xml-tests/test.xml -v -o input.c input.y"
at_fn_check_prepare_trace "sets.at:281"
( $at_check_trace; bison --xml=xml-tests/test.xml -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:281"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/sets.at:281: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "sets.at:281"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:281"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/sets.at:281: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "sets.at:281"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:281"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/sets.at:281: bison -v -o input.c input.y"
at_fn_check_prepare_trace "sets.at:281"
( $at_check_trace; bison -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:281"
$at_failed && at_fn_log_failure
$at_traceon; }


# Get the final state in the parser.
{ set +x
$as_echo "$at_srcdir/sets.at:284: sed -n 's/.*define YYFINAL *\\([0-9][0-9]*\\)/final state \\1/p' input.c"
at_fn_check_prepare_trace "sets.at:284"
( $at_check_trace; sed -n 's/.*define YYFINAL *\([0-9][0-9]*\)/final state \1/p' input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:284"
$at_failed && at_fn_log_failure
$at_traceon; }

mv stdout expout

# Get the final state in the report, from the "accept" action..
{ set +x
$as_echo "$at_srcdir/sets.at:289: sed -n '
           /^state \\(.*\\)/{
	     s//final state \\1/
	     x
	   }
	   / accept/{
	     x
	     p
	     q
	   }
	' input.output"
at_fn_check_prepare_notrace 'an embedded newline' "sets.at:289"
( $at_check_trace; sed -n '
           /^state \(.*\)/{
	     s//final state \1/
	     x
	   }
	   / accept/{
	     x
	     p
	     q
	   }
	' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/sets.at:289"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_88
#AT_START_89
at_fn_group_banner 89 'reduce.at:26' \
  "Useless Terminals" "                              " 6
at_xfail=no
(
  $as_echo "89. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output "input.c"

%token useless1
%token useless2
%token useless3
%token useless4
%token useless5
%token useless6
%token useless7
%token useless8
%token useless9

%token useful
%%
exp: useful;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:47: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:47"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:47"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:47: bison --xml=xml-tests/test.xml input.y"
at_fn_check_prepare_trace "reduce.at:47"
( $at_check_trace; bison --xml=xml-tests/test.xml input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:47"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:47: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:47"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:47"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:47: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:47"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:47"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:47: bison input.y"
at_fn_check_prepare_trace "reduce.at:47"
( $at_check_trace; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:47"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:49: sed -n '/^Grammar/q;/^\$/!p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^Grammar/q;/^$/!p' input.output" "reduce.at:49"
( $at_check_trace; sed -n '/^Grammar/q;/^$/!p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Terminals unused in grammar
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:49"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_89
#AT_START_90
at_fn_group_banner 90 'reduce.at:70' \
  "Useless Nonterminals" "                           " 6
at_xfail=no
(
  $as_echo "90. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output "input.c"

%nterm useless1
%nterm useless2
%nterm useless3
%nterm useless4
%nterm useless5
%nterm useless6
%nterm useless7
%nterm useless8
%nterm useless9

%token useful
%%
exp: useful;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:91: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:91"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:91: bison --xml=xml-tests/test.xml input.y"
at_fn_check_prepare_trace "reduce.at:91"
( $at_check_trace; bison --xml=xml-tests/test.xml input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:91: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:91"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:91: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:91"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:91: bison input.y"
at_fn_check_prepare_trace "reduce.at:91"
( $at_check_trace; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: warning: 9 nonterminals useless in grammar
input.y:4.8-15: warning: nonterminal useless in grammar: useless1
input.y:5.8-15: warning: nonterminal useless in grammar: useless2
input.y:6.8-15: warning: nonterminal useless in grammar: useless3
input.y:7.8-15: warning: nonterminal useless in grammar: useless4
input.y:8.8-15: warning: nonterminal useless in grammar: useless5
input.y:9.8-15: warning: nonterminal useless in grammar: useless6
input.y:10.8-15: warning: nonterminal useless in grammar: useless7
input.y:11.8-15: warning: nonterminal useless in grammar: useless8
input.y:12.8-15: warning: nonterminal useless in grammar: useless9
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:91"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:104: sed -n '/^Grammar/q;/^\$/!p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^Grammar/q;/^$/!p' input.output" "reduce.at:104"
( $at_check_trace; sed -n '/^Grammar/q;/^$/!p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Nonterminals useless in grammar
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:104"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_90
#AT_START_91
at_fn_group_banner 91 'reduce.at:125' \
  "Useless Rules" "                                  " 6
at_xfail=no
(
  $as_echo "91. $at_setup_line: testing $at_desc ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%verbose
%output "input.c"
%token useful
%%
exp: useful;
useless1: '1';
useless2: '2';
useless3: '3';
useless4: '4';
useless5: '5';
useless6: '6';
useless7: '7';
useless8: '8';
useless9: '9';
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:146: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:146"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:146: bison --xml=xml-tests/test.xml input.y"
at_fn_check_prepare_trace "reduce.at:146"
( $at_check_trace; bison --xml=xml-tests/test.xml input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:146: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:146"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:146: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:146"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:146: bison input.y"
at_fn_check_prepare_trace "reduce.at:146"
( $at_check_trace; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: warning: 9 nonterminals useless in grammar
input.y: warning: 9 rules useless in grammar
input.y:6.1-8: warning: nonterminal useless in grammar: useless1
input.y:7.1-8: warning: nonterminal useless in grammar: useless2
input.y:8.1-8: warning: nonterminal useless in grammar: useless3
input.y:9.1-8: warning: nonterminal useless in grammar: useless4
input.y:10.1-8: warning: nonterminal useless in grammar: useless5
input.y:11.1-8: warning: nonterminal useless in grammar: useless6
input.y:12.1-8: warning: nonterminal useless in grammar: useless7
input.y:13.1-8: warning: nonterminal useless in grammar: useless8
input.y:14.1-8: warning: nonterminal useless in grammar: useless9
input.y:6.11-13: warning: rule useless in grammar: useless1: '1'
input.y:7.11-13: warning: rule useless in grammar: useless2: '2'
input.y:8.11-13: warning: rule useless in grammar: useless3: '3'
input.y:9.11-13: warning: rule useless in grammar: useless4: '4'
input.y:10.11-13: warning: rule useless in grammar: useless5: '5'
input.y:11.11-13: warning: rule useless in grammar: useless6: '6'
input.y:12.11-13: warning: rule useless in grammar: useless7: '7'
input.y:13.11-13: warning: rule useless in grammar: useless8: '8'
input.y:14.11-13: warning: rule useless in grammar: useless9: '9'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:169: sed -n '/^Grammar/q;/^\$/!p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^Grammar/q;/^$/!p' input.output" "reduce.at:169"
( $at_check_trace; sed -n '/^Grammar/q;/^$/!p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Nonterminals useless in grammar
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
Terminals unused in grammar
   '1'
   '2'
   '3'
   '4'
   '5'
   '6'
   '7'
   '8'
   '9'
Rules useless in grammar
    2 useless1: '1'
    3 useless2: '2'
    4 useless3: '3'
    5 useless4: '4'
    6 useless5: '5'
    7 useless6: '6'
    8 useless7: '7'
    9 useless8: '8'
   10 useless9: '9'
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_91
#AT_START_92
at_fn_group_banner 92 'reduce.at:213' \
  "Reduced Automaton" "                              " 6
at_xfail=no
(
  $as_echo "92. $at_setup_line: testing $at_desc ..."
  $at_traceon




# The non reduced grammar.
# ------------------------
cat >not-reduced.y <<'_ATEOF'
/* A useless token. */
%token useless_token
/* A useful one. */
%token useful
%verbose
%output "not-reduced.c"

%%

exp: useful            { /* A useful action. */ }
   | non_productive    { /* A non productive action. */ }
   ;

not_reachable: useful  { /* A not reachable action. */ }
             ;

non_productive: non_productive useless_token
                       { /* Another non productive action. */ }
              ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:242: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot not-reduced.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:242"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot not-reduced.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:242"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:242: bison --xml=xml-tests/test.xml not-reduced.y"
at_fn_check_prepare_trace "reduce.at:242"
( $at_check_trace; bison --xml=xml-tests/test.xml not-reduced.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:242"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:242: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:242"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:242"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:242: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:242"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:242"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:242: bison not-reduced.y"
at_fn_check_prepare_trace "reduce.at:242"
( $at_check_trace; bison not-reduced.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "not-reduced.y: warning: 2 nonterminals useless in grammar
not-reduced.y: warning: 3 rules useless in grammar
not-reduced.y:14.1-13: warning: nonterminal useless in grammar: not_reachable
not-reduced.y:11.6-19: warning: nonterminal useless in grammar: non_productive
not-reduced.y:11.6-57: warning: rule useless in grammar: exp: non_productive
not-reduced.y:14.16-56: warning: rule useless in grammar: not_reachable: useful
not-reduced.y:17.17-18.63: warning: rule useless in grammar: non_productive: non_productive useless_token
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:242"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:252: sed -n '/^Grammar/q;/^\$/!p' not-reduced.output"
at_fn_check_prepare_dynamic "sed -n '/^Grammar/q;/^$/!p' not-reduced.output" "reduce.at:252"
( $at_check_trace; sed -n '/^Grammar/q;/^$/!p' not-reduced.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Nonterminals useless in grammar
   not_reachable
   non_productive
Terminals unused in grammar
   useless_token
Rules useless in grammar
    2 exp: non_productive
    3 not_reachable: useful
    4 non_productive: non_productive useless_token
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:252"
$at_failed && at_fn_log_failure
$at_traceon; }


# The reduced grammar.
# --------------------
cat >reduced.y <<'_ATEOF'
/* A useless token. */
%token useless_token
/* A useful one. */
%token useful
%verbose
%output "reduced.c"

%%

exp: useful            { /* A useful action. */ }
//   | non_productive    { /* A non productive action. */ } */
   ;

//not_reachable: useful  { /* A not reachable action. */ }
//             ;

//non_productive: non_productive useless_token
//                       { /* Another non productive action. */ }
//              ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:289: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot reduced.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:289"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot reduced.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:289"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:289: bison --xml=xml-tests/test.xml reduced.y"
at_fn_check_prepare_trace "reduce.at:289"
( $at_check_trace; bison --xml=xml-tests/test.xml reduced.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:289"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:289: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:289"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:289"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:289: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:289"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:289"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:289: bison reduced.y"
at_fn_check_prepare_trace "reduce.at:289"
( $at_check_trace; bison reduced.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:289"
$at_failed && at_fn_log_failure
$at_traceon; }


# Comparing the parsers.
cp reduced.c expout
{ set +x
$as_echo "$at_srcdir/reduce.at:293: sed 's/not-reduced/reduced/g' not-reduced.c"
at_fn_check_prepare_trace "reduce.at:293"
( $at_check_trace; sed 's/not-reduced/reduced/g' not-reduced.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:293"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_92
#AT_START_93
at_fn_group_banner 93 'reduce.at:303' \
  "Underivable Rules" "                              " 6
at_xfail=no
(
  $as_echo "93. $at_setup_line: testing $at_desc ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%verbose
%output "input.c"
%token useful
%%
exp: useful | underivable;
underivable: indirection;
indirection: underivable;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:317: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:317"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:317"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:317: bison --xml=xml-tests/test.xml input.y"
at_fn_check_prepare_trace "reduce.at:317"
( $at_check_trace; bison --xml=xml-tests/test.xml input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:317"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:317: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:317"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:317"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:317: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:317"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:317"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:317: bison input.y"
at_fn_check_prepare_trace "reduce.at:317"
( $at_check_trace; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: warning: 2 nonterminals useless in grammar
input.y: warning: 3 rules useless in grammar
input.y:5.15-25: warning: nonterminal useless in grammar: underivable
input.y:6.14-24: warning: nonterminal useless in grammar: indirection
input.y:5.15-25: warning: rule useless in grammar: exp: underivable
input.y:6.14-24: warning: rule useless in grammar: underivable: indirection
input.y:7.14-24: warning: rule useless in grammar: indirection: underivable
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:317"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:327: sed -n '/^Grammar/q;/^\$/!p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^Grammar/q;/^$/!p' input.output" "reduce.at:327"
( $at_check_trace; sed -n '/^Grammar/q;/^$/!p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Nonterminals useless in grammar
   underivable
   indirection
Rules useless in grammar
    2 exp: underivable
    3 underivable: indirection
    4 indirection: underivable
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:327"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_93
#AT_START_94
at_fn_group_banner 94 'reduce.at:345' \
  "Empty Language" "                                 " 6
at_xfail=no
(
  $as_echo "94. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%output "input.c"
%%
exp: exp;
_ATEOF



{ set +x
$as_echo "$at_srcdir/reduce.at:353: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "reduce.at:353"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: warning: 2 nonterminals useless in grammar
input.y: warning: 2 rules useless in grammar
input.y:3.1-3: fatal error: start symbol exp does not derive any sentence
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/reduce.at:353"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_94
#AT_START_95
at_fn_group_banner 95 'reduce.at:396' \
  "no %define lr.type: Single State Split" "         " 6
at_xfail=no
(
  $as_echo "95. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%left 'a'
// Conflict resolution renders state 12 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


S: 'a' A 'a' /* rule 1 */
 | 'b' A 'b' /* rule 2 */
 | 'c' c     /* rule 3 */
 ;

/* A conflict should appear after the first 'a' in rules 4 and 5 but only after
   having shifted the first 'a' in rule 1.  However, when LALR(1) merging is
   chosen, the state containing that conflict is reused after having seen the
   first 'b' in rule 2 and then the first 'a' in rules 4 and 5.  In both cases,
   because of the merged state, if the next token is an 'a', the %left forces a
   reduction action with rule 5.  In the latter case, only a shift is actually
   grammatically correct.  Thus, the parser would report a syntax error for the
   grammatically correct sentence "baab" because it would encounter a syntax
   error after that incorrect reduction.

   Despite not being LALR(1), Menhir version 20070322 suffers from this problem
   as well.  It uses David Pager's weak compatibility test for merging states.
   Bison and Menhir accept non-LR(1) grammars with conflict resolution.  Pager
   designed his algorithm only for LR(1) grammars.  */
A: 'a' 'a' /* rule 4 */
 | 'a'     /* rule 5 */
 ;

/* Rule 3, rule 6, and rule 7 ensure that Bison does not report rule 4 as
   useless after conflict resolution.  This proves that, even though LALR(1)
   generates incorrect parser tables sometimes, Bison will not necessarily
   produce any warning to help the user realize it.  */
c: 'a' 'b' /* rule 6 */
 | A       /* rule 7 */
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:396: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:396"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:396: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:396"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:396: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:396"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:396: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:396"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:396: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:396"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:396: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:396"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a'
    5  | . 'a'

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a'
    5  | . 'a'

    'a'  shift, and go to state 5

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a'
    5  | . 'a'
    6 c: . 'a' 'b'
    7  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a'
    5  | 'a' .  ['a', 'b']

    \$default  reduce using rule 5 (A)

    Conflict between rule 5 and token 'a' resolved as reduce (%left 'a').


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a'
    5  | 'a' .  [\$end]
    6 c: 'a' . 'b'

    'a'  shift, and go to state 12
    'b'  shift, and go to state 15

    \$default  reduce using rule 5 (A)


state 9

    7 c: A .

    \$default  reduce using rule 7 (c)


state 10

    3 S: 'c' c .

    \$default  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' .

    \$default  reduce using rule 4 (A)


state 13

    1 S: 'a' A 'a' .

    \$default  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .

    \$default  reduce using rule 2 (S)


state 15

    6 c: 'a' 'b' .

    \$default  reduce using rule 6 (c)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:396: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:396"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:396:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:396"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_95
#AT_START_96
at_fn_group_banner 96 'reduce.at:396' \
  "%define lr.type lalr: Single State Split" "       " 6
at_xfail=no
(
  $as_echo "96. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type lalr
%left 'a'
// Conflict resolution renders state 12 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


S: 'a' A 'a' /* rule 1 */
 | 'b' A 'b' /* rule 2 */
 | 'c' c     /* rule 3 */
 ;

/* A conflict should appear after the first 'a' in rules 4 and 5 but only after
   having shifted the first 'a' in rule 1.  However, when LALR(1) merging is
   chosen, the state containing that conflict is reused after having seen the
   first 'b' in rule 2 and then the first 'a' in rules 4 and 5.  In both cases,
   because of the merged state, if the next token is an 'a', the %left forces a
   reduction action with rule 5.  In the latter case, only a shift is actually
   grammatically correct.  Thus, the parser would report a syntax error for the
   grammatically correct sentence "baab" because it would encounter a syntax
   error after that incorrect reduction.

   Despite not being LALR(1), Menhir version 20070322 suffers from this problem
   as well.  It uses David Pager's weak compatibility test for merging states.
   Bison and Menhir accept non-LR(1) grammars with conflict resolution.  Pager
   designed his algorithm only for LR(1) grammars.  */
A: 'a' 'a' /* rule 4 */
 | 'a'     /* rule 5 */
 ;

/* Rule 3, rule 6, and rule 7 ensure that Bison does not report rule 4 as
   useless after conflict resolution.  This proves that, even though LALR(1)
   generates incorrect parser tables sometimes, Bison will not necessarily
   produce any warning to help the user realize it.  */
c: 'a' 'b' /* rule 6 */
 | A       /* rule 7 */
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:396: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:396"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:396: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:396"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:396: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:396"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:396: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:396"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:396: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:396"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:396: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:396"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a'
    5  | . 'a'

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a'
    5  | . 'a'

    'a'  shift, and go to state 5

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a'
    5  | . 'a'
    6 c: . 'a' 'b'
    7  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a'
    5  | 'a' .  ['a', 'b']

    \$default  reduce using rule 5 (A)

    Conflict between rule 5 and token 'a' resolved as reduce (%left 'a').


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a'
    5  | 'a' .  [\$end]
    6 c: 'a' . 'b'

    'a'  shift, and go to state 12
    'b'  shift, and go to state 15

    \$default  reduce using rule 5 (A)


state 9

    7 c: A .

    \$default  reduce using rule 7 (c)


state 10

    3 S: 'c' c .

    \$default  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' .

    \$default  reduce using rule 4 (A)


state 13

    1 S: 'a' A 'a' .

    \$default  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .

    \$default  reduce using rule 2 (S)


state 15

    6 c: 'a' 'b' .

    \$default  reduce using rule 6 (c)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:396: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:396"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:396:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:396"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_96
#AT_START_97
at_fn_group_banner 97 'reduce.at:396' \
  "%define lr.type ielr: Single State Split" "       " 6
at_xfail=no
(
  $as_echo "97. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type ielr
%left 'a'
// Conflict resolution renders state 12 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


S: 'a' A 'a' /* rule 1 */
 | 'b' A 'b' /* rule 2 */
 | 'c' c     /* rule 3 */
 ;

/* A conflict should appear after the first 'a' in rules 4 and 5 but only after
   having shifted the first 'a' in rule 1.  However, when LALR(1) merging is
   chosen, the state containing that conflict is reused after having seen the
   first 'b' in rule 2 and then the first 'a' in rules 4 and 5.  In both cases,
   because of the merged state, if the next token is an 'a', the %left forces a
   reduction action with rule 5.  In the latter case, only a shift is actually
   grammatically correct.  Thus, the parser would report a syntax error for the
   grammatically correct sentence "baab" because it would encounter a syntax
   error after that incorrect reduction.

   Despite not being LALR(1), Menhir version 20070322 suffers from this problem
   as well.  It uses David Pager's weak compatibility test for merging states.
   Bison and Menhir accept non-LR(1) grammars with conflict resolution.  Pager
   designed his algorithm only for LR(1) grammars.  */
A: 'a' 'a' /* rule 4 */
 | 'a'     /* rule 5 */
 ;

/* Rule 3, rule 6, and rule 7 ensure that Bison does not report rule 4 as
   useless after conflict resolution.  This proves that, even though LALR(1)
   generates incorrect parser tables sometimes, Bison will not necessarily
   produce any warning to help the user realize it.  */
c: 'a' 'b' /* rule 6 */
 | A       /* rule 7 */
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:396: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:396"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:396: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:396"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:396: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:396"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:396: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:396"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:396: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:396"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:396: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:396"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a'
    5  | . 'a'

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a'
    5  | . 'a'

    'a'  shift, and go to state 16

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a'
    5  | . 'a'
    6 c: . 'a' 'b'
    7  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a'
    5  | 'a' .  ['a']

    \$default  reduce using rule 5 (A)

    Conflict between rule 5 and token 'a' resolved as reduce (%left 'a').


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a'
    5  | 'a' .  [\$end]
    6 c: 'a' . 'b'

    'a'  shift, and go to state 12
    'b'  shift, and go to state 15

    \$default  reduce using rule 5 (A)


state 9

    7 c: A .

    \$default  reduce using rule 7 (c)


state 10

    3 S: 'c' c .

    \$default  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' .

    \$default  reduce using rule 4 (A)


state 13

    1 S: 'a' A 'a' .

    \$default  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .

    \$default  reduce using rule 2 (S)


state 15

    6 c: 'a' 'b' .

    \$default  reduce using rule 6 (c)


state 16

    4 A: 'a' . 'a'
    5  | 'a' .  ['b']

    'a'  shift, and go to state 12

    \$default  reduce using rule 5 (A)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:396: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:396"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:396:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:396"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_97
#AT_START_98
at_fn_group_banner 98 'reduce.at:396' \
  "%define lr.type canonical-lr: Single State Split" "" 6
at_xfail=no
(
  $as_echo "98. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type canonical-lr
%left 'a'
// Conflict resolution renders state 12 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


S: 'a' A 'a' /* rule 1 */
 | 'b' A 'b' /* rule 2 */
 | 'c' c     /* rule 3 */
 ;

/* A conflict should appear after the first 'a' in rules 4 and 5 but only after
   having shifted the first 'a' in rule 1.  However, when LALR(1) merging is
   chosen, the state containing that conflict is reused after having seen the
   first 'b' in rule 2 and then the first 'a' in rules 4 and 5.  In both cases,
   because of the merged state, if the next token is an 'a', the %left forces a
   reduction action with rule 5.  In the latter case, only a shift is actually
   grammatically correct.  Thus, the parser would report a syntax error for the
   grammatically correct sentence "baab" because it would encounter a syntax
   error after that incorrect reduction.

   Despite not being LALR(1), Menhir version 20070322 suffers from this problem
   as well.  It uses David Pager's weak compatibility test for merging states.
   Bison and Menhir accept non-LR(1) grammars with conflict resolution.  Pager
   designed his algorithm only for LR(1) grammars.  */
A: 'a' 'a' /* rule 4 */
 | 'a'     /* rule 5 */
 ;

/* Rule 3, rule 6, and rule 7 ensure that Bison does not report rule 4 as
   useless after conflict resolution.  This proves that, even though LALR(1)
   generates incorrect parser tables sometimes, Bison will not necessarily
   produce any warning to help the user realize it.  */
c: 'a' 'b' /* rule 6 */
 | A       /* rule 7 */
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:396: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:396"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:396: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:396"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:396: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:396"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:396: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:396"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:396: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:396"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:396: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:396"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a'
    5  | . 'a'

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a'
    5  | . 'a'

    'a'  shift, and go to state 16

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a'
    5  | . 'a'
    6 c: . 'a' 'b'
    7  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a'
    5  | 'a' .  ['a']

    'a'  reduce using rule 5 (A)

    Conflict between rule 5 and token 'a' resolved as reduce (%left 'a').


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a'
    5  | 'a' .  [\$end]
    6 c: 'a' . 'b'

    'a'  shift, and go to state 17
    'b'  shift, and go to state 15

    \$end  reduce using rule 5 (A)


state 9

    7 c: A .  [\$end]

    \$end  reduce using rule 7 (c)


state 10

    3 S: 'c' c .  [\$end]

    \$end  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' .  ['a']

    'a'  reduce using rule 4 (A)


state 13

    1 S: 'a' A 'a' .  [\$end]

    \$end  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .  [\$end]

    \$end  reduce using rule 2 (S)


state 15

    6 c: 'a' 'b' .  [\$end]

    \$end  reduce using rule 6 (c)


state 16

    4 A: 'a' . 'a'
    5  | 'a' .  ['b']

    'a'  shift, and go to state 18

    'b'  reduce using rule 5 (A)


state 17

    4 A: 'a' 'a' .  [\$end]

    \$end  reduce using rule 4 (A)


state 18

    4 A: 'a' 'a' .  ['b']

    'b'  reduce using rule 4 (A)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:396: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:396"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:396:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:396"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:396"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_98
#AT_START_99
at_fn_group_banner 99 'reduce.at:629' \
  "no %define lr.type: Lane Split" "                 " 6
at_xfail=no
(
  $as_echo "99. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%left 'a'
// Conflict resolution renders state 16 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


/* Similar to the last test case set but two states must be split.  */
S: 'a' A 'a' /* rule 1 */
 | 'b' A 'b' /* rule 2 */
 | 'c' c     /* rule 3 */
 ;

A: 'a' 'a' 'a' /* rule 4 */
 | 'a' 'a'     /* rule 5 */
 ;

c: 'a' 'a' 'b' /* rule 6 */
 | A           /* rule 7 */
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:629: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:629"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:629: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:629"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:629: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:629"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:629: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:629"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:629: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:629"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:629: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:629"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'

    'a'  shift, and go to state 5

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'
    6 c: . 'a' 'a' 'b'
    7  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'

    'a'  shift, and go to state 12


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'
    6 c: 'a' . 'a' 'b'

    'a'  shift, and go to state 15


state 9

    7 c: A .

    \$default  reduce using rule 7 (c)


state 10

    3 S: 'c' c .

    \$default  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  ['a', 'b']

    \$default  reduce using rule 5 (A)

    Conflict between rule 5 and token 'a' resolved as reduce (%left 'a').


state 13

    1 S: 'a' A 'a' .

    \$default  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .

    \$default  reduce using rule 2 (S)


state 15

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  [\$end]
    6 c: 'a' 'a' . 'b'

    'a'  shift, and go to state 16
    'b'  shift, and go to state 17

    \$default  reduce using rule 5 (A)


state 16

    4 A: 'a' 'a' 'a' .

    \$default  reduce using rule 4 (A)


state 17

    6 c: 'a' 'a' 'b' .

    \$default  reduce using rule 6 (c)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:629: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:629"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:629:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:629"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_99
#AT_START_100
at_fn_group_banner 100 'reduce.at:629' \
  "%define lr.type lalr: Lane Split" "               " 6
at_xfail=no
(
  $as_echo "100. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type lalr
%left 'a'
// Conflict resolution renders state 16 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


/* Similar to the last test case set but two states must be split.  */
S: 'a' A 'a' /* rule 1 */
 | 'b' A 'b' /* rule 2 */
 | 'c' c     /* rule 3 */
 ;

A: 'a' 'a' 'a' /* rule 4 */
 | 'a' 'a'     /* rule 5 */
 ;

c: 'a' 'a' 'b' /* rule 6 */
 | A           /* rule 7 */
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:629: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:629"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:629: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:629"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:629: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:629"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:629: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:629"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:629: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:629"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:629: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:629"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'

    'a'  shift, and go to state 5

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'
    6 c: . 'a' 'a' 'b'
    7  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'

    'a'  shift, and go to state 12


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'
    6 c: 'a' . 'a' 'b'

    'a'  shift, and go to state 15


state 9

    7 c: A .

    \$default  reduce using rule 7 (c)


state 10

    3 S: 'c' c .

    \$default  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  ['a', 'b']

    \$default  reduce using rule 5 (A)

    Conflict between rule 5 and token 'a' resolved as reduce (%left 'a').


state 13

    1 S: 'a' A 'a' .

    \$default  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .

    \$default  reduce using rule 2 (S)


state 15

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  [\$end]
    6 c: 'a' 'a' . 'b'

    'a'  shift, and go to state 16
    'b'  shift, and go to state 17

    \$default  reduce using rule 5 (A)


state 16

    4 A: 'a' 'a' 'a' .

    \$default  reduce using rule 4 (A)


state 17

    6 c: 'a' 'a' 'b' .

    \$default  reduce using rule 6 (c)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:629: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:629"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:629:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:629"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_100
#AT_START_101
at_fn_group_banner 101 'reduce.at:629' \
  "%define lr.type ielr: Lane Split" "               " 6
at_xfail=no
(
  $as_echo "101. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type ielr
%left 'a'
// Conflict resolution renders state 16 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


/* Similar to the last test case set but two states must be split.  */
S: 'a' A 'a' /* rule 1 */
 | 'b' A 'b' /* rule 2 */
 | 'c' c     /* rule 3 */
 ;

A: 'a' 'a' 'a' /* rule 4 */
 | 'a' 'a'     /* rule 5 */
 ;

c: 'a' 'a' 'b' /* rule 6 */
 | A           /* rule 7 */
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:629: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:629"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:629: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:629"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:629: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:629"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:629: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:629"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:629: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:629"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:629: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:629"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'

    'a'  shift, and go to state 18

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'
    6 c: . 'a' 'a' 'b'
    7  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'

    'a'  shift, and go to state 12


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'
    6 c: 'a' . 'a' 'b'

    'a'  shift, and go to state 15


state 9

    7 c: A .

    \$default  reduce using rule 7 (c)


state 10

    3 S: 'c' c .

    \$default  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  ['a']

    \$default  reduce using rule 5 (A)

    Conflict between rule 5 and token 'a' resolved as reduce (%left 'a').


state 13

    1 S: 'a' A 'a' .

    \$default  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .

    \$default  reduce using rule 2 (S)


state 15

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  [\$end]
    6 c: 'a' 'a' . 'b'

    'a'  shift, and go to state 16
    'b'  shift, and go to state 17

    \$default  reduce using rule 5 (A)


state 16

    4 A: 'a' 'a' 'a' .

    \$default  reduce using rule 4 (A)


state 17

    6 c: 'a' 'a' 'b' .

    \$default  reduce using rule 6 (c)


state 18

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'

    'a'  shift, and go to state 19


state 19

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  ['b']

    'a'  shift, and go to state 16

    \$default  reduce using rule 5 (A)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:629: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:629"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:629:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:629"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_101
#AT_START_102
at_fn_group_banner 102 'reduce.at:629' \
  "%define lr.type canonical-lr: Lane Split" "       " 6
at_xfail=no
(
  $as_echo "102. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type canonical-lr
%left 'a'
// Conflict resolution renders state 16 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


/* Similar to the last test case set but two states must be split.  */
S: 'a' A 'a' /* rule 1 */
 | 'b' A 'b' /* rule 2 */
 | 'c' c     /* rule 3 */
 ;

A: 'a' 'a' 'a' /* rule 4 */
 | 'a' 'a'     /* rule 5 */
 ;

c: 'a' 'a' 'b' /* rule 6 */
 | A           /* rule 7 */
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:629: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:629"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:629: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:629"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:629: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:629"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:629: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:629"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:629: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:629"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:629: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:629"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'

    'a'  shift, and go to state 18

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a' 'a'
    5  | . 'a' 'a'
    6 c: . 'a' 'a' 'b'
    7  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'

    'a'  shift, and go to state 12


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'
    6 c: 'a' . 'a' 'b'

    'a'  shift, and go to state 15


state 9

    7 c: A .  [\$end]

    \$end  reduce using rule 7 (c)


state 10

    3 S: 'c' c .  [\$end]

    \$end  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  ['a']

    'a'  reduce using rule 5 (A)

    Conflict between rule 5 and token 'a' resolved as reduce (%left 'a').


state 13

    1 S: 'a' A 'a' .  [\$end]

    \$end  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .  [\$end]

    \$end  reduce using rule 2 (S)


state 15

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  [\$end]
    6 c: 'a' 'a' . 'b'

    'a'  shift, and go to state 19
    'b'  shift, and go to state 17

    \$end  reduce using rule 5 (A)


state 16

    4 A: 'a' 'a' 'a' .  ['a']

    'a'  reduce using rule 4 (A)


state 17

    6 c: 'a' 'a' 'b' .  [\$end]

    \$end  reduce using rule 6 (c)


state 18

    4 A: 'a' . 'a' 'a'
    5  | 'a' . 'a'

    'a'  shift, and go to state 20


state 19

    4 A: 'a' 'a' 'a' .  [\$end]

    \$end  reduce using rule 4 (A)


state 20

    4 A: 'a' 'a' . 'a'
    5  | 'a' 'a' .  ['b']

    'a'  shift, and go to state 21

    'b'  reduce using rule 5 (A)


state 21

    4 A: 'a' 'a' 'a' .  ['b']

    'b'  reduce using rule 4 (A)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:629: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:629"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:629:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:629"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_102
#AT_START_103
at_fn_group_banner 103 'reduce.at:873' \
  "no %define lr.type: Complex Lane Split" "         " 6
at_xfail=no
(
  $as_echo "103. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%left 'a'
// Conflict resolution renders state 16 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


/* Similar to the last test case set but forseeing the S/R conflict from the
   first state that must be split is becoming difficult.  Imagine if B were
   even more complex.  Imagine if A had other RHS's ending in other
   nonterminals.  */
S: 'a' A 'a'
 | 'b' A 'b'
 | 'c' c
 ;
A: 'a' 'a' B
 ;
B: 'a'
 | %prec 'a'
 ;
c: 'a' 'a' 'b'
 | A
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:873: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:873"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:873: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:873"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:873: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:873"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:873: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:873"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:873: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:873"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:873: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:873"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a' B

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a' B

    'a'  shift, and go to state 5

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a' B
    7 c: . 'a' 'a' 'b'
    8  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a' B

    'a'  shift, and go to state 12


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a' B
    7 c: 'a' . 'a' 'b'

    'a'  shift, and go to state 15


state 9

    8 c: A .

    \$default  reduce using rule 8 (c)


state 10

    3 S: 'c' c .

    \$default  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  ['a', 'b']

    \$default  reduce using rule 6 (B)

    B  go to state 17

    Conflict between rule 6 and token 'a' resolved as reduce (%left 'a').


state 13

    1 S: 'a' A 'a' .

    \$default  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .

    \$default  reduce using rule 2 (S)


state 15

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  [\$end]
    7 c: 'a' 'a' . 'b'

    'a'  shift, and go to state 16
    'b'  shift, and go to state 18

    \$default  reduce using rule 6 (B)

    B  go to state 17


state 16

    5 B: 'a' .

    \$default  reduce using rule 5 (B)


state 17

    4 A: 'a' 'a' B .

    \$default  reduce using rule 4 (A)


state 18

    7 c: 'a' 'a' 'b' .

    \$default  reduce using rule 7 (c)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:873: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:873"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:873:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:873"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_103
#AT_START_104
at_fn_group_banner 104 'reduce.at:873' \
  "%define lr.type lalr: Complex Lane Split" "       " 6
at_xfail=no
(
  $as_echo "104. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type lalr
%left 'a'
// Conflict resolution renders state 16 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


/* Similar to the last test case set but forseeing the S/R conflict from the
   first state that must be split is becoming difficult.  Imagine if B were
   even more complex.  Imagine if A had other RHS's ending in other
   nonterminals.  */
S: 'a' A 'a'
 | 'b' A 'b'
 | 'c' c
 ;
A: 'a' 'a' B
 ;
B: 'a'
 | %prec 'a'
 ;
c: 'a' 'a' 'b'
 | A
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:873: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:873"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:873: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:873"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:873: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:873"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:873: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:873"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:873: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:873"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:873: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:873"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a' B

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a' B

    'a'  shift, and go to state 5

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a' B
    7 c: . 'a' 'a' 'b'
    8  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a' B

    'a'  shift, and go to state 12


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a' B
    7 c: 'a' . 'a' 'b'

    'a'  shift, and go to state 15


state 9

    8 c: A .

    \$default  reduce using rule 8 (c)


state 10

    3 S: 'c' c .

    \$default  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  ['a', 'b']

    \$default  reduce using rule 6 (B)

    B  go to state 17

    Conflict between rule 6 and token 'a' resolved as reduce (%left 'a').


state 13

    1 S: 'a' A 'a' .

    \$default  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .

    \$default  reduce using rule 2 (S)


state 15

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  [\$end]
    7 c: 'a' 'a' . 'b'

    'a'  shift, and go to state 16
    'b'  shift, and go to state 18

    \$default  reduce using rule 6 (B)

    B  go to state 17


state 16

    5 B: 'a' .

    \$default  reduce using rule 5 (B)


state 17

    4 A: 'a' 'a' B .

    \$default  reduce using rule 4 (A)


state 18

    7 c: 'a' 'a' 'b' .

    \$default  reduce using rule 7 (c)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:873: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:873"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:873:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:873"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_104
#AT_START_105
at_fn_group_banner 105 'reduce.at:873' \
  "%define lr.type ielr: Complex Lane Split" "       " 6
at_xfail=no
(
  $as_echo "105. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type ielr
%left 'a'
// Conflict resolution renders state 16 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


/* Similar to the last test case set but forseeing the S/R conflict from the
   first state that must be split is becoming difficult.  Imagine if B were
   even more complex.  Imagine if A had other RHS's ending in other
   nonterminals.  */
S: 'a' A 'a'
 | 'b' A 'b'
 | 'c' c
 ;
A: 'a' 'a' B
 ;
B: 'a'
 | %prec 'a'
 ;
c: 'a' 'a' 'b'
 | A
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:873: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:873"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:873: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:873"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:873: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:873"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:873: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:873"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:873: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:873"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:873: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:873"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a' B

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a' B

    'a'  shift, and go to state 19

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a' B
    7 c: . 'a' 'a' 'b'
    8  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a' B

    'a'  shift, and go to state 12


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a' B
    7 c: 'a' . 'a' 'b'

    'a'  shift, and go to state 15


state 9

    8 c: A .

    \$default  reduce using rule 8 (c)


state 10

    3 S: 'c' c .

    \$default  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  ['a']

    \$default  reduce using rule 6 (B)

    B  go to state 17

    Conflict between rule 6 and token 'a' resolved as reduce (%left 'a').


state 13

    1 S: 'a' A 'a' .

    \$default  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .

    \$default  reduce using rule 2 (S)


state 15

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  [\$end]
    7 c: 'a' 'a' . 'b'

    'a'  shift, and go to state 16
    'b'  shift, and go to state 18

    \$default  reduce using rule 6 (B)

    B  go to state 17


state 16

    5 B: 'a' .

    \$default  reduce using rule 5 (B)


state 17

    4 A: 'a' 'a' B .

    \$default  reduce using rule 4 (A)


state 18

    7 c: 'a' 'a' 'b' .

    \$default  reduce using rule 7 (c)


state 19

    4 A: 'a' . 'a' B

    'a'  shift, and go to state 20


state 20

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  ['b']

    'a'  shift, and go to state 16

    \$default  reduce using rule 6 (B)

    B  go to state 17
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:873: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:873"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:873:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:873"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_105
#AT_START_106
at_fn_group_banner 106 'reduce.at:873' \
  "%define lr.type canonical-lr: Complex Lane Split" "" 6
at_xfail=no
(
  $as_echo "106. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type canonical-lr
%left 'a'
// Conflict resolution renders state 16 unreachable for canonical LR(1).  We
// keep it so that the paser table diff is easier to code.
%define lr.keep-unreachable-states

%%


/* Similar to the last test case set but forseeing the S/R conflict from the
   first state that must be split is becoming difficult.  Imagine if B were
   even more complex.  Imagine if A had other RHS's ending in other
   nonterminals.  */
S: 'a' A 'a'
 | 'b' A 'b'
 | 'c' c
 ;
A: 'a' 'a' B
 ;
B: 'a'
 | %prec 'a'
 ;
c: 'a' 'a' 'b'
 | A
 ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'a', 'a', 'a', 'b', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:873: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:873"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:873: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:873"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:873: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:873"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:873: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:873"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:873: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:873"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:873: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:873"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'a'
    2  | . 'b' A 'b'
    3  | . 'c' c

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'a'
    4 A: . 'a' 'a' B

    'a'  shift, and go to state 5

    A  go to state 6


state 2

    2 S: 'b' . A 'b'
    4 A: . 'a' 'a' B

    'a'  shift, and go to state 19

    A  go to state 7


state 3

    3 S: 'c' . c
    4 A: . 'a' 'a' B
    7 c: . 'a' 'a' 'b'
    8  | . A

    'a'  shift, and go to state 8

    A  go to state 9
    c  go to state 10


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 11


state 5

    4 A: 'a' . 'a' B

    'a'  shift, and go to state 12


state 6

    1 S: 'a' A . 'a'

    'a'  shift, and go to state 13


state 7

    2 S: 'b' A . 'b'

    'b'  shift, and go to state 14


state 8

    4 A: 'a' . 'a' B
    7 c: 'a' . 'a' 'b'

    'a'  shift, and go to state 15


state 9

    8 c: A .  [\$end]

    \$end  reduce using rule 8 (c)


state 10

    3 S: 'c' c .  [\$end]

    \$end  reduce using rule 3 (S)


state 11

    0 \$accept: S \$end .

    \$default  accept


state 12

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  ['a']

    'a'  reduce using rule 6 (B)

    B  go to state 17

    Conflict between rule 6 and token 'a' resolved as reduce (%left 'a').


state 13

    1 S: 'a' A 'a' .  [\$end]

    \$end  reduce using rule 1 (S)


state 14

    2 S: 'b' A 'b' .  [\$end]

    \$end  reduce using rule 2 (S)


state 15

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  [\$end]
    7 c: 'a' 'a' . 'b'

    'a'  shift, and go to state 20
    'b'  shift, and go to state 18

    \$end  reduce using rule 6 (B)

    B  go to state 21


state 16

    5 B: 'a' .  ['a']

    'a'  reduce using rule 5 (B)


state 17

    4 A: 'a' 'a' B .  ['a']

    'a'  reduce using rule 4 (A)


state 18

    7 c: 'a' 'a' 'b' .  [\$end]

    \$end  reduce using rule 7 (c)


state 19

    4 A: 'a' . 'a' B

    'a'  shift, and go to state 22


state 20

    5 B: 'a' .  [\$end]

    \$end  reduce using rule 5 (B)


state 21

    4 A: 'a' 'a' B .  [\$end]

    \$end  reduce using rule 4 (A)


state 22

    4 A: 'a' 'a' . B
    5 B: . 'a'
    6  | .  ['b']

    'a'  shift, and go to state 23

    'b'  reduce using rule 6 (B)

    B  go to state 24


state 23

    5 B: 'a' .  ['b']

    'b'  reduce using rule 5 (B)


state 24

    4 A: 'a' 'a' B .  ['b']

    'b'  reduce using rule 4 (A)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:873: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:873"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:873:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:873"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:873"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_106
#AT_START_107
at_fn_group_banner 107 'reduce.at:1142' \
  "no %define lr.type: Split During Added Lookahead Propagation" "" 6
at_xfail=no
(
  $as_echo "107. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.keep-unreachable-states

%%


/* The partial state chart diagram below is for LALR(1).  State 0 is the start
   state.  States are iterated for successor construction in numerical order.
   Transitions are downwards.

   State 13 has a R/R conflict that cannot be predicted by Bison's LR(1)
   algorithm using annotations alone.  That is, when state 11's successor on
   'd' is merged with state 5 (which is originally just state 1's successor on
   'd'), state 5's successor on 'e' must then be changed because the resulting
   lookaheads that propagate to it now make it incompatible with state 8's
   successor on 'e'.  In other words, state 13 must be split to avoid the
   conflict.

          0
        / | \
     a / c|  \ b
      1   3   2
      |   |   |
     d|   |c  | d
      |  11   |
      |   |   |
       \ /d   |
        5     8
         \    |
        e \  / e
           13
           R/R

   This grammar is designed carefully to make sure that, despite Bison's LR(1)
   algorithm's bread-first iteration of transitions to reconstruct states,
   state 11's successors are constructed after state 5's and state 8's.
   Otherwise (for example, if you remove the first 'c' in each of rules 6 and
   7), state 5's successor on 'e' would never be merged with state 8's, so the
   split of the resulting state 13 would never need to be performed.  */
S: 'a' A 'f'
 | 'a' B
 | 'b' A 'f'
 | 'b' B 'g'
 | 'b' 'd'
 | 'c' 'c' A 'g'
 | 'c' 'c' B
 ;
A: 'd' 'e' ;
B: 'd' 'e' ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'd', 'e', 'g', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:1142"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1142"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1142"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1142"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1142"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1142: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:1142"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'f'
    2  | . 'a' B
    3  | . 'b' A 'f'
    4  | . 'b' B 'g'
    5  | . 'b' 'd'
    6  | . 'c' 'c' A 'g'
    7  | . 'c' 'c' B

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'f'
    2  | 'a' . B
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 5

    A  go to state 6
    B  go to state 7


state 2

    3 S: 'b' . A 'f'
    4  | 'b' . B 'g'
    5  | 'b' . 'd'
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 8

    A  go to state 9
    B  go to state 10


state 3

    6 S: 'c' . 'c' A 'g'
    7  | 'c' . 'c' B

    'c'  shift, and go to state 11


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 12


state 5

    8 A: 'd' . 'e'
    9 B: 'd' . 'e'

    'e'  shift, and go to state 13


state 6

    1 S: 'a' A . 'f'

    'f'  shift, and go to state 14


state 7

    2 S: 'a' B .

    \$default  reduce using rule 2 (S)


state 8

    5 S: 'b' 'd' .  [\$end]
    8 A: 'd' . 'e'
    9 B: 'd' . 'e'

    'e'  shift, and go to state 13

    \$default  reduce using rule 5 (S)


state 9

    3 S: 'b' A . 'f'

    'f'  shift, and go to state 15


state 10

    4 S: 'b' B . 'g'

    'g'  shift, and go to state 16


state 11

    6 S: 'c' 'c' . A 'g'
    7  | 'c' 'c' . B
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 5

    A  go to state 17
    B  go to state 18


state 12

    0 \$accept: S \$end .

    \$default  accept


state 13

    8 A: 'd' 'e' .  ['f', 'g']
    9 B: 'd' 'e' .  [\$end, 'g']

    \$end      reduce using rule 9 (B)
    'g'       reduce using rule 8 (A)
    'g'       [reduce using rule 9 (B)]
    \$default  reduce using rule 8 (A)


state 14

    1 S: 'a' A 'f' .

    \$default  reduce using rule 1 (S)


state 15

    3 S: 'b' A 'f' .

    \$default  reduce using rule 3 (S)


state 16

    4 S: 'b' B 'g' .

    \$default  reduce using rule 4 (S)


state 17

    6 S: 'c' 'c' A . 'g'

    'g'  shift, and go to state 19


state 18

    7 S: 'c' 'c' B .

    \$default  reduce using rule 7 (S)


state 19

    6 S: 'c' 'c' A 'g' .

    \$default  reduce using rule 6 (S)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:1142: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:1142"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1142:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:1142"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_107
#AT_START_108
at_fn_group_banner 108 'reduce.at:1142' \
  "%define lr.type lalr: Split During Added Lookahead Propagation" "" 6
at_xfail=no
(
  $as_echo "108. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type lalr
%define lr.keep-unreachable-states

%%


/* The partial state chart diagram below is for LALR(1).  State 0 is the start
   state.  States are iterated for successor construction in numerical order.
   Transitions are downwards.

   State 13 has a R/R conflict that cannot be predicted by Bison's LR(1)
   algorithm using annotations alone.  That is, when state 11's successor on
   'd' is merged with state 5 (which is originally just state 1's successor on
   'd'), state 5's successor on 'e' must then be changed because the resulting
   lookaheads that propagate to it now make it incompatible with state 8's
   successor on 'e'.  In other words, state 13 must be split to avoid the
   conflict.

          0
        / | \
     a / c|  \ b
      1   3   2
      |   |   |
     d|   |c  | d
      |  11   |
      |   |   |
       \ /d   |
        5     8
         \    |
        e \  / e
           13
           R/R

   This grammar is designed carefully to make sure that, despite Bison's LR(1)
   algorithm's bread-first iteration of transitions to reconstruct states,
   state 11's successors are constructed after state 5's and state 8's.
   Otherwise (for example, if you remove the first 'c' in each of rules 6 and
   7), state 5's successor on 'e' would never be merged with state 8's, so the
   split of the resulting state 13 would never need to be performed.  */
S: 'a' A 'f'
 | 'a' B
 | 'b' A 'f'
 | 'b' B 'g'
 | 'b' 'd'
 | 'c' 'c' A 'g'
 | 'c' 'c' B
 ;
A: 'd' 'e' ;
B: 'd' 'e' ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'd', 'e', 'g', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:1142"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1142"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1142"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1142"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1142"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1142: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:1142"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'f'
    2  | . 'a' B
    3  | . 'b' A 'f'
    4  | . 'b' B 'g'
    5  | . 'b' 'd'
    6  | . 'c' 'c' A 'g'
    7  | . 'c' 'c' B

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'f'
    2  | 'a' . B
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 5

    A  go to state 6
    B  go to state 7


state 2

    3 S: 'b' . A 'f'
    4  | 'b' . B 'g'
    5  | 'b' . 'd'
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 8

    A  go to state 9
    B  go to state 10


state 3

    6 S: 'c' . 'c' A 'g'
    7  | 'c' . 'c' B

    'c'  shift, and go to state 11


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 12


state 5

    8 A: 'd' . 'e'
    9 B: 'd' . 'e'

    'e'  shift, and go to state 13


state 6

    1 S: 'a' A . 'f'

    'f'  shift, and go to state 14


state 7

    2 S: 'a' B .

    \$default  reduce using rule 2 (S)


state 8

    5 S: 'b' 'd' .  [\$end]
    8 A: 'd' . 'e'
    9 B: 'd' . 'e'

    'e'  shift, and go to state 13

    \$default  reduce using rule 5 (S)


state 9

    3 S: 'b' A . 'f'

    'f'  shift, and go to state 15


state 10

    4 S: 'b' B . 'g'

    'g'  shift, and go to state 16


state 11

    6 S: 'c' 'c' . A 'g'
    7  | 'c' 'c' . B
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 5

    A  go to state 17
    B  go to state 18


state 12

    0 \$accept: S \$end .

    \$default  accept


state 13

    8 A: 'd' 'e' .  ['f', 'g']
    9 B: 'd' 'e' .  [\$end, 'g']

    \$end      reduce using rule 9 (B)
    'g'       reduce using rule 8 (A)
    'g'       [reduce using rule 9 (B)]
    \$default  reduce using rule 8 (A)


state 14

    1 S: 'a' A 'f' .

    \$default  reduce using rule 1 (S)


state 15

    3 S: 'b' A 'f' .

    \$default  reduce using rule 3 (S)


state 16

    4 S: 'b' B 'g' .

    \$default  reduce using rule 4 (S)


state 17

    6 S: 'c' 'c' A . 'g'

    'g'  shift, and go to state 19


state 18

    7 S: 'c' 'c' B .

    \$default  reduce using rule 7 (S)


state 19

    6 S: 'c' 'c' A 'g' .

    \$default  reduce using rule 6 (S)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:1142: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:1142"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1142:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:1142"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_108
#AT_START_109
at_fn_group_banner 109 'reduce.at:1142' \
  "%define lr.type ielr: Split During Added Lookahead Propagation" "" 6
at_xfail=no
(
  $as_echo "109. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type ielr
%define lr.keep-unreachable-states

%%


/* The partial state chart diagram below is for LALR(1).  State 0 is the start
   state.  States are iterated for successor construction in numerical order.
   Transitions are downwards.

   State 13 has a R/R conflict that cannot be predicted by Bison's LR(1)
   algorithm using annotations alone.  That is, when state 11's successor on
   'd' is merged with state 5 (which is originally just state 1's successor on
   'd'), state 5's successor on 'e' must then be changed because the resulting
   lookaheads that propagate to it now make it incompatible with state 8's
   successor on 'e'.  In other words, state 13 must be split to avoid the
   conflict.

          0
        / | \
     a / c|  \ b
      1   3   2
      |   |   |
     d|   |c  | d
      |  11   |
      |   |   |
       \ /d   |
        5     8
         \    |
        e \  / e
           13
           R/R

   This grammar is designed carefully to make sure that, despite Bison's LR(1)
   algorithm's bread-first iteration of transitions to reconstruct states,
   state 11's successors are constructed after state 5's and state 8's.
   Otherwise (for example, if you remove the first 'c' in each of rules 6 and
   7), state 5's successor on 'e' would never be merged with state 8's, so the
   split of the resulting state 13 would never need to be performed.  */
S: 'a' A 'f'
 | 'a' B
 | 'b' A 'f'
 | 'b' B 'g'
 | 'b' 'd'
 | 'c' 'c' A 'g'
 | 'c' 'c' B
 ;
A: 'd' 'e' ;
B: 'd' 'e' ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'd', 'e', 'g', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:1142"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1142"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1142"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1142"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1142"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1142: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:1142"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'f'
    2  | . 'a' B
    3  | . 'b' A 'f'
    4  | . 'b' B 'g'
    5  | . 'b' 'd'
    6  | . 'c' 'c' A 'g'
    7  | . 'c' 'c' B

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'f'
    2  | 'a' . B
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 5

    A  go to state 6
    B  go to state 7


state 2

    3 S: 'b' . A 'f'
    4  | 'b' . B 'g'
    5  | 'b' . 'd'
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 8

    A  go to state 9
    B  go to state 10


state 3

    6 S: 'c' . 'c' A 'g'
    7  | 'c' . 'c' B

    'c'  shift, and go to state 11


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 12


state 5

    8 A: 'd' . 'e'
    9 B: 'd' . 'e'

    'e'  shift, and go to state 20


state 6

    1 S: 'a' A . 'f'

    'f'  shift, and go to state 14


state 7

    2 S: 'a' B .

    \$default  reduce using rule 2 (S)


state 8

    5 S: 'b' 'd' .  [\$end]
    8 A: 'd' . 'e'
    9 B: 'd' . 'e'

    'e'  shift, and go to state 13

    \$default  reduce using rule 5 (S)


state 9

    3 S: 'b' A . 'f'

    'f'  shift, and go to state 15


state 10

    4 S: 'b' B . 'g'

    'g'  shift, and go to state 16


state 11

    6 S: 'c' 'c' . A 'g'
    7  | 'c' 'c' . B
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 5

    A  go to state 17
    B  go to state 18


state 12

    0 \$accept: S \$end .

    \$default  accept


state 13

    8 A: 'd' 'e' .  ['f']
    9 B: 'd' 'e' .  ['g']

    'g'       reduce using rule 9 (B)
    \$default  reduce using rule 8 (A)


state 14

    1 S: 'a' A 'f' .

    \$default  reduce using rule 1 (S)


state 15

    3 S: 'b' A 'f' .

    \$default  reduce using rule 3 (S)


state 16

    4 S: 'b' B 'g' .

    \$default  reduce using rule 4 (S)


state 17

    6 S: 'c' 'c' A . 'g'

    'g'  shift, and go to state 19


state 18

    7 S: 'c' 'c' B .

    \$default  reduce using rule 7 (S)


state 19

    6 S: 'c' 'c' A 'g' .

    \$default  reduce using rule 6 (S)


state 20

    8 A: 'd' 'e' .  ['f', 'g']
    9 B: 'd' 'e' .  [\$end]

    \$end      reduce using rule 9 (B)
    \$default  reduce using rule 8 (A)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:1142: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:1142"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1142:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:1142"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_109
#AT_START_110
at_fn_group_banner 110 'reduce.at:1142' \
  "%define lr.type canonical-lr: Split During Added Lookahead Propagation" "" 6
at_xfail=no
(
  $as_echo "110. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type canonical-lr
%define lr.keep-unreachable-states

%%


/* The partial state chart diagram below is for LALR(1).  State 0 is the start
   state.  States are iterated for successor construction in numerical order.
   Transitions are downwards.

   State 13 has a R/R conflict that cannot be predicted by Bison's LR(1)
   algorithm using annotations alone.  That is, when state 11's successor on
   'd' is merged with state 5 (which is originally just state 1's successor on
   'd'), state 5's successor on 'e' must then be changed because the resulting
   lookaheads that propagate to it now make it incompatible with state 8's
   successor on 'e'.  In other words, state 13 must be split to avoid the
   conflict.

          0
        / | \
     a / c|  \ b
      1   3   2
      |   |   |
     d|   |c  | d
      |  11   |
      |   |   |
       \ /d   |
        5     8
         \    |
        e \  / e
           13
           R/R

   This grammar is designed carefully to make sure that, despite Bison's LR(1)
   algorithm's bread-first iteration of transitions to reconstruct states,
   state 11's successors are constructed after state 5's and state 8's.
   Otherwise (for example, if you remove the first 'c' in each of rules 6 and
   7), state 5's successor on 'e' would never be merged with state 8's, so the
   split of the resulting state 13 would never need to be performed.  */
S: 'a' A 'f'
 | 'a' B
 | 'b' A 'f'
 | 'b' B 'g'
 | 'b' 'd'
 | 'c' 'c' A 'g'
 | 'c' 'c' B
 ;
A: 'd' 'e' ;
B: 'd' 'e' ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'b', 'd', 'e', 'g', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:1142"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1142"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1142"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1142: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1142"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:1142: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1142"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1142: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:1142"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . S \$end
    1 S: . 'a' A 'f'
    2  | . 'a' B
    3  | . 'b' A 'f'
    4  | . 'b' B 'g'
    5  | . 'b' 'd'
    6  | . 'c' 'c' A 'g'
    7  | . 'c' 'c' B

    'a'  shift, and go to state 1
    'b'  shift, and go to state 2
    'c'  shift, and go to state 3

    S  go to state 4


state 1

    1 S: 'a' . A 'f'
    2  | 'a' . B
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 5

    A  go to state 6
    B  go to state 7


state 2

    3 S: 'b' . A 'f'
    4  | 'b' . B 'g'
    5  | 'b' . 'd'
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 8

    A  go to state 9
    B  go to state 10


state 3

    6 S: 'c' . 'c' A 'g'
    7  | 'c' . 'c' B

    'c'  shift, and go to state 11


state 4

    0 \$accept: S . \$end

    \$end  shift, and go to state 12


state 5

    8 A: 'd' . 'e'
    9 B: 'd' . 'e'

    'e'  shift, and go to state 13


state 6

    1 S: 'a' A . 'f'

    'f'  shift, and go to state 14


state 7

    2 S: 'a' B .  [\$end]

    \$end  reduce using rule 2 (S)


state 8

    5 S: 'b' 'd' .  [\$end]
    8 A: 'd' . 'e'
    9 B: 'd' . 'e'

    'e'  shift, and go to state 20

    \$end  reduce using rule 5 (S)


state 9

    3 S: 'b' A . 'f'

    'f'  shift, and go to state 15


state 10

    4 S: 'b' B . 'g'

    'g'  shift, and go to state 16


state 11

    6 S: 'c' 'c' . A 'g'
    7  | 'c' 'c' . B
    8 A: . 'd' 'e'
    9 B: . 'd' 'e'

    'd'  shift, and go to state 21

    A  go to state 17
    B  go to state 18


state 12

    0 \$accept: S \$end .

    \$default  accept


state 13

    8 A: 'd' 'e' .  ['f']
    9 B: 'd' 'e' .  [\$end]

    \$end  reduce using rule 9 (B)
    'f'   reduce using rule 8 (A)


state 14

    1 S: 'a' A 'f' .  [\$end]

    \$end  reduce using rule 1 (S)


state 15

    3 S: 'b' A 'f' .  [\$end]

    \$end  reduce using rule 3 (S)


state 16

    4 S: 'b' B 'g' .  [\$end]

    \$end  reduce using rule 4 (S)


state 17

    6 S: 'c' 'c' A . 'g'

    'g'  shift, and go to state 19


state 18

    7 S: 'c' 'c' B .  [\$end]

    \$end  reduce using rule 7 (S)


state 19

    6 S: 'c' 'c' A 'g' .  [\$end]

    \$end  reduce using rule 6 (S)


state 20

    8 A: 'd' 'e' .  ['f']
    9 B: 'd' 'e' .  ['g']

    'f'  reduce using rule 8 (A)
    'g'  reduce using rule 9 (B)


state 21

    8 A: 'd' . 'e'
    9 B: 'd' . 'e'

    'e'  shift, and go to state 22


state 22

    8 A: 'd' 'e' .  ['g']
    9 B: 'd' 'e' .  [\$end]

    \$end  reduce using rule 9 (B)
    'g'   reduce using rule 8 (A)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:1142: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:1142"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1142:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:1142"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1142"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_110
#AT_START_111
at_fn_group_banner 111 'reduce.at:1472' \
  "no %define lr.default-reductions" "               " 6
at_xfail=no
(
  $as_echo "111. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}



%%


/* The start state is consistent and has a shift on 'a' and no reductions.
   After pushing the b below, enter an inconsistent state that has a shift and
   one reduction with one lookahead.  */
start:
    a b
  | a b 'a'
  | a c 'b'
  ;

/* After shifting this 'a', enter a consistent state that has no shift and 1
   reduction with multiple lookaheads.  */
a: 'a' ;

/* After the previous reduction, enter an inconsistent state that has no shift
   and multiple reductions.  The first reduction has more lookaheads than the
   second, so the first should always be preferred as the default reduction if
   enabled.  The second reduction has one lookahead.  */
b: ;
c: ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'a', 'a', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:1472"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1472"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1472"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1472"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1472"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1472: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:1472"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . start \$end
    1 start: . a b
    2      | . a b 'a'
    3      | . a c 'b'
    4 a: . 'a'

    'a'  shift, and go to state 1

    start  go to state 2
    a      go to state 3


state 1

    4 a: 'a' .

    \$default  reduce using rule 4 (a)


state 2

    0 \$accept: start . \$end

    \$end  shift, and go to state 4


state 3

    1 start: a . b
    2      | a . b 'a'
    3      | a . c 'b'
    5 b: .  [\$end, 'a']
    6 c: .  ['b']

    'b'       reduce using rule 6 (c)
    \$default  reduce using rule 5 (b)

    b  go to state 5
    c  go to state 6


state 4

    0 \$accept: start \$end .

    \$default  accept


state 5

    1 start: a b .  [\$end]
    2      | a b . 'a'

    'a'  shift, and go to state 7

    \$default  reduce using rule 1 (start)


state 6

    3 start: a c . 'b'

    'b'  shift, and go to state 8


state 7

    2 start: a b 'a' .

    \$default  reduce using rule 2 (start)


state 8

    3 start: a c 'b' .

    \$default  reduce using rule 3 (start)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:1472: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:1472"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1472:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:1472"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_111
#AT_START_112
at_fn_group_banner 112 'reduce.at:1472' \
  "%define lr.default-reductions all" "              " 6
at_xfail=no
(
  $as_echo "112. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.default-reductions all

%%


/* The start state is consistent and has a shift on 'a' and no reductions.
   After pushing the b below, enter an inconsistent state that has a shift and
   one reduction with one lookahead.  */
start:
    a b
  | a b 'a'
  | a c 'b'
  ;

/* After shifting this 'a', enter a consistent state that has no shift and 1
   reduction with multiple lookaheads.  */
a: 'a' ;

/* After the previous reduction, enter an inconsistent state that has no shift
   and multiple reductions.  The first reduction has more lookaheads than the
   second, so the first should always be preferred as the default reduction if
   enabled.  The second reduction has one lookahead.  */
b: ;
c: ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'a', 'a', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:1472"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1472"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1472"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1472"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1472"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1472: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:1472"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . start \$end
    1 start: . a b
    2      | . a b 'a'
    3      | . a c 'b'
    4 a: . 'a'

    'a'  shift, and go to state 1

    start  go to state 2
    a      go to state 3


state 1

    4 a: 'a' .

    \$default  reduce using rule 4 (a)


state 2

    0 \$accept: start . \$end

    \$end  shift, and go to state 4


state 3

    1 start: a . b
    2      | a . b 'a'
    3      | a . c 'b'
    5 b: .  [\$end, 'a']
    6 c: .  ['b']

    'b'       reduce using rule 6 (c)
    \$default  reduce using rule 5 (b)

    b  go to state 5
    c  go to state 6


state 4

    0 \$accept: start \$end .

    \$default  accept


state 5

    1 start: a b .  [\$end]
    2      | a b . 'a'

    'a'  shift, and go to state 7

    \$default  reduce using rule 1 (start)


state 6

    3 start: a c . 'b'

    'b'  shift, and go to state 8


state 7

    2 start: a b 'a' .

    \$default  reduce using rule 2 (start)


state 8

    3 start: a c 'b' .

    \$default  reduce using rule 3 (start)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:1472: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:1472"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1472:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:1472"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_112
#AT_START_113
at_fn_group_banner 113 'reduce.at:1472' \
  "%define lr.default-reductions consistent" "       " 6
at_xfail=no
(
  $as_echo "113. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.default-reductions consistent

%%


/* The start state is consistent and has a shift on 'a' and no reductions.
   After pushing the b below, enter an inconsistent state that has a shift and
   one reduction with one lookahead.  */
start:
    a b
  | a b 'a'
  | a c 'b'
  ;

/* After shifting this 'a', enter a consistent state that has no shift and 1
   reduction with multiple lookaheads.  */
a: 'a' ;

/* After the previous reduction, enter an inconsistent state that has no shift
   and multiple reductions.  The first reduction has more lookaheads than the
   second, so the first should always be preferred as the default reduction if
   enabled.  The second reduction has one lookahead.  */
b: ;
c: ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'a', 'a', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:1472"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1472"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1472"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1472"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1472"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1472: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:1472"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . start \$end
    1 start: . a b
    2      | . a b 'a'
    3      | . a c 'b'
    4 a: . 'a'

    'a'  shift, and go to state 1

    start  go to state 2
    a      go to state 3


state 1

    4 a: 'a' .

    \$default  reduce using rule 4 (a)


state 2

    0 \$accept: start . \$end

    \$end  shift, and go to state 4


state 3

    1 start: a . b
    2      | a . b 'a'
    3      | a . c 'b'
    5 b: .  [\$end, 'a']
    6 c: .  ['b']

    \$end  reduce using rule 5 (b)
    'a'   reduce using rule 5 (b)
    'b'   reduce using rule 6 (c)

    b  go to state 5
    c  go to state 6


state 4

    0 \$accept: start \$end .

    \$default  accept


state 5

    1 start: a b .  [\$end]
    2      | a b . 'a'

    'a'  shift, and go to state 7

    \$end  reduce using rule 1 (start)


state 6

    3 start: a c . 'b'

    'b'  shift, and go to state 8


state 7

    2 start: a b 'a' .

    \$default  reduce using rule 2 (start)


state 8

    3 start: a c 'b' .

    \$default  reduce using rule 3 (start)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:1472: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:1472"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1472:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:1472"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_113
#AT_START_114
at_fn_group_banner 114 'reduce.at:1472' \
  "%define lr.default-reductions accepting" "        " 6
at_xfail=no
(
  $as_echo "114. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.default-reductions accepting

%%


/* The start state is consistent and has a shift on 'a' and no reductions.
   After pushing the b below, enter an inconsistent state that has a shift and
   one reduction with one lookahead.  */
start:
    a b
  | a b 'a'
  | a c 'b'
  ;

/* After shifting this 'a', enter a consistent state that has no shift and 1
   reduction with multiple lookaheads.  */
a: 'a' ;

/* After the previous reduction, enter an inconsistent state that has no shift
   and multiple reductions.  The first reduction has more lookaheads than the
   second, so the first should always be preferred as the default reduction if
   enabled.  The second reduction has one lookahead.  */
b: ;
c: ;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    'a', 'a', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "reduce.at:1472"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1472"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1472"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/reduce.at:1472: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "reduce.at:1472"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/reduce.at:1472: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "reduce.at:1472"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1472: sed -n '/^state 0\$/,\$p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 0$/,$p' input.output" "reduce.at:1472"
( $at_check_trace; sed -n '/^state 0$/,$p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . start \$end
    1 start: . a b
    2      | . a b 'a'
    3      | . a c 'b'
    4 a: . 'a'

    'a'  shift, and go to state 1

    start  go to state 2
    a      go to state 3


state 1

    4 a: 'a' .  [\$end, 'a', 'b']

    \$end  reduce using rule 4 (a)
    'a'   reduce using rule 4 (a)
    'b'   reduce using rule 4 (a)


state 2

    0 \$accept: start . \$end

    \$end  shift, and go to state 4


state 3

    1 start: a . b
    2      | a . b 'a'
    3      | a . c 'b'
    5 b: .  [\$end, 'a']
    6 c: .  ['b']

    \$end  reduce using rule 5 (b)
    'a'   reduce using rule 5 (b)
    'b'   reduce using rule 6 (c)

    b  go to state 5
    c  go to state 6


state 4

    0 \$accept: start \$end .

    \$default  accept


state 5

    1 start: a b .  [\$end]
    2      | a b . 'a'

    'a'  shift, and go to state 7

    \$end  reduce using rule 1 (start)


state 6

    3 start: a c . 'b'

    'b'  shift, and go to state 8


state 7

    2 start: a b 'a' .  [\$end]

    \$end  reduce using rule 2 (start)


state 8

    3 start: a c 'b' .  [\$end]

    \$end  reduce using rule 3 (start)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/reduce.at:1472: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "reduce.at:1472"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/reduce.at:1472:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "reduce.at:1472"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/reduce.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_114
#AT_START_115
at_fn_group_banner 115 'synclines.at:109' \
  "Prologue synch line" "                            " 7
at_xfail=no
(
  $as_echo "115. $at_setup_line: testing $at_desc ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ set +x
$as_echo "$at_srcdir/synclines.at:109: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c syncline.c" "synclines.at:109"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c syncline.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:109: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:109"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:109: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:109"
( $at_check_trace; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%{
#error "2"
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/synclines.at:109: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:109"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/synclines.at:109: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:109"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/synclines.at:109: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:109"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/synclines.at:109: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:109"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/synclines.at:109: bison -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:109"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/synclines.at:109: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c input.c" "synclines.at:109"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:109: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:109"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:109: cat stdout"
at_fn_check_prepare_trace "synclines.at:109"
( $at_check_trace; cat stdout
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:2: #error \"2\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_115
#AT_START_116
at_fn_group_banner 116 'synclines.at:126' \
  "%union synch line" "                              " 7
at_xfail=no
(
  $as_echo "116. $at_setup_line: testing $at_desc ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ set +x
$as_echo "$at_srcdir/synclines.at:126: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c syncline.c" "synclines.at:126"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c syncline.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:126: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:126"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:126: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:126"
( $at_check_trace; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%union {
#error "2"
  char dummy;
}
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/synclines.at:126: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:126"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/synclines.at:126: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:126"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/synclines.at:126: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:126"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/synclines.at:126: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:126"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/synclines.at:126: bison -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:126"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/synclines.at:126: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c input.c" "synclines.at:126"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:126: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:126"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:126: cat stdout"
at_fn_check_prepare_trace "synclines.at:126"
( $at_check_trace; cat stdout
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:2: #error \"2\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:126"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_116
#AT_START_117
at_fn_group_banner 117 'synclines.at:146' \
  "Postprologue synch line" "                        " 7
at_xfail=no
(
  $as_echo "117. $at_setup_line: testing $at_desc ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ set +x
$as_echo "$at_srcdir/synclines.at:146: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c syncline.c" "synclines.at:146"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c syncline.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:146: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:146"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:146: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:146"
( $at_check_trace; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%union
{
  int ival;
}
%{
#error "10"
%}
%%
exp: '0';
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/synclines.at:146: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:146"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/synclines.at:146: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:146"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/synclines.at:146: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:146"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/synclines.at:146: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:146"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/synclines.at:146: bison -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:146"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/synclines.at:146: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c input.c" "synclines.at:146"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:146: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:146"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:146: cat stdout"
at_fn_check_prepare_trace "synclines.at:146"
( $at_check_trace; cat stdout
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:10: #error \"10\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_117
#AT_START_118
at_fn_group_banner 118 'synclines.at:169' \
  "Action synch line" "                              " 7
at_xfail=no
(
  $as_echo "118. $at_setup_line: testing $at_desc ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ set +x
$as_echo "$at_srcdir/synclines.at:169: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c syncline.c" "synclines.at:169"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c syncline.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:169: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:169"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:169: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:169"
( $at_check_trace; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp:
{
#error "8"
};
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/synclines.at:169: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:169"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/synclines.at:169: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:169"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/synclines.at:169: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:169"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/synclines.at:169: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:169"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/synclines.at:169: bison -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:169"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/synclines.at:169: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c input.c" "synclines.at:169"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:169: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:169"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:169: cat stdout"
at_fn_check_prepare_trace "synclines.at:169"
( $at_check_trace; cat stdout
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:8: #error \"8\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:169"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_118
#AT_START_119
at_fn_group_banner 119 'synclines.at:188' \
  "Epilogue synch line" "                            " 7
at_xfail=no
(
  $as_echo "119. $at_setup_line: testing $at_desc ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ set +x
$as_echo "$at_srcdir/synclines.at:188: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c syncline.c" "synclines.at:188"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c syncline.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:188: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:188"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:188: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:188"
( $at_check_trace; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
%%
#error "8"
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/synclines.at:188: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:188"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/synclines.at:188: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:188"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/synclines.at:188: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:188"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/synclines.at:188: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "synclines.at:188"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/synclines.at:188: bison -o input.c input.y"
at_fn_check_prepare_trace "synclines.at:188"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/synclines.at:188: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -c input.c" "synclines.at:188"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_skip $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
# It may also issue more context information:
#
#   input.y: In function 'yyparse':
#   input.y:8: #error "8"
# =>
#   input.y:4: #error "8"
#
#
# And possibly distcc adds its bits.
#
#   distcc[33187] ERROR: compile (null) on localhost failed
#   syncline.c:1:2: error: #error "1"
#   distcc[33185] ERROR: compile syncline.c on localhost failed
#
# or even
#
#   distcc[35882] (dcc_connect_by_name) ERROR: failed to look up host "chrisimac": Unknown host
#   distcc[35882] Warning: failed to distribute input.c to chrisimac/4, running locally instead

{ set +x
$as_echo "$at_srcdir/synclines.at:188: sed -e '/^distcc\\[[0-9]*\\] /d'                            \\
               -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/'      \\
               -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/'  \\
               -e \"/^[^:]*: In function '[^\\']*':\$/d\"                \\
            stderr"
at_fn_check_prepare_notrace 'an embedded newline' "synclines.at:188"
( $at_check_trace; sed -e '/^distcc\[[0-9]*\] /d'                            \
               -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/'      \
               -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/'  \
               -e "/^[^:]*: In function '[^\']*':$/d"                \
            stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/synclines.at:188: cat stdout"
at_fn_check_prepare_trace "synclines.at:188"
( $at_check_trace; cat stdout
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:8: #error \"8\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/synclines.at:188"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_119
#AT_START_120
at_fn_group_banner 120 'headers.at:27' \
  "%union and --defines" "                           " 8
at_xfail=no
(
  $as_echo "120. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%union
{
  int   integer;
  char *string ;
}
%%
exp: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/headers.at:39: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines input.y"
at_fn_check_prepare_notrace 'an embedded newline' "headers.at:39"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:39"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/headers.at:39: bison --xml=xml-tests/test.xml --defines input.y"
at_fn_check_prepare_trace "headers.at:39"
( $at_check_trace; bison --xml=xml-tests/test.xml --defines input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:39"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/headers.at:39: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "headers.at:39"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:39"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/headers.at:39: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "headers.at:39"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:39"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/headers.at:39: bison --defines input.y"
at_fn_check_prepare_trace "headers.at:39"
( $at_check_trace; bison --defines input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:39"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_120
#AT_START_121
at_fn_group_banner 121 'headers.at:77' \
  "Invalid CPP guards: input/input" "                " 8
at_xfail=no
(
  $as_echo "121. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Possibly create inner directories.
dirname=`$as_dirname -- input/input ||
$as_expr Xinput/input : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 Xinput/input : 'X\(//\)[^/]' \| \
	 Xinput/input : 'X\(//\)$' \| \
	 Xinput/input : 'X\(/\)' \| . 2>/dev/null ||
$as_echo Xinput/input |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
as_dir=$dirname; as_fn_mkdir_p

cat >input/input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <input/input.h>
void yyerror (const char *);
int yylex (void);
%}
%%
dummy:;
%%
#include <input/input.h>
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/headers.at:77: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines=input/input.h --output=y.tab.c input/input.y"
at_fn_check_prepare_notrace 'an embedded newline' "headers.at:77"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines=input/input.h --output=y.tab.c input/input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:77"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/headers.at:77: bison --xml=xml-tests/test.xml --defines=input/input.h --output=y.tab.c input/input.y"
at_fn_check_prepare_trace "headers.at:77"
( $at_check_trace; bison --xml=xml-tests/test.xml --defines=input/input.h --output=y.tab.c input/input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:77"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/headers.at:77: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "headers.at:77"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:77"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/headers.at:77: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "headers.at:77"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:77"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/headers.at:77: bison --defines=input/input.h --output=y.tab.c input/input.y"
at_fn_check_prepare_trace "headers.at:77"
( $at_check_trace; bison --defines=input/input.h --output=y.tab.c input/input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:77"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/headers.at:77: \$CC \$CFLAGS \$CPPFLAGS -o y.tab.o -I. -c y.tab.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c" "headers.at:77"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:77"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_121
#AT_START_122
at_fn_group_banner 122 'headers.at:78' \
  "Invalid CPP guards: 9foo" "                       " 8
at_xfail=no
(
  $as_echo "122. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Possibly create inner directories.
dirname=`$as_dirname -- 9foo ||
$as_expr X9foo : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X9foo : 'X\(//\)[^/]' \| \
	 X9foo : 'X\(//\)$' \| \
	 X9foo : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X9foo |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
as_dir=$dirname; as_fn_mkdir_p

cat >9foo.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <9foo.h>
void yyerror (const char *);
int yylex (void);
%}
%%
dummy:;
%%
#include <9foo.h>
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/headers.at:78: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines=9foo.h --output=y.tab.c 9foo.y"
at_fn_check_prepare_notrace 'an embedded newline' "headers.at:78"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines=9foo.h --output=y.tab.c 9foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/headers.at:78: bison --xml=xml-tests/test.xml --defines=9foo.h --output=y.tab.c 9foo.y"
at_fn_check_prepare_trace "headers.at:78"
( $at_check_trace; bison --xml=xml-tests/test.xml --defines=9foo.h --output=y.tab.c 9foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/headers.at:78: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "headers.at:78"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/headers.at:78: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "headers.at:78"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/headers.at:78: bison --defines=9foo.h --output=y.tab.c 9foo.y"
at_fn_check_prepare_trace "headers.at:78"
( $at_check_trace; bison --defines=9foo.h --output=y.tab.c 9foo.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/headers.at:78: \$CC \$CFLAGS \$CPPFLAGS -o y.tab.o -I. -c y.tab.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c" "headers.at:78"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_122
#AT_START_123
at_fn_group_banner 123 'headers.at:87' \
  "export YYLTYPE" "                                 " 8
at_xfail=no
(
  $as_echo "123. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%locations

%name-prefix "my_"
%{
#include <stdio.h>
#include <stdlib.h>

static int
my_lex (void)
{
  return EOF;
}

static void
my_error (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

%}
%%
exp:;
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/headers.at:114: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "headers.at:114"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:114"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/headers.at:114: bison --xml=xml-tests/test.xml --defines -o input.c input.y"
at_fn_check_prepare_trace "headers.at:114"
( $at_check_trace; bison --xml=xml-tests/test.xml --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:114"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/headers.at:114: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "headers.at:114"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:114"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/headers.at:114: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "headers.at:114"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:114"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/headers.at:114: bison --defines -o input.c input.y"
at_fn_check_prepare_trace "headers.at:114"
( $at_check_trace; bison --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:114"
$at_failed && at_fn_log_failure
$at_traceon; }


# YYLTYPE should be defined, and MY_LLOC declared.
cat >caller.c <<'_ATEOF'
#include "input.h"
YYLTYPE *my_llocp = &my_lloc;

int my_parse (void);

int
main (void)
{
  return my_parse ();
}
_ATEOF


# Link and execute, just to make sure everything is fine (and in
# particular, that MY_LLOC is indeed defined somewhere).
{ set +x
$as_echo "$at_srcdir/headers.at:132: \$CC \$CFLAGS \$CPPFLAGS -o caller.o -c caller.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o caller.o -c caller.c" "headers.at:132"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o caller.o -c caller.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:132"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/headers.at:133: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c" "headers.at:133"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:133"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/headers.at:134: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o caller caller.o input.o \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o caller caller.o input.o $LIBS" "headers.at:134"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o caller caller.o input.o $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:134"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/headers.at:135:  \$PREPARSER ./caller"
at_fn_check_prepare_dynamic " $PREPARSER ./caller" "headers.at:135"
( $at_check_trace;  $PREPARSER ./caller
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/headers.at:135"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_123
#AT_START_124
at_fn_group_banner 124 'actions.at:25' \
  "Mid-rule actions" "                               " 9
at_xfail=no
(
  $as_echo "124. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison once forgot the mid-rule actions.  It was because the action
# was attached to the host rule (the one with the mid-rule action),
# instead of being attached to the empty rule dedicated to this
# action.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%define parse.error verbose
%debug
%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
%}
%%
exp:     { putchar ('0'); }
     '1' { putchar ('1'); }
     '2' { putchar ('2'); }
     '3' { putchar ('3'); }
     '4' { putchar ('4'); }
     '5' { putchar ('5'); }
     '6' { putchar ('6'); }
     '7' { putchar ('7'); }
     '8' { putchar ('8'); }
     '9' { putchar ('9'); }
         { putchar ('\n'); }
   ;
%%
static int
yylex (void)
{
  static char const input[] = "123456789";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:78: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -d -v -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:78"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -d -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:78: bison --xml=xml-tests/test.xml -d -v -o input.c input.y"
at_fn_check_prepare_trace "actions.at:78"
( $at_check_trace; bison --xml=xml-tests/test.xml -d -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:78: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:78"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:78: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:78"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:78: bison -d -v -o input.c input.y"
at_fn_check_prepare_trace "actions.at:78"
( $at_check_trace; bison -d -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:78"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:79: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:79"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:79"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:80:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "actions.at:80"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "0123456789
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:80"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_124
#AT_START_125
at_fn_group_banner 125 'actions.at:94' \
  "Exotic Dollars" "                                 " 9
at_xfail=no
(
  $as_echo "125. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%define parse.error verbose
%debug
%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(Var)
%}

%union
{
  int val;
};

%type <val> a_1 a_2 a_5
            sum_of_the_five_previous_values

%%
exp: a_1 a_2 { $<val>$ = 3; } { $<val>$ = $<val>3 + 1; } a_5
     sum_of_the_five_previous_values
    {
       USE (($1, $2, $<foo>3, $<foo>4, $5));
       printf ("%d\n", $6);
    }
;
a_1: { $$ = 1; };
a_2: { $$ = 2; };
a_5: { $$ = 5; };

sum_of_the_five_previous_values:
    {
       $$ = $<val>0 + $<val>-1 + $<val>-2 + $<val>-3 + $<val>-4;
    }
;

%%
static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return EOF;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:156: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -d -v -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:156"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -d -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:156"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:156: bison --xml=xml-tests/test.xml -d -v -o input.c input.y"
at_fn_check_prepare_trace "actions.at:156"
( $at_check_trace; bison --xml=xml-tests/test.xml -d -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:156"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:156: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:156"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:156"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:156: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:156"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:156"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:156: bison -d -v -o input.c input.y"
at_fn_check_prepare_trace "actions.at:156"
( $at_check_trace; bison -d -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:156"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:157: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:157"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:157"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:158:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "actions.at:158"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "15
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:158"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_125
#AT_START_126
at_fn_group_banner 126 'actions.at:571' \
  "Printers and Destructors : " "                    " 9
at_xfail=no
(
  $as_echo "126. $at_setup_line: testing $at_desc ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).first_line, (Location).last_line
}

%define parse.error verbose
%debug
%verbose
%locations



%code {

static int yylex (void);
static void yyerror (const char *msg);
}



/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    fprintf (yyoutput, "%d", $$);
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (void)
{
  static unsigned int counter = 0;

  int c = (yylval) = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (yylloc).first_line = (yylloc).first_column = 10 * c;
  (yylloc).last_line = (yylloc).last_column = (yylloc).first_line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((yylloc)));
  return source[c];
}

static void
yyerror (const char *msg)
{
  printf ("%d-%d: %s\n", RANGE (yylloc), msg);
}

int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:571: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:571"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:571: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:571"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:571: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:571"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:571: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:571"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:571: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:571"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/actions.at:571: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:571"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }




# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ set +x
$as_echo "$at_srcdir/actions.at:571:  \$PREPARSER ./input '(x)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)'" "actions.at:571"
( $at_check_trace;  $PREPARSER ./input '(x)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ set +x
$as_echo "$at_srcdir/actions.at:571:  \$PREPARSER ./input '(y)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(y)'" "actions.at:571"
( $at_check_trace;  $PREPARSER ./input '(y)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ set +x
$as_echo "$at_srcdir/actions.at:571:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(xxxxx)(x)(x)y'" "actions.at:571"
( $at_check_trace;  $PREPARSER ./input '(xxxxx)(x)(x)y'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ set +x
$as_echo "$at_srcdir/actions.at:571:  \$PREPARSER ./input '(x)(x)x'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)(x)x'" "actions.at:571"
( $at_check_trace;  $PREPARSER ./input '(x)(x)x'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.

{ set +x
$as_echo "$at_srcdir/actions.at:571:  \$PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'" "actions.at:571"
( $at_check_trace;  $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: '(' (6@60-69)
sending: 'x' (7@70-79)
thing (7@70-79): 'x' (7@70-79)
sending: ')' (8@80-89)
line (6@60-89): '(' (6@60-69) thing (7@70-79) ')' (8@80-89)
sending: '(' (9@90-99)
sending: 'x' (10@100-109)
thing (10@100-109): 'x' (10@100-109)
sending: ')' (11@110-119)
line (9@90-119): '(' (9@90-99) thing (10@100-109) ')' (11@110-119)
sending: '(' (12@120-129)
sending: 'x' (13@130-139)
thing (13@130-139): 'x' (13@130-139)
sending: ')' (14@140-149)
line (12@120-149): '(' (12@120-129) thing (13@130-139) ')' (14@140-149)
sending: '(' (15@150-159)
sending: 'x' (16@160-169)
thing (16@160-169): 'x' (16@160-169)
sending: ')' (17@170-179)
line (15@150-179): '(' (15@150-159) thing (16@160-169) ')' (17@170-179)
sending: '(' (18@180-189)
sending: 'x' (19@190-199)
thing (19@190-199): 'x' (19@190-199)
sending: ')' (20@200-209)
200-209: memory exhausted
Freeing nterm thing (19@190-199)
Freeing nterm line (15@150-179)
Freeing nterm line (12@120-149)
Freeing nterm line (9@90-119)
Freeing nterm line (6@60-89)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Parsing FAILED (status 2).
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 2 $at_status "$at_srcdir/actions.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }





  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_126
#AT_START_127
at_fn_group_banner 127 'actions.at:572' \
  "Printers and Destructors with union: " "          " 9
at_xfail=no
(
  $as_echo "127. $at_setup_line: testing $at_desc ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).first_line, (Location).last_line
}

%define parse.error verbose
%debug
%verbose
%locations

%union
{
  int ival;
}

%code provides {

static int yylex (void);
static void yyerror (const char *msg);
}

%type <ival> '(' 'x' 'y' ')' ';' thing line input END

/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    fprintf (yyoutput, "%d", $$);
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (void)
{
  static unsigned int counter = 0;

  int c = (yylval).ival = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (yylloc).first_line = (yylloc).first_column = 10 * c;
  (yylloc).last_line = (yylloc).last_column = (yylloc).first_line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((yylloc)));
  return source[c];
}

static void
yyerror (const char *msg)
{
  printf ("%d-%d: %s\n", RANGE (yylloc), msg);
}

int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:572: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:572"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:572: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:572"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:572: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:572"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:572: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:572"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:572: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:572"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/actions.at:572: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:572"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }




# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ set +x
$as_echo "$at_srcdir/actions.at:572:  \$PREPARSER ./input '(x)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)'" "actions.at:572"
( $at_check_trace;  $PREPARSER ./input '(x)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ set +x
$as_echo "$at_srcdir/actions.at:572:  \$PREPARSER ./input '(y)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(y)'" "actions.at:572"
( $at_check_trace;  $PREPARSER ./input '(y)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ set +x
$as_echo "$at_srcdir/actions.at:572:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(xxxxx)(x)(x)y'" "actions.at:572"
( $at_check_trace;  $PREPARSER ./input '(xxxxx)(x)(x)y'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ set +x
$as_echo "$at_srcdir/actions.at:572:  \$PREPARSER ./input '(x)(x)x'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)(x)x'" "actions.at:572"
( $at_check_trace;  $PREPARSER ./input '(x)(x)x'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.

{ set +x
$as_echo "$at_srcdir/actions.at:572:  \$PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'" "actions.at:572"
( $at_check_trace;  $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: '(' (6@60-69)
sending: 'x' (7@70-79)
thing (7@70-79): 'x' (7@70-79)
sending: ')' (8@80-89)
line (6@60-89): '(' (6@60-69) thing (7@70-79) ')' (8@80-89)
sending: '(' (9@90-99)
sending: 'x' (10@100-109)
thing (10@100-109): 'x' (10@100-109)
sending: ')' (11@110-119)
line (9@90-119): '(' (9@90-99) thing (10@100-109) ')' (11@110-119)
sending: '(' (12@120-129)
sending: 'x' (13@130-139)
thing (13@130-139): 'x' (13@130-139)
sending: ')' (14@140-149)
line (12@120-149): '(' (12@120-129) thing (13@130-139) ')' (14@140-149)
sending: '(' (15@150-159)
sending: 'x' (16@160-169)
thing (16@160-169): 'x' (16@160-169)
sending: ')' (17@170-179)
line (15@150-179): '(' (15@150-159) thing (16@160-169) ')' (17@170-179)
sending: '(' (18@180-189)
sending: 'x' (19@190-199)
thing (19@190-199): 'x' (19@190-199)
sending: ')' (20@200-209)
200-209: memory exhausted
Freeing nterm thing (19@190-199)
Freeing nterm line (15@150-179)
Freeing nterm line (12@120-149)
Freeing nterm line (9@90-119)
Freeing nterm line (6@60-89)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Parsing FAILED (status 2).
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 2 $at_status "$at_srcdir/actions.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }





  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_127
#AT_START_128
at_fn_group_banner 128 'actions.at:574' \
  "Printers and Destructors : %defines %skeleton \"lalr1.cc\"" "" 9
at_xfail=no
(
  $as_echo "128. $at_setup_line: testing $at_desc ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).begin.line, (Location).end.line
}

%define parse.error verbose
%debug
%verbose
%locations
%defines %skeleton "lalr1.cc"

%define global_tokens_and_yystype
%code {
typedef yy::location YYLTYPE;
static int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);

}



/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    debug_stream () << $$;;
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static unsigned int counter = 0;

  int c = (*lvalp) = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (*llocp).begin.line = (*llocp).begin.column = 10 * c;
  (*llocp).end.line = (*llocp).end.column = (*llocp).begin.line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((*llocp)));
  return source[c];
}

/* A C++ error reporting function. */
void
yy::parser::error (const location& l, const std::string& m)
{
  printf ("%d-%d: %s\n", RANGE (l), m.c_str());
}

static bool yydebug;
int
yyparse ()
{
  yy::parser parser;
  parser.set_debug_level (yydebug);
  return parser.parse ();
}


int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:574: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:574"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:574: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "actions.at:574"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:574: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:574"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:574: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:574"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:574: bison -o input.cc input.y"
at_fn_check_prepare_trace "actions.at:574"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/actions.at:574: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "actions.at:574"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:574: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "actions.at:574"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }




# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ set +x
$as_echo "$at_srcdir/actions.at:574:  \$PREPARSER ./input '(x)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)'" "actions.at:574"
( $at_check_trace;  $PREPARSER ./input '(x)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ set +x
$as_echo "$at_srcdir/actions.at:574:  \$PREPARSER ./input '(y)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(y)'" "actions.at:574"
( $at_check_trace;  $PREPARSER ./input '(y)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ set +x
$as_echo "$at_srcdir/actions.at:574:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(xxxxx)(x)(x)y'" "actions.at:574"
( $at_check_trace;  $PREPARSER ./input '(xxxxx)(x)(x)y'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ set +x
$as_echo "$at_srcdir/actions.at:574:  \$PREPARSER ./input '(x)(x)x'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)(x)x'" "actions.at:574"
( $at_check_trace;  $PREPARSER ./input '(x)(x)x'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:574"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.




  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_128
#AT_START_129
at_fn_group_banner 129 'actions.at:575' \
  "Printers and Destructors with union: %defines %skeleton \"lalr1.cc\"" "" 9
at_xfail=no
(
  $as_echo "129. $at_setup_line: testing $at_desc ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).begin.line, (Location).end.line
}

%define parse.error verbose
%debug
%verbose
%locations
%defines %skeleton "lalr1.cc"
%union
{
  int ival;
}
%define global_tokens_and_yystype
%code provides {
typedef yy::location YYLTYPE;
static int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);

}

%type <ival> '(' 'x' 'y' ')' ';' thing line input END

/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    debug_stream () << $$;;
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static unsigned int counter = 0;

  int c = (*lvalp).ival = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (*llocp).begin.line = (*llocp).begin.column = 10 * c;
  (*llocp).end.line = (*llocp).end.column = (*llocp).begin.line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((*llocp)));
  return source[c];
}

/* A C++ error reporting function. */
void
yy::parser::error (const location& l, const std::string& m)
{
  printf ("%d-%d: %s\n", RANGE (l), m.c_str());
}

static bool yydebug;
int
yyparse ()
{
  yy::parser parser;
  parser.set_debug_level (yydebug);
  return parser.parse ();
}


int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:575: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:575"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:575: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "actions.at:575"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:575: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:575"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:575: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:575"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:575: bison -o input.cc input.y"
at_fn_check_prepare_trace "actions.at:575"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/actions.at:575: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "actions.at:575"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:575: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "actions.at:575"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }




# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ set +x
$as_echo "$at_srcdir/actions.at:575:  \$PREPARSER ./input '(x)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)'" "actions.at:575"
( $at_check_trace;  $PREPARSER ./input '(x)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ set +x
$as_echo "$at_srcdir/actions.at:575:  \$PREPARSER ./input '(y)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(y)'" "actions.at:575"
( $at_check_trace;  $PREPARSER ./input '(y)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ set +x
$as_echo "$at_srcdir/actions.at:575:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(xxxxx)(x)(x)y'" "actions.at:575"
( $at_check_trace;  $PREPARSER ./input '(xxxxx)(x)(x)y'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ set +x
$as_echo "$at_srcdir/actions.at:575:  \$PREPARSER ./input '(x)(x)x'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)(x)x'" "actions.at:575"
( $at_check_trace;  $PREPARSER ./input '(x)(x)x'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.




  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_129
#AT_START_130
at_fn_group_banner 130 'actions.at:577' \
  "Printers and Destructors : %glr-parser" "         " 9
at_xfail=no
(
  $as_echo "130. $at_setup_line: testing $at_desc ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).first_line, (Location).last_line
}

%define parse.error verbose
%debug
%verbose
%locations
%glr-parser


%code {

static int yylex (void);
static void yyerror (const char *msg);
}



/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    fprintf (yyoutput, "%d", $$);
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (void)
{
  static unsigned int counter = 0;

  int c = (yylval) = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (yylloc).first_line = (yylloc).first_column = 10 * c;
  (yylloc).last_line = (yylloc).last_column = (yylloc).first_line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((yylloc)));
  return source[c];
}

static void
yyerror (const char *msg)
{
  printf ("%d-%d: %s\n", RANGE (yylloc), msg);
}

int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:577: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:577"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:577: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:577"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:577: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:577"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:577: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:577"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:577: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:577"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/actions.at:577: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:577"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }




# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ set +x
$as_echo "$at_srcdir/actions.at:577:  \$PREPARSER ./input '(x)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)'" "actions.at:577"
( $at_check_trace;  $PREPARSER ./input '(x)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ set +x
$as_echo "$at_srcdir/actions.at:577:  \$PREPARSER ./input '(y)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(y)'" "actions.at:577"
( $at_check_trace;  $PREPARSER ./input '(y)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ set +x
$as_echo "$at_srcdir/actions.at:577:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(xxxxx)(x)(x)y'" "actions.at:577"
( $at_check_trace;  $PREPARSER ./input '(xxxxx)(x)(x)y'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ set +x
$as_echo "$at_srcdir/actions.at:577:  \$PREPARSER ./input '(x)(x)x'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)(x)x'" "actions.at:577"
( $at_check_trace;  $PREPARSER ./input '(x)(x)x'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.




  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_130
#AT_START_131
at_fn_group_banner 131 'actions.at:578' \
  "Printers and Destructors with union: %glr-parser" "" 9
at_xfail=no
(
  $as_echo "131. $at_setup_line: testing $at_desc ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).first_line, (Location).last_line
}

%define parse.error verbose
%debug
%verbose
%locations
%glr-parser
%union
{
  int ival;
}

%code provides {

static int yylex (void);
static void yyerror (const char *msg);
}

%type <ival> '(' 'x' 'y' ')' ';' thing line input END

/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    fprintf (yyoutput, "%d", $$);
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (void)
{
  static unsigned int counter = 0;

  int c = (yylval).ival = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (yylloc).first_line = (yylloc).first_column = 10 * c;
  (yylloc).last_line = (yylloc).last_column = (yylloc).first_line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((yylloc)));
  return source[c];
}

static void
yyerror (const char *msg)
{
  printf ("%d-%d: %s\n", RANGE (yylloc), msg);
}

int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:578: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:578"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:578: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:578"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:578: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:578"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:578: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:578"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:578: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:578"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/actions.at:578: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:578"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }




# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ set +x
$as_echo "$at_srcdir/actions.at:578:  \$PREPARSER ./input '(x)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)'" "actions.at:578"
( $at_check_trace;  $PREPARSER ./input '(x)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ set +x
$as_echo "$at_srcdir/actions.at:578:  \$PREPARSER ./input '(y)'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(y)'" "actions.at:578"
( $at_check_trace;  $PREPARSER ./input '(y)'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ set +x
$as_echo "$at_srcdir/actions.at:578:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(xxxxx)(x)(x)y'" "actions.at:578"
( $at_check_trace;  $PREPARSER ./input '(xxxxx)(x)(x)y'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ set +x
$as_echo "$at_srcdir/actions.at:578:  \$PREPARSER ./input '(x)(x)x'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '(x)(x)x'" "actions.at:578"
( $at_check_trace;  $PREPARSER ./input '(x)(x)x'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.




  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_131
#AT_START_132
at_fn_group_banner 132 'actions.at:589' \
  "Default tagless %printer and %destructor" "       " 9
at_xfail=no
(
  $as_echo "132. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%define parse.error verbose
%debug
%locations
%initial-action {
  @$.first_line = @$.last_line = 1;
  @$.first_column = @$.last_column = 1;
}

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%printer {
  fprintf (yyoutput, "<*> printer should not be called.\n");
} <*>

%printer {
  fprintf (yyoutput, "<> printer for '%c' @ %d", $$, @$.first_column);
} <>
%destructor {
  fprintf (stdout, "<> destructor for '%c' @ %d.\n", $$, @$.first_column);
} <>

%printer {
  fprintf (yyoutput, "'b'/'c' printer for '%c' @ %d", $$, @$.first_column);
} 'b' 'c'
%destructor {
  fprintf (stdout, "'b'/'c' destructor for '%c' @ %d.\n", $$, @$.first_column);
} 'b' 'c'

%destructor {
  fprintf (yyoutput, "<*> destructor should not be called.\n");
} <*>

%%

start: 'a' 'b' 'c' 'd' 'e' { $$ = 'S'; USE(($1, $2, $3, $4, $5)); } ;

%%

static int
yylex (void)
{
  static char const input[] = "abcd";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylval = input[toknum++];
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = toknum;
  return yylval;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:663: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:663"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:663"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:663: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:663"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:663"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:663: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:663"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:663"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:663: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:663"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:663"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:663: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:663"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:663"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:664: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:664"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:665:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "actions.at:665"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reading a token: Next token is token 'a' (1.1-1.1: <> printer for 'a' @ 1)
Shifting token 'a' (1.1-1.1: <> printer for 'a' @ 1)
Entering state 1
Reading a token: Next token is token 'b' (1.2-1.2: 'b'/'c' printer for 'b' @ 2)
Shifting token 'b' (1.2-1.2: 'b'/'c' printer for 'b' @ 2)
Entering state 3
Reading a token: Next token is token 'c' (1.3-1.3: 'b'/'c' printer for 'c' @ 3)
Shifting token 'c' (1.3-1.3: 'b'/'c' printer for 'c' @ 3)
Entering state 5
Reading a token: Next token is token 'd' (1.4-1.4: <> printer for 'd' @ 4)
Shifting token 'd' (1.4-1.4: <> printer for 'd' @ 4)
Entering state 6
Reading a token: Now at end of input.
syntax error, unexpected \$end, expecting 'e'
Error: popping token 'd' (1.4-1.4: <> printer for 'd' @ 4)
Stack now 0 1 3 5
Error: popping token 'c' (1.3-1.3: 'b'/'c' printer for 'c' @ 3)
Stack now 0 1 3
Error: popping token 'b' (1.2-1.2: 'b'/'c' printer for 'b' @ 2)
Stack now 0 1
Error: popping token 'a' (1.1-1.1: <> printer for 'a' @ 1)
Stack now 0
Cleanup: discarding lookahead token \$end (1.5-1.5: )
Stack now 0
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "<> destructor for 'd' @ 4.
'b'/'c' destructor for 'c' @ 3.
'b'/'c' destructor for 'b' @ 2.
<> destructor for 'a' @ 1.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_132
#AT_START_133
at_fn_group_banner 133 'actions.at:707' \
  "Default tagged and per-type %printer and %destructor" "" 9
at_xfail=no
(
  $as_echo "133. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%define parse.error verbose
%debug

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%printer {
  fprintf (yyoutput, "<> printer should not be called.\n");
} <>

%union { int field0; int field1; int field2; }
%type <field0> start 'a' 'g'
%type <field1> 'e'
%type <field2> 'f'
%printer {
  fprintf (yyoutput, "<*>/<field2>/e printer");
} <*> 'e' <field2>
%destructor {
  fprintf (stdout, "<*>/<field2>/e destructor.\n");
} <*> 'e' <field2>

%type <field1> 'b'
%printer { fprintf (yyoutput, "<field1> printer"); } <field1>
%destructor { fprintf (stdout, "<field1> destructor.\n"); } <field1>

%type <field0> 'c'
%printer { fprintf (yyoutput, "'c' printer"); } 'c'
%destructor { fprintf (stdout, "'c' destructor.\n"); } 'c'

%type <field1> 'd'
%printer { fprintf (yyoutput, "'d' printer"); } 'd'
%destructor { fprintf (stdout, "'d' destructor.\n"); } 'd'

%destructor {
  fprintf (yyoutput, "<> destructor should not be called.\n");
} <>

%%

start:
  'a' 'b' 'c' 'd' 'e' 'f' 'g'
    {
      USE(($1, $2, $3, $4, $5, $6, $7));
      $$ = 'S';
    }
  ;

%%

static int
yylex (void)
{
  static char const input[] = "abcdef";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:788: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:788"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:788"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:788: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:788"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:788"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:788: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:788"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:788"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:788: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:788"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:788"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:788: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:788"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:788"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:789: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:789"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:789"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:790:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "actions.at:790"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reading a token: Next token is token 'a' (<*>/<field2>/e printer)
Shifting token 'a' (<*>/<field2>/e printer)
Entering state 1
Reading a token: Next token is token 'b' (<field1> printer)
Shifting token 'b' (<field1> printer)
Entering state 3
Reading a token: Next token is token 'c' ('c' printer)
Shifting token 'c' ('c' printer)
Entering state 5
Reading a token: Next token is token 'd' ('d' printer)
Shifting token 'd' ('d' printer)
Entering state 6
Reading a token: Next token is token 'e' (<*>/<field2>/e printer)
Shifting token 'e' (<*>/<field2>/e printer)
Entering state 7
Reading a token: Next token is token 'f' (<*>/<field2>/e printer)
Shifting token 'f' (<*>/<field2>/e printer)
Entering state 8
Reading a token: Now at end of input.
syntax error, unexpected \$end, expecting 'g'
Error: popping token 'f' (<*>/<field2>/e printer)
Stack now 0 1 3 5 6 7
Error: popping token 'e' (<*>/<field2>/e printer)
Stack now 0 1 3 5 6
Error: popping token 'd' ('d' printer)
Stack now 0 1 3 5
Error: popping token 'c' ('c' printer)
Stack now 0 1 3
Error: popping token 'b' (<field1> printer)
Stack now 0 1
Error: popping token 'a' (<*>/<field2>/e printer)
Stack now 0
Cleanup: discarding lookahead token \$end ()
Stack now 0
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "<*>/<field2>/e destructor.
<*>/<field2>/e destructor.
'd' destructor.
'c' destructor.
<field1> destructor.
<*>/<field2>/e destructor.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:790"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_133
#AT_START_134
at_fn_group_banner 134 'actions.at:844' \
  "Default %printer and %destructor for user-defined end token" "" 9
at_xfail=no
(
  $as_echo "134. $at_setup_line: testing $at_desc ..."
  $at_traceon


# _AT_CHECK_DEFAULT_PRINTER_AND_DESTRUCTOR_FOR_END_TOKEN(TYPED)
# -----------------------------------------------------------------------------




cat >input0.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%define parse.error verbose
%debug
%locations
%initial-action {
  @$.first_line = @$.last_line = 1;
  @$.first_column = @$.last_column = 1;
}

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%destructor {
  fprintf (yyoutput, "<*> destructor should not be called.\n");
} <*>

%token END 0
%printer {
  fprintf (yyoutput, "<> for '%c' @ %d", $$, @$.first_column);
} <>
%destructor {
  fprintf (stdout, "<> for '%c' @ %d.\n", $$, @$.first_column);
} <>

%printer {
  fprintf (yyoutput, "<*> printer should not be called.\n");
} <*>




%%

start: { $$ = 'S'; } ;

%%

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  yylval = 'E';
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = 1;
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:947: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input0.c input0.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:947"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input0.c input0.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:947"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:947: bison --xml=xml-tests/test.xml -o input0.c input0.y"
at_fn_check_prepare_trace "actions.at:947"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input0.c input0.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:947"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:947: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:947"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:947"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:947: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:947"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:947"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:947: bison -o input0.c input0.y"
at_fn_check_prepare_trace "actions.at:947"
( $at_check_trace; bison -o input0.c input0.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:947"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:947: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input0 input0.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input0 input0.c $LIBS" "actions.at:947"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input0 input0.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:947"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:947:  \$PREPARSER ./input0"
at_fn_check_prepare_dynamic " $PREPARSER ./input0" "actions.at:947"
( $at_check_trace;  $PREPARSER ./input0
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reducing stack by rule 1 (line 46):
-> \$\$ = nterm start (1.1-1.1: <> for 'S' @ 1)
Stack now 0
Entering state 1
Reading a token: Now at end of input.
Shifting token END (1.1-1.1: <> for 'E' @ 1)
Entering state 2
Stack now 0 1 2
Cleanup: popping token END (1.1-1.1: <> for 'E' @ 1)
Cleanup: popping nterm start (1.1-1.1: <> for 'S' @ 1)
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "<> for 'E' @ 1.
<> for 'S' @ 1.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:947"
$at_failed && at_fn_log_failure
$at_traceon; }







cat >input1.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%define parse.error verbose
%debug
%locations
%initial-action {
  @$.first_line = @$.last_line = 1;
  @$.first_column = @$.last_column = 1;
}

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%destructor {
  fprintf (yyoutput, "<> destructor should not be called.\n");
} <>

%token END 0
%printer {
  fprintf (yyoutput, "<*> for '%c' @ %d", $$, @$.first_column);
} <*>
%destructor {
  fprintf (stdout, "<*> for '%c' @ %d.\n", $$, @$.first_column);
} <*>

%printer {
  fprintf (yyoutput, "<> printer should not be called.\n");
} <>

%union { char tag; }
%type <tag> start END

%%

start: { $$ = 'S'; } ;

%%

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  yylval.tag = 'E';
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = 1;
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:948: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input1.c input1.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:948"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input1.c input1.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:948"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:948: bison --xml=xml-tests/test.xml -o input1.c input1.y"
at_fn_check_prepare_trace "actions.at:948"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input1.c input1.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:948"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:948: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:948"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:948"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:948: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:948"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:948"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:948: bison -o input1.c input1.y"
at_fn_check_prepare_trace "actions.at:948"
( $at_check_trace; bison -o input1.c input1.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:948"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:948: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input1 input1.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input1 input1.c $LIBS" "actions.at:948"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input1 input1.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:948"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:948:  \$PREPARSER ./input1"
at_fn_check_prepare_dynamic " $PREPARSER ./input1" "actions.at:948"
( $at_check_trace;  $PREPARSER ./input1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reducing stack by rule 1 (line 46):
-> \$\$ = nterm start (1.1-1.1: <*> for 'S' @ 1)
Stack now 0
Entering state 1
Reading a token: Now at end of input.
Shifting token END (1.1-1.1: <*> for 'E' @ 1)
Entering state 2
Stack now 0 1 2
Cleanup: popping token END (1.1-1.1: <*> for 'E' @ 1)
Cleanup: popping nterm start (1.1-1.1: <*> for 'S' @ 1)
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "<*> for 'E' @ 1.
<*> for 'S' @ 1.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:948"
$at_failed && at_fn_log_failure
$at_traceon; }






  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_134
#AT_START_135
at_fn_group_banner 135 'actions.at:958' \
  "Default %printer and %destructor are not for error or \$undefined" "" 9
at_xfail=no
(
  $as_echo "135. $at_setup_line: testing $at_desc ..."
  $at_traceon


# If Bison were to apply the default %printer and %destructor to the error
# token or to $undefined:
#   - For the error token:
#     - It would generate warnings for unused $n.
#     - It would invoke the %printer and %destructor on the error token's
#       semantic value, which would be initialized from the lookahead, which
#       would be destroyed separately.
#   - For $undefined, who knows what the semantic value would be.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%printer {
  fprintf (yyoutput, "'%c'", $$);
} <> <*>
%destructor {
  fprintf (stderr, "DESTROY '%c'\n", $$);
} <> <*>

%%

start:
  { $$ = 'S'; }
  /* In order to reveal the problems that this bug caused during parsing, add
   * $2 to USE.  */
  | 'a' error 'b' 'c' { USE(($1, $3, $4)); $$ = 'S'; }
  ;

%%

static int
yylex (void)
{
  static char const input[] = "abd";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylval = input[toknum++];
  return yylval;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:1023: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1023"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1023"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:1023: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1023"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1023"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:1023: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1023"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1023"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:1023: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1023"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1023"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:1023: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1023"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1023"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1024: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:1024"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1024"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1025:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "actions.at:1025"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reading a token: Next token is token 'a' ('a')
Shifting token 'a' ('a')
Entering state 1
Reading a token: Next token is token 'b' ('b')
syntax error
Shifting token error ()
Entering state 3
Next token is token 'b' ('b')
Shifting token 'b' ('b')
Entering state 5
Reading a token: Next token is token \$undefined ()
Error: popping token 'b' ('b')
DESTROY 'b'
Stack now 0 1 3
Error: popping token error ()
Stack now 0 1
Shifting token error ()
Entering state 3
Next token is token \$undefined ()
Error: discarding token \$undefined ()
Error: popping token error ()
Stack now 0 1
Shifting token error ()
Entering state 3
Reading a token: Now at end of input.
Cleanup: discarding lookahead token \$end ()
Stack now 0 1 3
Cleanup: popping token error ()
Cleanup: popping token 'a' ('a')
DESTROY 'a'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:1025"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_135
#AT_START_136
at_fn_group_banner 136 'actions.at:1068' \
  "Default %printer and %destructor are not for \$accept" "" 9
at_xfail=no
(
  $as_echo "136. $at_setup_line: testing $at_desc ..."
  $at_traceon


# If YYSTYPE is a union and Bison were to apply the default %printer and
# %destructor to $accept:
#   - The %printer and %destructor code generated for $accept would always be
#     dead code because $accept is currently never shifted onto the stack.
#   - $$ for $accept would always be of type YYSTYPE because it's not possible
#     to declare `%type <field> $accept'.  (Also true for $undefined.)
#   - Thus, the compiler might complain that the user code assumes the wrong
#     type for $$ since the code might assume the type associated with a
#     specific union field, which is especially reasonable in C++ since that
#     type may be a base type.  This test case checks for this problem.  (Also
#     true for $undefined and the error token, so there are three warnings for
#     %printer and three for %destructor.)

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug /* So that %printer is actually compiled.  */

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%printer {
  char chr = $$;
  fprintf (yyoutput, "'%c'", chr);
} <> <*>
%destructor {
  char chr = $$;
  fprintf (stderr, "DESTROY '%c'\n", chr);
} <> <*>

%union { char chr; }
%type <chr> start

%%

start: { USE($$); } ;

%%

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:1134: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1134"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1134"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:1134: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1134"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1134"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:1134: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1134"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1134"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:1134: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1134"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1134"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:1134: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1134"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1134"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1135: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:1135"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1135"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_136
#AT_START_137
at_fn_group_banner 137 'actions.at:1145' \
  "Default %printer and %destructor for mid-rule values" "" 9
at_xfail=no
(
  $as_echo "137. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug /* So that %printer is actually compiled.  */

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
# define YYLTYPE int
# define YYLLOC_DEFAULT(Current, Rhs, N)
# define YY_LOCATION_PRINT(File, Loc)
%}

%printer { fprintf (yyoutput, "%d", @$); } <>
%destructor { fprintf (stderr, "DESTROY %d\n", @$); } <>
%printer { fprintf (yyoutput, "<*> printer should not be called"); } <*>
%destructor { fprintf (yyoutput, "<*> destructor should not be called"); } <*>

%%

start:
  {           @$ = 1; } // Not set or used.
  { USE ($$); @$ = 2; } // Both set and used.
  { USE ($$); @$ = 3; } // Only set.
  {           @$ = 4; } // Only used.
  'c'
  { USE (($$, $2, $4, $5)); @$ = 0; }
  ;

%%

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:1202: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1202"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1202"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:1202: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1202"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1202"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:1202: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1202"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1202"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:1202: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1202"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1202"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:1202: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1202"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:33.3-23: warning: unset value: \$\$
input.y:30.3-35.37: warning: unused value: \$3
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1202"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/actions.at:1207: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:1207"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1207"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1208:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "actions.at:1208"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reducing stack by rule 1 (line 30):
-> \$\$ = nterm \$@1 (: )
Stack now 0
Entering state 2
Reducing stack by rule 2 (line 31):
-> \$\$ = nterm @2 (: 2)
Stack now 0 2
Entering state 4
Reducing stack by rule 3 (line 32):
-> \$\$ = nterm @3 (: 3)
Stack now 0 2 4
Entering state 5
Reducing stack by rule 4 (line 33):
-> \$\$ = nterm @4 (: 4)
Stack now 0 2 4 5
Entering state 6
Reading a token: Now at end of input.
syntax error
Error: popping nterm @4 (: 4)
DESTROY 4
Stack now 0 2 4 5
Error: popping nterm @3 (: 3)
DESTROY 3
Stack now 0 2 4
Error: popping nterm @2 (: 2)
DESTROY 2
Stack now 0 2
Error: popping nterm \$@1 (: )
Stack now 0
Cleanup: discarding lookahead token \$end (: )
Stack now 0
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/actions.at:1208"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_137
#AT_START_138
at_fn_group_banner 138 'actions.at:1301' \
  "@\$ in %initial-action implies %locations" "       " 9
at_xfail=no
(
  $as_echo "138. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static int yylex (void);
  static void yyerror (char const *msg);
}

%debug

%initial-action {
  printf ("%d\n", @$.first_line);
}

%%

start:  ;

%%

static int
yylex (void)
{
  return 0;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:1301: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1301"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1301"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:1301: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1301"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1301"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:1301: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1301"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1301"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:1301: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1301"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1301"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:1301: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1301"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1301"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1301: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:1301"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1301"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_138
#AT_START_139
at_fn_group_banner 139 'actions.at:1302' \
  "@\$ in %destructor implies %locations" "           " 9
at_xfail=no
(
  $as_echo "139. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static int yylex (void);
  static void yyerror (char const *msg);
}

%debug

%destructor {
  printf ("%d\n", @$.first_line);
} start

%%

start:  ;

%%

static int
yylex (void)
{
  return 0;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:1302: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1302"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1302"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:1302: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1302"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1302"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:1302: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1302"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1302"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:1302: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1302"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1302"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:1302: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1302"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1302"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1302: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:1302"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1302"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_139
#AT_START_140
at_fn_group_banner 140 'actions.at:1303' \
  "@\$ in %printer implies %locations" "              " 9
at_xfail=no
(
  $as_echo "140. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static int yylex (void);
  static void yyerror (char const *msg);
}

%debug

%printer {
  printf ("%d\n", @$.first_line);
} start

%%

start:  ;

%%

static int
yylex (void)
{
  return 0;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:1303: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1303"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1303"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:1303: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1303"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1303"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:1303: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1303"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1303"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:1303: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1303"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1303"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:1303: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1303"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1303"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1303: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:1303"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1303"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_140
#AT_START_141
at_fn_group_banner 141 'actions.at:1310' \
  "Fix user actions without a trailing semicolon" "  " 9
at_xfail=no
(
  $as_echo "141. $at_setup_line: testing $at_desc ..."
  $at_traceon


# This feature is undocumented, but we accidentally broke it in 2.3a,
# and there was a complaint at:
# <http://lists.gnu.org/archive/html/bug-bison/2008-11/msg00001.html>.

cat >input.y <<'_ATEOF'
%%
start: test2 test1 test0 testc;

test2
: 'a' { semi;			/* TEST:N:2 */ }
| 'b' { if (0) {no_semi}	/* TEST:N:2 */ }
| 'c' { if (0) {semi;}		/* TEST:N:2 */ }
| 'd' { semi;   no_semi		/* TEST:Y:2 */ }
| 'e' { semi(); no_semi()	/* TEST:Y:2 */ }
| 'f' { semi[]; no_semi[]	/* TEST:Y:2 */ }
| 'g' { semi++; no_semi++	/* TEST:Y:2 */ }
| 'h' { {no_semi} no_semi	/* TEST:Y:2 */ }
| 'i' { {semi;}   no_semi	/* TEST:Y:2 */ }
;
test1
  : 'a' { semi;			// TEST:N:1 ;
} | 'b' { if (0) {no_semi}	// TEST:N:1 ;
} | 'c' { if (0) {semi;}	// TEST:N:1 ;
} | 'd' { semi;   no_semi	// TEST:Y:1 ;
} | 'e' { semi(); no_semi()	// TEST:Y:1 ;
} | 'f' { semi[]; no_semi[]	// TEST:Y:1 ;
} | 'g' { semi++; no_semi++	// TEST:Y:1 ;
} | 'h' { {no_semi} no_semi	// TEST:Y:1 ;
} | 'i' { {semi;}   no_semi	// TEST:Y:1 ;
} ;
test0
  : 'a' { semi;			// TEST:N:1 {}
} | 'b' { if (0) {no_semi}	// TEST:N:1 {}
} | 'c' { if (0) {semi;}	// TEST:N:1 {}
} | 'd' { semi;   no_semi	// TEST:Y:1 {}
} | 'e' { semi(); no_semi()	// TEST:Y:1 {}
} | 'f' { semi[]; no_semi[]	// TEST:Y:1 {}
} | 'g' { semi++; no_semi++	// TEST:Y:1 {}
} | 'h' { {no_semi} no_semi	// TEST:Y:1 {}
} | 'i' { {semi;}   no_semi	// TEST:Y:1 {}
} ;

testc
: 'a' {
#define TEST_MACRO_N \
[]"broken\" $ @ $$ @$ [];\
string;"}
| 'b' {
no_semi
#define TEST_MACRO_N \
[]"broken\" $ @ $$ @$ [];\
string;"}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:1366: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1366"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1366"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:1366: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1366"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1366"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:1366: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1366"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1366"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:1366: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1366"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1366"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:1366: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1366"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:8.48: warning: a \`;' might be needed at the end of action code
input.y:8.48: warning: future versions of Bison will not add the \`;'
input.y:9.48: warning: a \`;' might be needed at the end of action code
input.y:9.48: warning: future versions of Bison will not add the \`;'
input.y:10.48: warning: a \`;' might be needed at the end of action code
input.y:10.48: warning: future versions of Bison will not add the \`;'
input.y:11.48: warning: a \`;' might be needed at the end of action code
input.y:11.48: warning: future versions of Bison will not add the \`;'
input.y:12.48: warning: a \`;' might be needed at the end of action code
input.y:12.48: warning: future versions of Bison will not add the \`;'
input.y:13.48: warning: a \`;' might be needed at the end of action code
input.y:13.48: warning: future versions of Bison will not add the \`;'
input.y:20.1: warning: a \`;' might be needed at the end of action code
input.y:20.1: warning: future versions of Bison will not add the \`;'
input.y:21.1: warning: a \`;' might be needed at the end of action code
input.y:21.1: warning: future versions of Bison will not add the \`;'
input.y:22.1: warning: a \`;' might be needed at the end of action code
input.y:22.1: warning: future versions of Bison will not add the \`;'
input.y:23.1: warning: a \`;' might be needed at the end of action code
input.y:23.1: warning: future versions of Bison will not add the \`;'
input.y:24.1: warning: a \`;' might be needed at the end of action code
input.y:24.1: warning: future versions of Bison will not add the \`;'
input.y:25.1: warning: a \`;' might be needed at the end of action code
input.y:25.1: warning: future versions of Bison will not add the \`;'
input.y:31.1: warning: a \`;' might be needed at the end of action code
input.y:31.1: warning: future versions of Bison will not add the \`;'
input.y:32.1: warning: a \`;' might be needed at the end of action code
input.y:32.1: warning: future versions of Bison will not add the \`;'
input.y:33.1: warning: a \`;' might be needed at the end of action code
input.y:33.1: warning: future versions of Bison will not add the \`;'
input.y:34.1: warning: a \`;' might be needed at the end of action code
input.y:34.1: warning: future versions of Bison will not add the \`;'
input.y:35.1: warning: a \`;' might be needed at the end of action code
input.y:35.1: warning: future versions of Bison will not add the \`;'
input.y:36.1: warning: a \`;' might be needed at the end of action code
input.y:36.1: warning: future versions of Bison will not add the \`;'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1366"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/actions.at:1405: perl -0777 -ne '
my \$count = 0;
s{/\\* TEST:N:2 \\*/ \\}\$}{ ++\$count; \"\" }gem;
printf \"\$count\\n\";' input.c"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1405"
( $at_check_trace; perl -0777 -ne '
my $count = 0;
s{/\* TEST:N:2 \*/ \}$}{ ++$count; "" }gem;
printf "$count\n";' input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1405"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1406: perl -0777 -ne '
my \$count = 0;
s{/\\* TEST:Y:2 \\*/ ;\\}\$}{ ++\$count; \"\" }gem;
printf \"\$count\\n\";' input.c"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1406"
( $at_check_trace; perl -0777 -ne '
my $count = 0;
s{/\* TEST:Y:2 \*/ ;\}$}{ ++$count; "" }gem;
printf "$count\n";' input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "6
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1406"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1407: perl -0777 -ne '
my \$count = 0;
s{// TEST:N:1 [;{}]*\\n\\}\$}{ ++\$count; \"\" }gem;
printf \"\$count\\n\";' input.c"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1407"
( $at_check_trace; perl -0777 -ne '
my $count = 0;
s{// TEST:N:1 [;{}]*\n\}$}{ ++$count; "" }gem;
printf "$count\n";' input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "6
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1407"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1408: perl -0777 -ne '
my \$count = 0;
s{// TEST:Y:1 [;{}]*\\n;\\}\$}{ ++\$count; \"\" }gem;
printf \"\$count\\n\";' input.c"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1408"
( $at_check_trace; perl -0777 -ne '
my $count = 0;
s{// TEST:Y:1 [;{}]*\n;\}$}{ ++$count; "" }gem;
printf "$count\n";' input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "12
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1408"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1409: perl -0777 -ne '
my \$count = 0;
s{#define TEST_MACRO_N \\\\\\n\\[\\]\"broken\\\\\" \\\$ \\@ \\\$\\\$ \\@\\\$ \\[\\];\\\\\\nstring;\"\\}}{ ++\$count; \"\" }gem;
printf \"\$count\\n\";' input.c"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1409"
( $at_check_trace; perl -0777 -ne '
my $count = 0;
s{#define TEST_MACRO_N \\\n\[\]"broken\\" \$ \@ \$\$ \@\$ \[\];\\\nstring;"\}}{ ++$count; "" }gem;
printf "$count\n";' input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1409"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_141
#AT_START_142
at_fn_group_banner 142 'actions.at:1418' \
  "Destroying lookahead assigned by semantic action" "" 9
at_xfail=no
(
  $as_echo "142. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%code {
  #include <assert.h>
  #include <stdio.h>
  static void yyerror (char const *);
  static int yylex (void);
  #define USE(Var)
}

%destructor { fprintf (stderr, "'a' destructor\n"); } 'a'
%destructor { fprintf (stderr, "'b' destructor\n"); } 'b'

%%

// In a previous version of Bison, yychar assigned by the semantic
// action below was not translated into yytoken before the lookahead was
// discarded and thus before its destructor (selected according to
// yytoken) was called in order to return from yyparse.  This would
// happen even if YYACCEPT was performed in a later semantic action as
// long as only consistent states with default reductions were visited
// in between.  However, we leave YYACCEPT in the same semantic action
// for this test in order to show that skeletons cannot simply translate
// immediately after every semantic action because a semantic action
// that has set yychar might not always return normally.  Instead,
// skeletons must translate before every use of yytoken.
start: 'a' accept { USE($1); } ;
accept: /*empty*/ {
  assert (yychar == YYEMPTY);
  yychar = 'b';
  YYACCEPT;
} ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static char const *input = "a";
  return *input++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/actions.at:1475: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "actions.at:1475"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1475"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/actions.at:1475: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1475"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1475"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/actions.at:1475: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1475"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1475"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/actions.at:1475: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "actions.at:1475"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1475"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/actions.at:1475: bison -o input.c input.y"
at_fn_check_prepare_trace "actions.at:1475"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1475"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1476: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "actions.at:1476"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1476"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/actions.at:1477:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "actions.at:1477"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "'b' destructor
'a' destructor
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/actions.at:1477"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_142
#AT_START_143
at_fn_group_banner 143 'conflicts.at:31' \
  "S/R in initial" "                                 " 10
at_xfail=no
(
  $as_echo "143. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%expect 1
%%
exp: e 'e';
e: 'e' | /* Nothing. */;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:40: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:40"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:40"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:40: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:40"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:40"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:40: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:40"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:40"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:40: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:40"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:40"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:40: bison -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:40"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:4.9: warning: rule useless in parser due to conflicts: e: /* empty */
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:40"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_143
#AT_START_144
at_fn_group_banner 144 'conflicts.at:51' \
  "%nonassoc and eof" "                              " 10
at_xfail=no
(
  $as_echo "144. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define YYERROR_VERBOSE 1
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

/* The current argument. */
static const char *input;

static int
yylex (void)
{
  static size_t toknum;
  if (! (toknum <= strlen (input)))
    abort ();
  return input[toknum++];
}

%}

%nonassoc '<' '>'

%%
expr: expr '<' expr
    | expr '>' expr
    | '0'
    ;
%%
int
main (int argc, const char *argv[])
{
  input = argc <= 1 ? "" : argv[1];
  return yyparse ();
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:98: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:98"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:98: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:98"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:98: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:98"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:98: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:98"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:98: bison -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:98"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:99: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "conflicts.at:99"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:99"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/conflicts.at:101:  \$PREPARSER ./input '0<0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0<0'" "conflicts.at:101"
( $at_check_trace;  $PREPARSER ./input '0<0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:101"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:102:  \$PREPARSER ./input '0<0<0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0<0<0'" "conflicts.at:102"
( $at_check_trace;  $PREPARSER ./input '0<0<0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '<'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:102"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/conflicts.at:106:  \$PREPARSER ./input '0>0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0>0'" "conflicts.at:106"
( $at_check_trace;  $PREPARSER ./input '0>0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:106"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:107:  \$PREPARSER ./input '0>0>0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0>0>0'" "conflicts.at:107"
( $at_check_trace;  $PREPARSER ./input '0>0>0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '>'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:107"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/conflicts.at:111:  \$PREPARSER ./input '0<0>0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0<0>0'" "conflicts.at:111"
( $at_check_trace;  $PREPARSER ./input '0<0>0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '>'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:111"
$at_failed && at_fn_log_failure
$at_traceon; }


# We must disable default reductions in inconsistent states in order to
# have an explicit list of all expected tokens.  (However, unless we use
# canonical LR, lookahead sets are merged for different left contexts,
# so it is still possible to have extra incorrect tokens in the expected
# list.  That just doesn't happen to be a problem for this test case.)

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:121: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -Dlr.default-reductions=consistent -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:121"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -Dlr.default-reductions=consistent -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:121"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:121: bison --xml=xml-tests/test.xml -Dlr.default-reductions=consistent -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:121"
( $at_check_trace; bison --xml=xml-tests/test.xml -Dlr.default-reductions=consistent -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:121"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:121: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:121"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:121"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:121: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:121"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:121"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:121: bison -Dlr.default-reductions=consistent -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:121"
( $at_check_trace; bison -Dlr.default-reductions=consistent -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:121"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:122: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "conflicts.at:122"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:122"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/conflicts.at:124:  \$PREPARSER ./input '0<0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0<0'" "conflicts.at:124"
( $at_check_trace;  $PREPARSER ./input '0<0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:124"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:125:  \$PREPARSER ./input '0<0<0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0<0<0'" "conflicts.at:125"
( $at_check_trace;  $PREPARSER ./input '0<0<0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '<', expecting \$end
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:125"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/conflicts.at:129:  \$PREPARSER ./input '0>0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0>0'" "conflicts.at:129"
( $at_check_trace;  $PREPARSER ./input '0>0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:129"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:130:  \$PREPARSER ./input '0>0>0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0>0>0'" "conflicts.at:130"
( $at_check_trace;  $PREPARSER ./input '0>0>0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '>', expecting \$end
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/conflicts.at:134:  \$PREPARSER ./input '0<0>0'"
at_fn_check_prepare_dynamic " $PREPARSER ./input '0<0>0'" "conflicts.at:134"
( $at_check_trace;  $PREPARSER ./input '0<0>0'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '>', expecting \$end
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:134"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_144
#AT_START_145
at_fn_group_banner 145 'conflicts.at:146' \
  "parse.error=verbose and consistent errors" "      " 10
at_xfail=no
      : && at_xfail=yes
(
  $as_echo "145. $at_setup_line: testing $at_desc ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <assert.h>
  #include <stdio.h>
  int yylex (void);
  void yyerror (char const *);
  #define USE(Var)
}

%define parse.error verbose

// The point isn't to test IELR here, but state merging happens to
// complicate the example.
%define lr.type ielr

%nonassoc 'a'

// If yylval=0 here, then we know that the 'a' destructor is being
// invoked incorrectly for the 'b' set in the semantic action below.
// All 'a' tokens are returned by yylex, which sets yylval=1.
%destructor {
  if (!$$)
    fprintf (stderr, "Wrong destructor.\n");
} 'a'

%%

// The lookahead assigned by the semantic action isn't needed before
// either error action is encountered.  In a previous version of Bison,
// this was a problem as it meant yychar was not translated into yytoken
// before either error action.  The second error action thus invoked a
// destructor that it selected according to the incorrect yytoken.  The
// first error action would have reported an incorrect unexpected token
// except that, due to another bug, the unexpected token is not reported
// at all because the error action is the default action in a consistent
// state.  That bug still needs to be fixed.
start: error-reduce consistent-error 'a' { USE ($3); } ;

error-reduce:
  'a' 'a' consistent-reduction consistent-error 'a'
  { USE (($1, $2, $5)); }
| 'a' error
  { USE ($1); }
;

consistent-reduction: /*empty*/ {
  assert (yychar == YYEMPTY);
  yylval = 0;
  yychar = 'b';
} ;

consistent-error:
  'a' { USE ($1); }
| /*empty*/ %prec 'a'
;

// Provide another context in which all rules are useful so that this
// test case looks a little more realistic.
start: 'b' consistent-error 'b' ;

%%

int
yylex (void)
{
  static char const *input = "aa";
  yylval = 1;
  return *input++;
}

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# See comments in grammar for why this test doesn't succeed.




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:251: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:251"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:251"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:251: bison --xml=xml-tests/test.xml  -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:251"
( $at_check_trace; bison --xml=xml-tests/test.xml  -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:251"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:251: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:251"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:251"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:251: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:251"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:251"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:251: bison  -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:251"
( $at_check_trace; bison  -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:251"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:251: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "conflicts.at:251"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:251"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/conflicts.at:251:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "conflicts.at:251"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected 'b'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:251"
$at_failed && at_fn_log_failure
$at_traceon; }







if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:252: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -Dlr.default-reductions=consistent -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:252"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -Dlr.default-reductions=consistent -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:252"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:252: bison --xml=xml-tests/test.xml -Dlr.default-reductions=consistent -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:252"
( $at_check_trace; bison --xml=xml-tests/test.xml -Dlr.default-reductions=consistent -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:252"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:252: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:252"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:252"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:252: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:252"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:252"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:252: bison -Dlr.default-reductions=consistent -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:252"
( $at_check_trace; bison -Dlr.default-reductions=consistent -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:252"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:252: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "conflicts.at:252"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:252"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/conflicts.at:252:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "conflicts.at:252"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected 'b'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:252"
$at_failed && at_fn_log_failure
$at_traceon; }






# Canonical LR doesn't foresee the error for 'a'!


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:256: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -Dlr.default-reductions=accepting -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:256"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -Dlr.default-reductions=accepting -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:256"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:256: bison --xml=xml-tests/test.xml -Dlr.default-reductions=accepting -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:256"
( $at_check_trace; bison --xml=xml-tests/test.xml -Dlr.default-reductions=accepting -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:256"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:256: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:256"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:256"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:256: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:256"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:256"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:256: bison -Dlr.default-reductions=accepting -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:256"
( $at_check_trace; bison -Dlr.default-reductions=accepting -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:256"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:256: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "conflicts.at:256"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:256"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/conflicts.at:256:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "conflicts.at:256"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected \$end, expecting 'a'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:256"
$at_failed && at_fn_log_failure
$at_traceon; }







if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:258: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -Flr.type=canonical-lr -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:258"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -Flr.type=canonical-lr -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:258"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:258: bison --xml=xml-tests/test.xml -Flr.type=canonical-lr -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:258"
( $at_check_trace; bison --xml=xml-tests/test.xml -Flr.type=canonical-lr -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:258"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:258: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:258"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:258"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:258: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:258"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:258"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:258: bison -Flr.type=canonical-lr -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:258"
( $at_check_trace; bison -Flr.type=canonical-lr -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:258"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:258: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "conflicts.at:258"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:258"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/conflicts.at:258:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "conflicts.at:258"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected \$end, expecting 'a'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:258"
$at_failed && at_fn_log_failure
$at_traceon; }








  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_145
#AT_START_146
at_fn_group_banner 146 'conflicts.at:270' \
  "Unresolved SR Conflicts" "                        " 10
at_xfail=no
(
  $as_echo "146. $at_setup_line: testing $at_desc ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%token NUM OP
%%
exp: exp OP exp | NUM;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:280: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c --report=all input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:280"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:280"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:280: bison --xml=xml-tests/test.xml -o input.c --report=all input.y"
at_fn_check_prepare_trace "conflicts.at:280"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:280"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:280: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:280"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:280"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:280: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:280"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:280"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:280: bison -o input.c --report=all input.y"
at_fn_check_prepare_trace "conflicts.at:280"
( $at_check_trace; bison -o input.c --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:280"
$at_failed && at_fn_log_failure
$at_traceon; }


# Check the contents of the report.
{ set +x
$as_echo "$at_srcdir/conflicts.at:285: cat input.output"
at_fn_check_prepare_trace "conflicts.at:285"
( $at_check_trace; cat input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "State 5 conflicts: 1 shift/reduce


Grammar

    0 \$accept: exp \$end

    1 exp: exp OP exp
    2    | NUM


Terminals, with rules where they appear

\$end (0) 0
error (256)
NUM (258) 2
OP (259) 1


Nonterminals, with rules where they appear

\$accept (5)
    on left: 0
exp (6)
    on left: 1 2, on right: 0 1


state 0

    0 \$accept: . exp \$end
    1 exp: . exp OP exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 2


state 1

    2 exp: NUM .

    \$default  reduce using rule 2 (exp)


state 2

    0 \$accept: exp . \$end
    1 exp: exp . OP exp

    \$end  shift, and go to state 3
    OP    shift, and go to state 4


state 3

    0 \$accept: exp \$end .

    \$default  accept


state 4

    1 exp: . exp OP exp
    1    | exp OP . exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 5


state 5

    1 exp: exp . OP exp
    1    | exp OP exp .  [\$end, OP]

    OP  shift, and go to state 4

    OP        [reduce using rule 1 (exp)]
    \$default  reduce using rule 1 (exp)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:285"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_146
#AT_START_147
at_fn_group_banner 147 'conflicts.at:377' \
  "Resolved SR Conflicts" "                          " 10
at_xfail=no
(
  $as_echo "147. $at_setup_line: testing $at_desc ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%token NUM OP
%left OP
%%
exp: exp OP exp | NUM;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:388: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c --report=all input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:388"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:388"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:388: bison --xml=xml-tests/test.xml -o input.c --report=all input.y"
at_fn_check_prepare_trace "conflicts.at:388"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:388"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:388: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:388"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:388"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:388: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:388"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:388"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:388: bison -o input.c --report=all input.y"
at_fn_check_prepare_trace "conflicts.at:388"
( $at_check_trace; bison -o input.c --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:388"
$at_failed && at_fn_log_failure
$at_traceon; }


# Check the contents of the report.
{ set +x
$as_echo "$at_srcdir/conflicts.at:391: cat input.output"
at_fn_check_prepare_trace "conflicts.at:391"
( $at_check_trace; cat input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Grammar

    0 \$accept: exp \$end

    1 exp: exp OP exp
    2    | NUM


Terminals, with rules where they appear

\$end (0) 0
error (256)
NUM (258) 2
OP (259) 1


Nonterminals, with rules where they appear

\$accept (5)
    on left: 0
exp (6)
    on left: 1 2, on right: 0 1


state 0

    0 \$accept: . exp \$end
    1 exp: . exp OP exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 2


state 1

    2 exp: NUM .

    \$default  reduce using rule 2 (exp)


state 2

    0 \$accept: exp . \$end
    1 exp: exp . OP exp

    \$end  shift, and go to state 3
    OP    shift, and go to state 4


state 3

    0 \$accept: exp \$end .

    \$default  accept


state 4

    1 exp: . exp OP exp
    1    | exp OP . exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 5


state 5

    1 exp: exp . OP exp
    1    | exp OP exp .  [\$end, OP]

    \$default  reduce using rule 1 (exp)

    Conflict between rule 1 and token OP resolved as reduce (%left OP).
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:391"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_147
#AT_START_148
at_fn_group_banner 148 'conflicts.at:478' \
  "%precedence suffices" "                           " 10
at_xfail=no
(
  $as_echo "148. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%precedence "then"
%precedence "else"
%%
stmt:
  "if" cond "then" stmt
| "if" cond "then" stmt "else" stmt
| "stmt"
;

cond:
  "exp"
;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:495: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:495"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:495"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:495: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:495"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:495"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:495: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:495"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:495"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:495: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:495"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:495"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:495: bison -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:495"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:495"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_148
#AT_START_149
at_fn_group_banner 149 'conflicts.at:504' \
  "%precedence does not suffice" "                   " 10
at_xfail=no
(
  $as_echo "149. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%precedence "then"
%precedence "else"
%%
stmt:
  "if" cond "then" stmt
| "if" cond "then" stmt "else" stmt
| "stmt"
;

cond:
  "exp"
| cond "then" cond
;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:522: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:522"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:522: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:522"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:522: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:522"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:522: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:522"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:522: bison -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:522"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 shift/reduce
input.y:12.3-18: warning: rule useless in parser due to conflicts: cond: cond \"then\" cond
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_149
#AT_START_150
at_fn_group_banner 150 'conflicts.at:555' \
  "Defaulted Conflicted Reduction" "                 " 10
at_xfail=no
(
  $as_echo "150. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >input.y <<'_ATEOF'
%%
exp: num | id;
num: '0';
id : '0';
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:566: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c --report=all input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:566"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:566"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:566: bison --xml=xml-tests/test.xml -o input.c --report=all input.y"
at_fn_check_prepare_trace "conflicts.at:566"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:566"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:566: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:566"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:566"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:566: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:566"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:566"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:566: bison -o input.c --report=all input.y"
at_fn_check_prepare_trace "conflicts.at:566"
( $at_check_trace; bison -o input.c --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 reduce/reduce
input.y:4.6-8: warning: rule useless in parser due to conflicts: id: '0'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:566"
$at_failed && at_fn_log_failure
$at_traceon; }


# Check the contents of the report.
{ set +x
$as_echo "$at_srcdir/conflicts.at:572: cat input.output"
at_fn_check_prepare_trace "conflicts.at:572"
( $at_check_trace; cat input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Rules useless in parser due to conflicts

    4 id: '0'


State 1 conflicts: 1 reduce/reduce


Grammar

    0 \$accept: exp \$end

    1 exp: num
    2    | id

    3 num: '0'

    4 id: '0'


Terminals, with rules where they appear

\$end (0) 0
'0' (48) 3 4
error (256)


Nonterminals, with rules where they appear

\$accept (4)
    on left: 0
exp (5)
    on left: 1 2, on right: 0
num (6)
    on left: 3, on right: 1
id (7)
    on left: 4, on right: 2


state 0

    0 \$accept: . exp \$end
    1 exp: . num
    2    | . id
    3 num: . '0'
    4 id: . '0'

    '0'  shift, and go to state 1

    exp  go to state 2
    num  go to state 3
    id   go to state 4


state 1

    3 num: '0' .  [\$end]
    4 id: '0' .  [\$end]

    \$end      reduce using rule 3 (num)
    \$end      [reduce using rule 4 (id)]
    \$default  reduce using rule 3 (num)


state 2

    0 \$accept: exp . \$end

    \$end  shift, and go to state 5


state 3

    1 exp: num .

    \$default  reduce using rule 1 (exp)


state 4

    2 exp: id .

    \$default  reduce using rule 2 (exp)


state 5

    0 \$accept: exp \$end .

    \$default  accept
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_150
#AT_START_151
at_fn_group_banner 151 'conflicts.at:674' \
  "%expect not enough" "                             " 10
at_xfail=no
(
  $as_echo "151. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 0
%%
exp: exp OP exp | NUM;
_ATEOF



{ set +x
$as_echo "$at_srcdir/conflicts.at:683: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y" "conflicts.at:683"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 shift/reduce
input.y: expected 0 shift/reduce conflicts
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:683"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_151
#AT_START_152
at_fn_group_banner 152 'conflicts.at:694' \
  "%expect right" "                                  " 10
at_xfail=no
(
  $as_echo "152. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 1
%%
exp: exp OP exp | NUM;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:703: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:703"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:703"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:703: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:703"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:703"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:703: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:703"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:703"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:703: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:703"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:703"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:703: bison -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:703"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:703"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_152
#AT_START_153
at_fn_group_banner 153 'conflicts.at:711' \
  "%expect too much" "                               " 10
at_xfail=no
(
  $as_echo "153. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 2
%%
exp: exp OP exp | NUM;
_ATEOF



{ set +x
$as_echo "$at_srcdir/conflicts.at:720: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y" "conflicts.at:720"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 shift/reduce
input.y: expected 2 shift/reduce conflicts
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_153
#AT_START_154
at_fn_group_banner 154 'conflicts.at:731' \
  "%expect with reduce conflicts" "                  " 10
at_xfail=no
(
  $as_echo "154. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%expect 0
%%
program: a 'a' | a a;
a: 'a';
_ATEOF



{ set +x
$as_echo "$at_srcdir/conflicts.at:740: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y" "conflicts.at:740"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 reduce/reduce
input.y: expected 0 reduce/reduce conflicts
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/conflicts.at:740"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_154
#AT_START_155
at_fn_group_banner 155 'conflicts.at:751' \
  "%prec with user string" "                         " 10
at_xfail=no
(
  $as_echo "155. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%%
exp:
  "foo" %prec "foo"
;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:760: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:760"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:760"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:760: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:760"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:760"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:760: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:760"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:760"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:760: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:760"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:760"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:760: bison -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:760"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:760"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_155
#AT_START_156
at_fn_group_banner 156 'conflicts.at:768' \
  "%no-default-prec without %prec" "                 " 10
at_xfail=no
(
  $as_echo "156. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%left '+'
%left '*'

%%

%no-default-prec;

e:   e '+' e
   | e '*' e
   | '0'
   ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:784: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:784"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:784"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:784: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:784"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:784"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:784: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:784"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:784"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:784: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:784"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:784"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:784: bison -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:784"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 4 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:784"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_156
#AT_START_157
at_fn_group_banner 157 'conflicts.at:794' \
  "%no-default-prec with %prec" "                    " 10
at_xfail=no
(
  $as_echo "157. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%left '+'
%left '*'

%%

%no-default-prec;

e:   e '+' e %prec '+'
   | e '*' e %prec '*'
   | '0'
   ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:810: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:810"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:810"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:810: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:810"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:810"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:810: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:810"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:810"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:810: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:810"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:810"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:810: bison -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:810"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:810"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_157
#AT_START_158
at_fn_group_banner 158 'conflicts.at:818' \
  "%default-prec" "                                  " 10
at_xfail=no
(
  $as_echo "158. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%left '+'
%left '*'

%%

%default-prec;

e:   e '+' e
   | e '*' e
   | '0'
   ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:834: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:834"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:834"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:834: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:834"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:834"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:834: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:834"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:834"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:834: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:834"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:834"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:834: bison -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:834"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:834"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_158
#AT_START_159
at_fn_group_banner 159 'conflicts.at:842' \
  "Unreachable States After Conflict Resolution" "   " 10
at_xfail=no
(
  $as_echo "159. $at_setup_line: testing $at_desc ..."
  $at_traceon


# If conflict resolution makes states unreachable, remove those states, report
# rules that are then unused, and don't report conflicts in those states.  Test
# what happens when a nonterminal becomes useless as a result of state removal
# since that causes lalr.o's goto map to be rewritten.

cat >input.y <<'_ATEOF'
%output "input.c"
%left 'a'

%%

start: resolved_conflict 'a' reported_conflicts 'a' ;

/* S/R conflict resolved as reduce, so the state with item
 * (resolved_conflict: 'a' . unreachable1) and all it transition successors are
 * unreachable, and the associated production is useless.  */
resolved_conflict:
    'a' unreachable1
  | %prec 'a'
  ;

/* S/R conflict that need not be reported since it is unreachable because of
 * the previous conflict resolution.  Nonterminal unreachable1 and all its
 * productions are useless.  */
unreachable1:
    'a' unreachable2
  |
  ;

/* Likewise for a R/R conflict and nonterminal unreachable2.  */
unreachable2: | ;

/* Make sure remaining S/R and R/R conflicts are still reported correctly even
 * when their states are renumbered due to state removal.  */
reported_conflicts:
    'a'
  | 'a'
  |
  ;

_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:886: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:886"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:886"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:886: bison --xml=xml-tests/test.xml --report=all input.y"
at_fn_check_prepare_trace "conflicts.at:886"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:886"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:886: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:886"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:886"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:886: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:886"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:886"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:886: bison --report=all input.y"
at_fn_check_prepare_trace "conflicts.at:886"
( $at_check_trace; bison --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 shift/reduce, 1 reduce/reduce
input.y:12.5-20: warning: rule useless in parser due to conflicts: resolved_conflict: 'a' unreachable1
input.y:20.5-20: warning: rule useless in parser due to conflicts: unreachable1: 'a' unreachable2
input.y:21.4: warning: rule useless in parser due to conflicts: unreachable1: /* empty */
input.y:25.13: warning: rule useless in parser due to conflicts: unreachable2: /* empty */
input.y:25.16: warning: rule useless in parser due to conflicts: unreachable2: /* empty */
input.y:31.5-7: warning: rule useless in parser due to conflicts: reported_conflicts: 'a'
input.y:32.4: warning: rule useless in parser due to conflicts: reported_conflicts: /* empty */
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:886"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/conflicts.at:897: cat input.output"
at_fn_check_prepare_trace "conflicts.at:897"
( $at_check_trace; cat input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Rules useless in parser due to conflicts

    2 resolved_conflict: 'a' unreachable1

    4 unreachable1: 'a' unreachable2
    5             | /* empty */

    6 unreachable2: /* empty */
    7             | /* empty */

    9 reported_conflicts: 'a'
   10                   | /* empty */


State 4 conflicts: 1 shift/reduce
State 5 conflicts: 1 reduce/reduce


Grammar

    0 \$accept: start \$end

    1 start: resolved_conflict 'a' reported_conflicts 'a'

    2 resolved_conflict: 'a' unreachable1
    3                  | /* empty */

    4 unreachable1: 'a' unreachable2
    5             | /* empty */

    6 unreachable2: /* empty */
    7             | /* empty */

    8 reported_conflicts: 'a'
    9                   | 'a'
   10                   | /* empty */


Terminals, with rules where they appear

\$end (0) 0
'a' (97) 1 2 4 8 9
error (256)


Nonterminals, with rules where they appear

\$accept (4)
    on left: 0
start (5)
    on left: 1, on right: 0
resolved_conflict (6)
    on left: 2 3, on right: 1
unreachable1 (7)
    on left: 4 5, on right: 2
unreachable2 (8)
    on left: 6 7, on right: 4
reported_conflicts (9)
    on left: 8 9 10, on right: 1


state 0

    0 \$accept: . start \$end
    1 start: . resolved_conflict 'a' reported_conflicts 'a'
    2 resolved_conflict: . 'a' unreachable1
    3                  | .  ['a']

    \$default  reduce using rule 3 (resolved_conflict)

    start              go to state 1
    resolved_conflict  go to state 2

    Conflict between rule 3 and token 'a' resolved as reduce (%left 'a').


state 1

    0 \$accept: start . \$end

    \$end  shift, and go to state 3


state 2

    1 start: resolved_conflict . 'a' reported_conflicts 'a'

    'a'  shift, and go to state 4


state 3

    0 \$accept: start \$end .

    \$default  accept


state 4

    1 start: resolved_conflict 'a' . reported_conflicts 'a'
    8 reported_conflicts: . 'a'
    9                   | . 'a'
   10                   | .  ['a']

    'a'  shift, and go to state 5

    'a'  [reduce using rule 10 (reported_conflicts)]

    reported_conflicts  go to state 6


state 5

    8 reported_conflicts: 'a' .  ['a']
    9                   | 'a' .  ['a']

    'a'       reduce using rule 8 (reported_conflicts)
    'a'       [reduce using rule 9 (reported_conflicts)]
    \$default  reduce using rule 8 (reported_conflicts)


state 6

    1 start: resolved_conflict 'a' reported_conflicts . 'a'

    'a'  shift, and go to state 7


state 7

    1 start: resolved_conflict 'a' reported_conflicts 'a' .

    \$default  reduce using rule 1 (start)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:897"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input-keep.y <<'_ATEOF'
%define lr.keep-unreachable-states
_ATEOF

{ set +x
$as_echo "$at_srcdir/conflicts.at:1036: cat input.y >> input-keep.y"
at_fn_check_prepare_trace "conflicts.at:1036"
( $at_check_trace; cat input.y >> input-keep.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:1038: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input-keep.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:1038"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-keep.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:1038: bison --xml=xml-tests/test.xml input-keep.y"
at_fn_check_prepare_trace "conflicts.at:1038"
( $at_check_trace; bison --xml=xml-tests/test.xml input-keep.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:1038: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:1038"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:1038: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:1038"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:1038: bison input-keep.y"
at_fn_check_prepare_trace "conflicts.at:1038"
( $at_check_trace; bison input-keep.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input-keep.y: conflicts: 2 shift/reduce, 2 reduce/reduce
input-keep.y:22.4: warning: rule useless in parser due to conflicts: unreachable1: /* empty */
input-keep.y:26.16: warning: rule useless in parser due to conflicts: unreachable2: /* empty */
input-keep.y:32.5-7: warning: rule useless in parser due to conflicts: reported_conflicts: 'a'
input-keep.y:33.4: warning: rule useless in parser due to conflicts: reported_conflicts: /* empty */
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_159
#AT_START_160
at_fn_group_banner 160 'conflicts.at:1053' \
  "Solved conflicts report for multiple reductions in a state" "" 10
at_xfail=no
(
  $as_echo "160. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Used to lose earlier solved conflict messages even within a single S/R/R.

cat >input.y <<'_ATEOF'
%left 'a'
%right 'b'
%right 'c'
%right 'd'
%%
start:
    'a'
  | empty_a 'a'
  | 'b'
  | empty_b 'b'
  | 'c'
  | empty_c1 'c'
  | empty_c2 'c'
  | empty_c3 'c'
  ;
empty_a: %prec 'a' ;
empty_b: %prec 'b' ;
empty_c1: %prec 'c' ;
empty_c2: %prec 'c' ;
empty_c3: %prec 'd' ;
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:1079: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:1079"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1079"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:1079: bison --xml=xml-tests/test.xml --report=all -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:1079"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1079"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:1079: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:1079"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1079"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:1079: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:1079"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1079"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:1079: bison --report=all -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:1079"
( $at_check_trace; bison --report=all -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1079"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:1080: cat input.output | sed -n '/^state 0\$/,/^state 1\$/p'"
at_fn_check_prepare_notrace 'a shell pipeline' "conflicts.at:1080"
( $at_check_trace; cat input.output | sed -n '/^state 0$/,/^state 1$/p'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . start \$end
    1 start: . 'a'
    2      | . empty_a 'a'
    3      | . 'b'
    4      | . empty_b 'b'
    5      | . 'c'
    6      | . empty_c1 'c'
    7      | . empty_c2 'c'
    8      | . empty_c3 'c'
    9 empty_a: .  ['a']
   10 empty_b: .  []
   11 empty_c1: .  []
   12 empty_c2: .  []
   13 empty_c3: .  ['c']

    'b'  shift, and go to state 1

    'c'       reduce using rule 13 (empty_c3)
    \$default  reduce using rule 9 (empty_a)

    start     go to state 2
    empty_a   go to state 3
    empty_b   go to state 4
    empty_c1  go to state 5
    empty_c2  go to state 6
    empty_c3  go to state 7

    Conflict between rule 9 and token 'a' resolved as reduce (%left 'a').
    Conflict between rule 10 and token 'b' resolved as shift (%right 'b').
    Conflict between rule 11 and token 'c' resolved as shift (%right 'c').
    Conflict between rule 12 and token 'c' resolved as shift (%right 'c').
    Conflict between rule 13 and token 'c' resolved as reduce ('c' < 'd').


state 1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1080"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_160
#AT_START_161
at_fn_group_banner 161 'conflicts.at:1133' \
  "%nonassoc error actions for multiple reductions in a state" "" 10
at_xfail=no
(
  $as_echo "161. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%nonassoc 'a' 'b' 'c'
%%
start:
    'a'
  | empty_a 'a'
  | 'b'
  | empty_b 'b'
  | 'c'
  | empty_c1 'c'
  | empty_c2 'c'
  | empty_c3 'c'
  ;
empty_a: %prec 'a' ;
empty_b: %prec 'b' ;
empty_c1: %prec 'c' ;
empty_c2: %prec 'c' ;
empty_c3: %prec 'c' ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/conflicts.at:1155: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "conflicts.at:1155"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1155"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/conflicts.at:1155: bison --xml=xml-tests/test.xml --report=all -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:1155"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1155"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:1155: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:1155"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1155"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/conflicts.at:1155: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "conflicts.at:1155"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1155"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/conflicts.at:1155: bison --report=all -o input.c input.y"
at_fn_check_prepare_trace "conflicts.at:1155"
( $at_check_trace; bison --report=all -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1155"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/conflicts.at:1156: cat input.output | sed -n '/^state 0\$/,/^state 1\$/p'"
at_fn_check_prepare_notrace 'a shell pipeline' "conflicts.at:1156"
( $at_check_trace; cat input.output | sed -n '/^state 0$/,/^state 1$/p'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . start \$end
    1 start: . 'a'
    2      | . empty_a 'a'
    3      | . 'b'
    4      | . empty_b 'b'
    5      | . 'c'
    6      | . empty_c1 'c'
    7      | . empty_c2 'c'
    8      | . empty_c3 'c'
    9 empty_a: .  []
   10 empty_b: .  []
   11 empty_c1: .  []
   12 empty_c2: .  ['c']
   13 empty_c3: .  ['c']

    'a'  error (nonassociative)
    'b'  error (nonassociative)
    'c'  error (nonassociative)

    'c'  [reduce using rule 12 (empty_c2)]
    'c'  [reduce using rule 13 (empty_c3)]

    start     go to state 1
    empty_a   go to state 2
    empty_b   go to state 3
    empty_c1  go to state 4
    empty_c2  go to state 5
    empty_c3  go to state 6

    Conflict between rule 9 and token 'a' resolved as an error (%nonassoc 'a').
    Conflict between rule 10 and token 'b' resolved as an error (%nonassoc 'b').
    Conflict between rule 11 and token 'c' resolved as an error (%nonassoc 'c').


state 1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/conflicts.at:1156"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_161
#AT_START_162
at_fn_group_banner 162 'calc.at:610' \
  "Calculator " "                                    " 11
at_xfail=no
(
  $as_echo "162. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */


%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:610: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:610"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:610: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:610: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:610"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:610: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:610"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:610: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:610: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:610"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:610"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:610: cat stderr"
at_fn_check_prepare_trace "calc.at:610"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_162
#AT_START_163
at_fn_group_banner 163 'calc.at:612' \
  "Calculator %defines" "                            " 11
at_xfail=no
(
  $as_echo "163. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%defines

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:612: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:612"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:612: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:612: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:612"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:612: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:612"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:612: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:612: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:612"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:612"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:612: cat stderr"
at_fn_check_prepare_trace "calc.at:612"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:612"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_163
#AT_START_164
at_fn_group_banner 164 'calc.at:613' \
  "Calculator %locations" "                          " 11
at_xfail=no
(
  $as_echo "164. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%locations

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
      (yylloc).last_line++;
      (yylloc).last_column = 1;
    }
  else
    (yylloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 1;
      (yylloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:613: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:613"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:613: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:613: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:613"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:613: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:613"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:613: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:613: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:613"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:613"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:613: cat stderr"
at_fn_check_prepare_trace "calc.at:613"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_164
#AT_START_165
at_fn_group_banner 165 'calc.at:615' \
  "Calculator %name-prefix=\"calc\"" "                 " 11
at_xfail=no
(
  $as_echo "165. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%name-prefix="calc"

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:615: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:615"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:615: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:615: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:615"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:615: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:615"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:615: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:615: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:615"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:615:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:615"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:615: cat stderr"
at_fn_check_prepare_trace "calc.at:615"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_165
#AT_START_166
at_fn_group_banner 166 'calc.at:616' \
  "Calculator %verbose" "                            " 11
at_xfail=no
(
  $as_echo "166. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%verbose

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:616: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:616"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:616: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:616: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:616"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:616: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:616"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:616: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:616: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:616"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:616"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:616: cat stderr"
at_fn_check_prepare_trace "calc.at:616"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_166
#AT_START_167
at_fn_group_banner 167 'calc.at:617' \
  "Calculator %yacc" "                               " 11
at_xfail=no
(
  $as_echo "167. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:617: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:617"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:617: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:617: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:617"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:617: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:617"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:617: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:617: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:617"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:617"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:617: cat stderr"
at_fn_check_prepare_trace "calc.at:617"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_167
#AT_START_168
at_fn_group_banner 168 'calc.at:618' \
  "Calculator %define parse.error verbose" "         " 11
at_xfail=no
(
  $as_echo "168. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define parse.error verbose

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:618: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:618"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:618: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:618: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:618"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:618: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:618"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:618: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:618: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:618"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:618:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:618"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:618: cat stderr"
at_fn_check_prepare_trace "calc.at:618"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_168
#AT_START_169
at_fn_group_banner 169 'calc.at:620' \
  "Calculator %define api.pure %locations" "         " 11
at_xfail=no
(
  $as_echo "169. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.pure %locations

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:620: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:620"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:620: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:620: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:620"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:620: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:620"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:620: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:620: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:620"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:620:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:620"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:620: cat stderr"
at_fn_check_prepare_trace "calc.at:620"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_169
#AT_START_170
at_fn_group_banner 170 'calc.at:621' \
  "Calculator %define api.push-pull both %define api.pure %locations" "" 11
at_xfail=no
(
  $as_echo "170. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.push-pull both %define api.pure %locations

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:621: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:621"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:621: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:621: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:621"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:621: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:621"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:621: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:621: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:621"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:621"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:621: cat stderr"
at_fn_check_prepare_trace "calc.at:621"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:621"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_170
#AT_START_171
at_fn_group_banner 171 'calc.at:622' \
  "Calculator %define parse.error verbose %locations" "" 11
at_xfail=no
(
  $as_echo "171. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define parse.error verbose %locations

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
      (yylloc).last_line++;
      (yylloc).last_column = 1;
    }
  else
    (yylloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 1;
      (yylloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:622: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:622"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:622: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:622: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:622"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:622: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:622"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:622: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:622: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:622"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:622"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:622: cat stderr"
at_fn_check_prepare_trace "calc.at:622"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:622"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_171
#AT_START_172
at_fn_group_banner 172 'calc.at:624' \
  "Calculator %define parse.error verbose %locations %defines %name-prefix \"calc\" %verbose %yacc" "" 11
at_xfail=no
(
  $as_echo "172. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define parse.error verbose %locations %defines %name-prefix "calc" %verbose %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:624: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:624"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:624: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:624: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:624"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:624: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:624"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:624: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:624: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:624"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:624"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:624: cat stderr"
at_fn_check_prepare_trace "calc.at:624"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_172
#AT_START_173
at_fn_group_banner 173 'calc.at:625' \
  "Calculator %define parse.error verbose %locations %defines %name-prefix \"calc\" %define api.tokens.prefix \"TOK_\" %verbose %yacc" "" 11
at_xfail=no
(
  $as_echo "173. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define parse.error verbose %locations %defines %name-prefix "calc" %define api.tokens.prefix "TOK_" %verbose %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return TOK_NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return TOK_CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:625: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:625"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:625: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:625: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:625"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:625: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:625"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:625: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:625: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:625"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:625:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:625"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:625: cat stderr"
at_fn_check_prepare_trace "calc.at:625"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_173
#AT_START_174
at_fn_group_banner 174 'calc.at:627' \
  "Calculator %debug" "                              " 11
at_xfail=no
(
  $as_echo "174. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%debug

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:627: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:627"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:627: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:627: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:627"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:627: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:627"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:627: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:627: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:627"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:627:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:627"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:627: cat stderr"
at_fn_check_prepare_trace "calc.at:627"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_174
#AT_START_175
at_fn_group_banner 175 'calc.at:628' \
  "Calculator %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc" "" 11
at_xfail=no
(
  $as_echo "175. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define parse.error verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:628: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:628"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:628: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:628: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:628"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:628: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:628"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:628: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:628: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:628"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:628:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:628"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:628: cat stderr"
at_fn_check_prepare_trace "calc.at:628"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_175
#AT_START_176
at_fn_group_banner 176 'calc.at:630' \
  "Calculator %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc" "" 11
at_xfail=no
(
  $as_echo "176. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.pure %define parse.error verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:630: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:630"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:630: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:630: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:630"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:630: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:630"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:630: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:630: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:630"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:630:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:630"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:630: cat stderr"
at_fn_check_prepare_trace "calc.at:630"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:630"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_176
#AT_START_177
at_fn_group_banner 177 'calc.at:631' \
  "Calculator %define api.push-pull both %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc" "" 11
at_xfail=no
(
  $as_echo "177. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.push-pull both %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:631: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:631"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:631: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:631: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:631"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:631: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:631"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:631: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:631: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:631"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:631:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:631"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:631: cat stderr"
at_fn_check_prepare_trace "calc.at:631"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_177
#AT_START_178
at_fn_group_banner 178 'calc.at:633' \
  "Calculator %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}" "" 11
at_xfail=no
(
  $as_echo "178. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.pure %define parse.error verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *llocp,
                     semantic_value *result, int *count,
                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (YYLTYPE *llocp,
         semantic_value *result, int *count,
         const char *s)
{
(void) result; (void) count;

  fprintf (stderr, "%d.%d",
           (*llocp).first_line, (*llocp).first_column);
  if ((*llocp).first_line != (*llocp).last_line)
    fprintf (stderr, "-%d.%d",
	     (*llocp).last_line,  (*llocp).last_column - 1);
  else if ((*llocp).first_column != (*llocp).last_column - 1)
    fprintf (stderr, "-%d",
	     (*llocp).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse (&result, &count);
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:633: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:633"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:633: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:633: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:633"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:633: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:633"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:633: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:633: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:633"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:633:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:633"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:633: cat stderr"
at_fn_check_prepare_trace "calc.at:633"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_178
#AT_START_179
at_fn_group_banner 179 'calc.at:650' \
  "Calculator %glr-parser " "                        " 12
at_xfail=no
(
  $as_echo "179. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:650: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:650"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:650: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:650: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:650"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:650: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:650"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:650: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:650: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:650"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:650"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:650: cat stderr"
at_fn_check_prepare_trace "calc.at:650"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_179
#AT_START_180
at_fn_group_banner 180 'calc.at:652' \
  "Calculator %glr-parser %defines" "                " 12
at_xfail=no
(
  $as_echo "180. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %defines

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:652: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:652"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:652: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:652: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:652"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:652: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:652"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:652: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:652: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:652"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:652"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:652: cat stderr"
at_fn_check_prepare_trace "calc.at:652"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_180
#AT_START_181
at_fn_group_banner 181 'calc.at:653' \
  "Calculator %glr-parser %locations" "              " 12
at_xfail=no
(
  $as_echo "181. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %locations

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
      (yylloc).last_line++;
      (yylloc).last_column = 1;
    }
  else
    (yylloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 1;
      (yylloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:653: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:653"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:653: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:653: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:653"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:653: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:653"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:653: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:653: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:653"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:653:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:653"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:653: cat stderr"
at_fn_check_prepare_trace "calc.at:653"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_181
#AT_START_182
at_fn_group_banner 182 'calc.at:654' \
  "Calculator %glr-parser %name-prefix \"calc\"" "     " 12
at_xfail=no
(
  $as_echo "182. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %name-prefix "calc"

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:654: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:654"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:654: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:654: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:654"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:654: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:654"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:654: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:654: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:654"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:654:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:654"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:654: cat stderr"
at_fn_check_prepare_trace "calc.at:654"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_182
#AT_START_183
at_fn_group_banner 183 'calc.at:655' \
  "Calculator %glr-parser %verbose" "                " 12
at_xfail=no
(
  $as_echo "183. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %verbose

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:655: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:655"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:655: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:655: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:655"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:655: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:655"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:655: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:655: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:655"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:655:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:655"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:655: cat stderr"
at_fn_check_prepare_trace "calc.at:655"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_183
#AT_START_184
at_fn_group_banner 184 'calc.at:656' \
  "Calculator %glr-parser %yacc" "                   " 12
at_xfail=no
(
  $as_echo "184. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:656: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:656"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:656: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:656: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:656"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:656: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:656"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:656: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:656: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:656"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:656:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:656"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:656: cat stderr"
at_fn_check_prepare_trace "calc.at:656"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:656"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_184
#AT_START_185
at_fn_group_banner 185 'calc.at:657' \
  "Calculator %glr-parser %define parse.error verbose" "" 12
at_xfail=no
(
  $as_echo "185. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define parse.error verbose

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:657: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:657"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:657: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:657: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:657"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:657: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:657"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:657: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:657: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:657"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:657:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:657"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:657: cat stderr"
at_fn_check_prepare_trace "calc.at:657"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:657"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_185
#AT_START_186
at_fn_group_banner 186 'calc.at:659' \
  "Calculator %glr-parser %define api.pure %locations" "" 12
at_xfail=no
(
  $as_echo "186. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define api.pure %locations

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *llocp,

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (YYLTYPE *llocp,

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (*llocp).first_line, (*llocp).first_column);
  if ((*llocp).first_line != (*llocp).last_line)
    fprintf (stderr, "-%d.%d",
	     (*llocp).last_line,  (*llocp).last_column - 1);
  else if ((*llocp).first_column != (*llocp).last_column - 1)
    fprintf (stderr, "-%d",
	     (*llocp).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:659: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:659"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:659: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:659: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:659"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:659: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:659"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:659: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:659: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:659"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:659:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:659"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:659: cat stderr"
at_fn_check_prepare_trace "calc.at:659"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:659"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_186
#AT_START_187
at_fn_group_banner 187 'calc.at:660' \
  "Calculator %glr-parser %define parse.error verbose %locations" "" 12
at_xfail=no
(
  $as_echo "187. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define parse.error verbose %locations

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
      (yylloc).last_line++;
      (yylloc).last_column = 1;
    }
  else
    (yylloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 1;
      (yylloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:660: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:660"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:660: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:660: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:660"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:660: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:660"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:660: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:660: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:660"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:660:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:660"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:660: cat stderr"
at_fn_check_prepare_trace "calc.at:660"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:660"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_187
#AT_START_188
at_fn_group_banner 188 'calc.at:662' \
  "Calculator %glr-parser %define parse.error verbose %locations %defines %name-prefix \"calc\" %verbose %yacc" "" 12
at_xfail=no
(
  $as_echo "188. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define parse.error verbose %locations %defines %name-prefix "calc" %verbose %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:662: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:662"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:662: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:662: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:662"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:662: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:662"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:662: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:662: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:662"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:662:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:662"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:662: cat stderr"
at_fn_check_prepare_trace "calc.at:662"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:662"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_188
#AT_START_189
at_fn_group_banner 189 'calc.at:664' \
  "Calculator %glr-parser %debug" "                  " 12
at_xfail=no
(
  $as_echo "189. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %debug

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:664: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:664"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:664: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:664: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:664"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:664: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:664"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:664: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:664: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS" "calc.at:664"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:664:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:664"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:664: cat stderr"
at_fn_check_prepare_trace "calc.at:664"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_189
#AT_START_190
at_fn_group_banner 190 'calc.at:665' \
  "Calculator %glr-parser %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc" "" 12
at_xfail=no
(
  $as_echo "190. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define parse.error verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:665: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:665"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:665: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:665: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:665"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:665: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:665"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:665: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:665: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:665"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:665:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:665"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:665: cat stderr"
at_fn_check_prepare_trace "calc.at:665"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:665"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_190
#AT_START_191
at_fn_group_banner 191 'calc.at:666' \
  "Calculator %glr-parser %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %define api.tokens.prefix \"TOK_\" %verbose %yacc" "" 12
at_xfail=no
(
  $as_echo "191. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define parse.error verbose %debug %locations %defines %name-prefix "calc" %define api.tokens.prefix "TOK_" %verbose %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }
  while ((c = get_char ()) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return TOK_NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return TOK_CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:666: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:666"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:666: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:666: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:666"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:666: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:666"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:666: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:666: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:666"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:666:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:666"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:666: cat stderr"
at_fn_check_prepare_trace "calc.at:666"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:666"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_191
#AT_START_192
at_fn_group_banner 192 'calc.at:668' \
  "Calculator %glr-parser %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc" "" 12
at_xfail=no
(
  $as_echo "192. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *llocp,

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (YYLTYPE *llocp,

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (*llocp).first_line, (*llocp).first_column);
  if ((*llocp).first_line != (*llocp).last_line)
    fprintf (stderr, "-%d.%d",
	     (*llocp).last_line,  (*llocp).last_column - 1);
  else if ((*llocp).first_column != (*llocp).last_column - 1)
    fprintf (stderr, "-%d",
	     (*llocp).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:668: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:668"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:668: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:668: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:668"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:668: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:668"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:668: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:668: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:668"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:668:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:668"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:668: cat stderr"
at_fn_check_prepare_trace "calc.at:668"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:668"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_192
#AT_START_193
at_fn_group_banner 193 'calc.at:670' \
  "Calculator %glr-parser %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}" "" 12
at_xfail=no
(
  $as_echo "193. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define api.pure %define parse.error verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}

%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *llocp,
                     semantic_value *result, int *count,
                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C error reporting function.  */
static void
yyerror (YYLTYPE *llocp,
         semantic_value *result, int *count,
         const char *s)
{
(void) result; (void) count;

  fprintf (stderr, "%d.%d",
           (*llocp).first_line, (*llocp).first_column);
  if ((*llocp).first_line != (*llocp).last_line)
    fprintf (stderr, "-%d.%d",
	     (*llocp).last_line,  (*llocp).last_column - 1);
  else if ((*llocp).first_column != (*llocp).last_column - 1)
    fprintf (stderr, "-%d",
	     (*llocp).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse (&result, &count);
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:670: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:670"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:670: bison --xml=xml-tests/test.xml -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:670: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:670"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:670: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:670"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:670: bison -o calc.c calc.y"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; bison -o calc.c calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/calc.at:670: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS" "calc.at:670"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:670:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:670"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:670: cat stderr"
at_fn_check_prepare_trace "calc.at:670"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:670"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_193
#AT_START_194
at_fn_group_banner 194 'calc.at:680' \
  "Calculator %skeleton \"lalr1.cc\" %defines %locations" "" 13
at_xfail=no
(
  $as_echo "194. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%skeleton "lalr1.cc" %defines %locations
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
yy::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:680: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:680"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:680: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:680: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:680"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:680: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:680"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:680: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:680: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:680"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:680: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:680"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:680"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:680: cat stderr"
at_fn_check_prepare_trace "calc.at:680"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:680"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_194
#AT_START_195
at_fn_group_banner 195 'calc.at:689' \
  "Calculator %language \"C++\" %defines " "           " 13
at_xfail=no
(
  $as_echo "195. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
yy::parser::error (const std::string& m)
{
  std::cerr << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp);
static int get_char (YYSTYPE *lvalp);
static void unget_char (YYSTYPE *lvalp,  int c);


static int
get_char (YYSTYPE *lvalp)
{
  int res = getc (input);
  (void) lvalp;;

  return res;
}

static void
unget_char (YYSTYPE *lvalp,  int c)
{
  (void) lvalp;;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp)
{
  int c = get_char (lvalp);
  int sign = 1;
  int n = 0;

  (void) lvalp;;
  if (c == '-')
    {
      c = get_char (lvalp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp);
    }

  unget_char (lvalp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

  /* Skip current token, then white spaces.  */
  do
    {

    }
  while ((c = get_char (lvalp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp,  c);
      (*lvalp).ival = read_signed_integer (lvalp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:689: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:689"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:689: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:689: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:689"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:689: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:689"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:689: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:689: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:689"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:689: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:689"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:689:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:689"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:689: cat stderr"
at_fn_check_prepare_trace "calc.at:689"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_195
#AT_START_196
at_fn_group_banner 196 'calc.at:690' \
  "Calculator %language \"C++\" %defines %locations" " " 13
at_xfail=no
(
  $as_echo "196. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
yy::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:690: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:690"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:690: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:690: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:690"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:690: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:690"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:690: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:690: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:690"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:690: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:690"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:690:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:690"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:690: cat stderr"
at_fn_check_prepare_trace "calc.at:690"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_196
#AT_START_197
at_fn_group_banner 197 'calc.at:691' \
  "Calculator %language \"C++\" %defines %locations %define location_type Span" "" 13
at_xfail=no
(
  $as_echo "197. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %define location_type Span
%define global_tokens_and_yystype
%code requires
{

# include <iostream>
  struct Point
  {
    int l;
    int c;
  };

  struct Span
  {
    Point first;
    Point last;
  };

# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
  do                                                                    \
    if (N)                                                              \
      {                                                                 \
        (Current).first = YYRHSLOC (Rhs, 1).first;                      \
        (Current).last  = YYRHSLOC (Rhs, N).last;                       \
      }                                                                 \
    else                                                                \
      {                                                                 \
        (Current).first = (Current).last = YYRHSLOC (Rhs, 0).last;      \
      }                                                                 \
  while (false)


  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%


  std::ostream&
  operator<< (std::ostream& o, const Span& s)
  {
    o << s.first.l << '.' << s.first.c;
    if (s.first.l != s.last.l)
      o << '-' << s.last.l << '.' << s.last.c - 1;
    else if (s.first.c != s.last.c - 1)
      o << '-' << s.last.c - 1;
    return o;
  }


/* A C++ error reporting function.  */
void
yy::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last.l++;
      (*llocp).last.c = 1;
    }
  else
    (*llocp).last.c++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last.c = 1;
      (*llocp).last.l = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first.c = (*llocp).last.c;
      (*llocp).first.l   = (*llocp).last.l;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:691: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:691"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:691: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:691: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:691"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:691: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:691"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:691: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:691: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:691"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:691: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:691"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:691:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:691"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:691: cat stderr"
at_fn_check_prepare_trace "calc.at:691"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_197
#AT_START_198
at_fn_group_banner 198 'calc.at:692' \
  "Calculator %language \"C++\" %defines %locations %define parse.error verbose %name-prefix \"calc\" %verbose %yacc" "" 13
at_xfail=no
(
  $as_echo "198. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %define parse.error verbose %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:692: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:692"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:692: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:692: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:692"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:692: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:692"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:692: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:692: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:692"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:692: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:692"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:692:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:692"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:692: cat stderr"
at_fn_check_prepare_trace "calc.at:692"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:692"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_198
#AT_START_199
at_fn_group_banner 199 'calc.at:694' \
  "Calculator %language \"C++\" %defines %locations %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc" "" 13
at_xfail=no
(
  $as_echo "199. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %define parse.error verbose %debug %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:694: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:694"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:694: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:694: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:694"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:694: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:694"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:694: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:694: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:694"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:694: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:694"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:694:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:694"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:694: cat stderr"
at_fn_check_prepare_trace "calc.at:694"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_199
#AT_START_200
at_fn_group_banner 200 'calc.at:696' \
  "Calculator %language \"C++\" %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc" "" 13
at_xfail=no
(
  $as_echo "200. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:696: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:696"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:696: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:696: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:696"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:696: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:696"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:696: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:696: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:696"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:696: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:696"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:696:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:696"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:696: cat stderr"
at_fn_check_prepare_trace "calc.at:696"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_200
#AT_START_201
at_fn_group_banner 201 'calc.at:697' \
  "Calculator %language \"C++\" %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %define api.tokens.prefix \"TOK_\" %verbose %yacc" "" 13
at_xfail=no
(
  $as_echo "201. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix "calc" %define api.tokens.prefix "TOK_" %verbose %yacc
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return TOK_NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return TOK_CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:697: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:697"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:697: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:697: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:697"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:697: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:697"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:697: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:697: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:697"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:697: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:697"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:697:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:697"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:697: cat stderr"
at_fn_check_prepare_trace "calc.at:697"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_201
#AT_START_202
at_fn_group_banner 202 'calc.at:699' \
  "Calculator %language \"C++\" %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}" "" 13
at_xfail=no
(
  $as_echo "202. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse (semantic_value *result, int *count)
{
  calc::parser parser (result, count);
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse (&result, &count);
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:699: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:699"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:699: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:699: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:699"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:699: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:699"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:699: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:699: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:699"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:699: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:699"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:699:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:699"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:699: cat stderr"
at_fn_check_prepare_trace "calc.at:699"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:699"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_202
#AT_START_203
at_fn_group_banner 203 'calc.at:710' \
  "Calculator %skeleton \"glr.cc\" %defines %locations" "" 14
at_xfail=no
(
  $as_echo "203. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%skeleton "glr.cc" %defines %locations
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
yy::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:710: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:710"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:710: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:710: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:710"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:710: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:710"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:710: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:710: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:710"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:710: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:710"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:710:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:710"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:710: cat stderr"
at_fn_check_prepare_trace "calc.at:710"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_203
#AT_START_204
at_fn_group_banner 204 'calc.at:719' \
  "Calculator %language \"C++\" %glr-parser %defines %locations " "" 14
at_xfail=no
(
  $as_echo "204. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
yy::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:719: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:719"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:719: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:719: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:719"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:719: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:719"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:719: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:719: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:719"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:719: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:719"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:719:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:719"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:719: cat stderr"
at_fn_check_prepare_trace "calc.at:719"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:719"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_204
#AT_START_205
at_fn_group_banner 205 'calc.at:720' \
  "Calculator %language \"C++\" %glr-parser %defines %locations %define location_type Span" "" 14
at_xfail=no
(
  $as_echo "205. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %define location_type Span
%define global_tokens_and_yystype
%code requires
{

# include <iostream>
  struct Point
  {
    int l;
    int c;
  };

  struct Span
  {
    Point first;
    Point last;
  };

# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
  do                                                                    \
    if (N)                                                              \
      {                                                                 \
        (Current).first = YYRHSLOC (Rhs, 1).first;                      \
        (Current).last  = YYRHSLOC (Rhs, N).last;                       \
      }                                                                 \
    else                                                                \
      {                                                                 \
        (Current).first = (Current).last = YYRHSLOC (Rhs, 0).last;      \
      }                                                                 \
  while (false)


  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%


  std::ostream&
  operator<< (std::ostream& o, const Span& s)
  {
    o << s.first.l << '.' << s.first.c;
    if (s.first.l != s.last.l)
      o << '-' << s.last.l << '.' << s.last.c - 1;
    else if (s.first.c != s.last.c - 1)
      o << '-' << s.last.c - 1;
    return o;
  }


/* A C++ error reporting function.  */
void
yy::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last.l++;
      (*llocp).last.c = 1;
    }
  else
    (*llocp).last.c++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last.c = 1;
      (*llocp).last.l = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).first.c = (*llocp).last.c;
      (*llocp).first.l   = (*llocp).last.l;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:720: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:720"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:720: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:720: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:720"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:720: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:720"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:720: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:720: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:720"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:720: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:720"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:720:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:720"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:720: cat stderr"
at_fn_check_prepare_trace "calc.at:720"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_205
#AT_START_206
at_fn_group_banner 206 'calc.at:721' \
  "Calculator %language \"C++\" %glr-parser %defines %locations %define parse.error verbose %name-prefix \"calc\" %verbose %yacc" "" 14
at_xfail=no
(
  $as_echo "206. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %define parse.error verbose %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:721: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:721"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:721: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:721: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:721"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:721: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:721"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:721: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:721: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:721"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:721: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:721"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:721:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:721"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:721: cat stderr"
at_fn_check_prepare_trace "calc.at:721"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:721"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_206
#AT_START_207
at_fn_group_banner 207 'calc.at:723' \
  "Calculator %language \"C++\" %glr-parser %defines %locations %debug" "" 14
at_xfail=no
(
  $as_echo "207. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %debug
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
yy::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:723: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:723"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:723: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:723: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:723"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:723: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:723"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:723: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:723: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:723"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:723: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:723"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:723:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:723"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:723: cat stderr"
at_fn_check_prepare_trace "calc.at:723"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:723"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_207
#AT_START_208
at_fn_group_banner 208 'calc.at:724' \
  "Calculator %language \"C++\" %glr-parser %defines %locations %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc" "" 14
at_xfail=no
(
  $as_echo "208. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %define parse.error verbose %debug %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:724: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:724: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:724: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:724"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:724: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:724"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:724:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:724"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:724: cat stderr"
at_fn_check_prepare_trace "calc.at:724"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_208
#AT_START_209
at_fn_group_banner 209 'calc.at:726' \
  "Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc" "" 14
at_xfail=no
(
  $as_echo "209. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:726: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:726"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:726: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:726: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:726"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:726: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:726"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:726: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:726: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:726"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:726: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:726"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:726:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:726"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:726: cat stderr"
at_fn_check_prepare_trace "calc.at:726"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:726"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_209
#AT_START_210
at_fn_group_banner 210 'calc.at:727' \
  "Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %define api.tokens.prefix \"TOK_\" %verbose %yacc" "" 14
at_xfail=no
(
  $as_echo "210. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix "calc" %define api.tokens.prefix "TOK_" %verbose %yacc
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return TOK_NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return TOK_CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:727: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:727"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:727: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:727: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:727"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:727: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:727"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:727: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:727: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:727"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:727: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:727"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:727:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:727"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:727: cat stderr"
at_fn_check_prepare_trace "calc.at:727"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:727"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_210
#AT_START_211
at_fn_group_banner 211 'calc.at:729' \
  "Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}" "" 14
at_xfail=no
(
  $as_echo "211. $at_setup_line: testing $at_desc ..."
  $at_traceon









# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.












cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %pure-parser %define parse.error verbose %debug %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
%define global_tokens_and_yystype
%code requires
{

  /* Exercise pre-prologue dependency to %union.  */
  typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides
{
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::parser::location_type
#endif

}

%code
{
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);


int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}


/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++). */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '='   /* comparison	       */
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%



/* A C++ error reporting function.  */
void
calc::parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}

/* A C++ yyparse that simulates the C signature.  */
int
yyparse (semantic_value *result, int *count)
{
  calc::parser parser (result, count);
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


/* A C main function.  */
int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse (&result, &count);
  if (fclose (input))
    perror ("fclose");
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).end.line++;
      (*llocp).end.column = 1;
    }
  else
    (*llocp).end.column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).end.column = 1;
      (*llocp).end.line = 1;

    }

  /* Skip current token, then white spaces.  */
  do
    {
     (*llocp).begin.column = (*llocp).end.column;
      (*llocp).begin.line   = (*llocp).end.line;

    }
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t');

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/calc.at:729: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "calc.at:729"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/calc.at:729: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; bison --xml=xml-tests/test.xml -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/calc.at:729: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:729"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/calc.at:729: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "calc.at:729"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/calc.at:729: bison -o calc.cc calc.y"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; bison -o calc.cc calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/calc.at:729: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "calc.at:729"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/calc.at:729: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS" "calc.at:729"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc /dev/null"
at_fn_check_prepare_dynamic " $PREPARSER ./calc /dev/null" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ set +x
$as_echo "$at_srcdir/calc.at:729:  \$PREPARSER ./calc input"
at_fn_check_prepare_dynamic " $PREPARSER ./calc input" "calc.at:729"
( $at_check_trace;  $PREPARSER ./calc input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ set +x
$as_echo "$at_srcdir/calc.at:729: cat stderr"
at_fn_check_prepare_trace "calc.at:729"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/calc.at:729"
$at_failed && at_fn_log_failure
$at_traceon; }
































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_211
#AT_START_212
at_fn_group_banner 212 'torture.at:140' \
  "Big triangle" "                                   " 15
at_xfail=no
(
  $as_echo "212. $at_setup_line: testing $at_desc ..."
  $at_traceon


# I have been able to go up to 2000 on my machine.
# I tried 3000, a 29Mb grammar file, but then my system killed bison.
# With 500 and the new parser, which consume far too much memory,
# it gets killed too.  Of course the parser is to be cleaned.
cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
my $max = $ARGV[0] || 10;

print <<EOF;
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug
%{
#include <stdio.h>
#include <stdlib.h>

static int yylex (void);
static void yyerror (const char *msg);
%}
%union
{
  int val;
};

%token END "end"
%type <val> exp input
EOF

for my $size (1 .. $max)
  {
    print "%token t$size $size \"$size\"\n";
  };

print <<EOF;
%%
input:
  exp        { if (\$1 != 0) abort (); \$\$ = \$1; }
| input exp  { if (\$2 != \$1 + 1) abort (); \$\$ = \$2; }
;

exp:
  END
    { \$\$ = 0; }
EOF

for my $size (1 .. $max)
  {
    use Text::Wrap;
    print wrap ("| ", "   ",
		(map { "\"$_\"" } (1 .. $size)),
		" END \n"),
		  "    { \$\$ = $size; }\n";
  };
print ";\n";

print <<EOF;
%%
static int
yylex (void)
{
  static int inner = 1;
  static int outer = 0;
  if (outer > $max)
    return 0;
  else if (inner > outer)
    {
      inner = 1;
      ++outer;
      return END;
    }
  return inner++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


{ set +x
$as_echo "$at_srcdir/torture.at:146: perl -w ./gengram.pl 200 || exit 77"
at_fn_check_prepare_trace "torture.at:146"
( $at_check_trace; perl -w ./gengram.pl 200 || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

mv stdout input.y

{ set +x
$as_echo "$at_srcdir/torture.at:147: bison -v -o input.c input.y"
at_fn_check_prepare_trace "torture.at:147"
( $at_check_trace; bison -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:147"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:148: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "torture.at:148"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:148"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:149:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "torture.at:149"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:149"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_212
#AT_START_213
at_fn_group_banner 213 'torture.at:233' \
  "Big horizontal" "                                 " 15
at_xfail=no
(
  $as_echo "213. $at_setup_line: testing $at_desc ..."
  $at_traceon


# I have been able to go up to 10000 on my machine, but I had to
# increase the maximum stack size (* 100).  It gave:
#
# input.y      263k
# input.tab.c  1.3M
# input        453k
#
# gengram.pl 10000                 0.70s user 0.01s sys  99% cpu    0.711 total
# bison input.y                  730.56s user 0.53s sys  99% cpu 12:12.34 total
# gcc -Wall input.tab.c -o input   5.81s user 0.20s sys 100% cpu     6.01 total
# ./input                          0.00s user 0.01s sys 108% cpu     0.01 total
#
cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
my $max = $ARGV[0] || 10;

print <<EOF;
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug
%{
#include <stdio.h>
#include <stdlib.h>

static int yylex (void);
static void yyerror (const char *msg);
%}

%token
EOF
for my $size (1 .. $max)
  {
    print "    t$size $size \"$size\"\n";
  };

print <<EOF;

%%
EOF

use Text::Wrap;
print
  wrap ("exp: ", "  ",
	(map { "\"$_\"" } (1 .. $max)), ";"),
  "\n";

print <<EOF;
%%
static int
yylex (void)
{
  static int counter = 1;
  if (counter <= $max)
    return counter++;
  if (counter++ != $max + 1)
    abort ();
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


{ set +x
$as_echo "$at_srcdir/torture.at:247: perl -w ./gengram.pl 1000 || exit 77"
at_fn_check_prepare_trace "torture.at:247"
( $at_check_trace; perl -w ./gengram.pl 1000 || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:247"
$at_failed && at_fn_log_failure
$at_traceon; }

mv stdout input.y


# GNU m4 requires about 70 MiB for this test on a 32-bit host.
# Ask for 200 MiB, which should be plenty even on a 64-bit host.
data_limit=`(ulimit -S -d) 2>/dev/null`
case $data_limit in
[0-9]*)
  if test "$data_limit" -lt 204000; then
    { set +x
$as_echo "$at_srcdir/torture.at:251: ulimit -S -d 204000 || exit 77"
at_fn_check_prepare_trace "torture.at:251"
( $at_check_trace; ulimit -S -d 204000 || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:251"
$at_failed && at_fn_log_failure
$at_traceon; }

    ulimit -S -d 204000
  fi
esac

{ set +x
$as_echo "$at_srcdir/torture.at:253: bison -v -o input.c input.y"
at_fn_check_prepare_trace "torture.at:253"
( $at_check_trace; bison -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:253"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:254: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "torture.at:254"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:254"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:255:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "torture.at:255"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:255"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_213
#AT_START_214
at_fn_group_banner 214 'torture.at:373' \
  "Many lookahead tokens" "                          " 15
at_xfail=no
(
  $as_echo "214. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
use Text::Wrap;
my $max = $ARGV[0] || 10;

print <<EOF;
%error-verbose
%debug
%{
# include <stdio.h>
# include <stdlib.h>
# include <assert.h>

static int yylex (void);
static void yyerror (const char *msg);
%}
%union
{
  int val;
};

%type <val> input exp
%token token
EOF

print
  wrap ("%type <val> ",
	"            ",
	map { "n$_" } (1 .. $max)),
  "\n";

print "%token\n";
for my $count (1 .. $max)
  {
    print "    t$count $count \"$count\"\n";
  };

print <<EOF;
%%
input:
  exp        { assert (\$1 == 1); \$\$ = \$1; }
| input exp  { assert (\$2 == \$1 + 1); \$\$ = \$2; }
;

exp:
  n1 "1" { assert (\$1 == 1); \$\$ = \$1; }
EOF

for my $count (2 .. $max)
  {
    print "| n$count \"$count\" { assert (\$1 == $count); \$\$ = \$1; }\n";
  };
print ";\n";

for my $count (1 .. $max)
  {
    print "n$count: token { \$\$ = $count; };\n";
  };

print <<EOF;
%%
static int
yylex (void)
{
  static int return_token = 1;
  static int counter = 1;
  if (counter > $max)
    {
      if (counter++ != $max + 1)
	abort ();
      return 0;
    }
  if (return_token)
    {
      return_token = 0;
      return token;
    }
  return_token = 1;
  return counter++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


{ set +x
$as_echo "$at_srcdir/torture.at:375: perl -w ./gengram.pl 1000 || exit 77"
at_fn_check_prepare_trace "torture.at:375"
( $at_check_trace; perl -w ./gengram.pl 1000 || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:375"
$at_failed && at_fn_log_failure
$at_traceon; }

mv stdout input.y


# GNU m4 requires about 70 MiB for this test on a 32-bit host.
# Ask for 200 MiB, which should be plenty even on a 64-bit host.
data_limit=`(ulimit -S -d) 2>/dev/null`
case $data_limit in
[0-9]*)
  if test "$data_limit" -lt 204000; then
    { set +x
$as_echo "$at_srcdir/torture.at:379: ulimit -S -d 204000 || exit 77"
at_fn_check_prepare_trace "torture.at:379"
( $at_check_trace; ulimit -S -d 204000 || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:379"
$at_failed && at_fn_log_failure
$at_traceon; }

    ulimit -S -d 204000
  fi
esac

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/torture.at:381: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "torture.at:381"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:381"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/torture.at:381: bison --xml=xml-tests/test.xml -v -o input.c input.y"
at_fn_check_prepare_trace "torture.at:381"
( $at_check_trace; bison --xml=xml-tests/test.xml -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:381"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/torture.at:381: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:381"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:381"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/torture.at:381: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:381"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:381"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/torture.at:381: bison -v -o input.c input.y"
at_fn_check_prepare_trace "torture.at:381"
( $at_check_trace; bison -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:381"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:382: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "torture.at:382"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:382"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:383:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "torture.at:383"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:383"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_214
#AT_START_215
at_fn_group_banner 215 'torture.at:474' \
  "Exploding the Stack Size with Alloca" "           " 15
at_xfail=no
(
  $as_echo "215. $at_setup_line: testing $at_desc ..."
  $at_traceon




# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

#if (defined __GNUC__ || defined __BUILTIN_VA_ARG_INCR \
     || defined _AIX || defined _MSC_VER || defined _ALLOCA_H)
# define YYSTACK_USE_ALLOCA 1
#endif

  static int yylex (void);
  static void yyerror (const char *msg);
%}

%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  if (yylval < 0)
    abort ();
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  char *endp;
  YYSTYPE yylval_init;
  if (argc != 2)
    abort ();
  yylval_init = strtol (argv[1], &endp, 10);
  if (! (argv[1] != endp
	 && 0 <= yylval_init && yylval_init <= INT_MAX
	 && errno != ERANGE))
    abort ();
  yydebug = 1;
  {
    int count;
    int status;
    for (count = 0; count < 2; ++count)
      {
        int new_status;
        yylval = yylval_init;
        new_status = yyparse ();
        if (count > 0 && new_status != status)
          abort ();
        status = new_status;
      }
    return status;
  }
}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/torture.at:483: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "torture.at:483"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:483"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/torture.at:483: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "torture.at:483"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:483"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/torture.at:483: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:483"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:483"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/torture.at:483: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:483"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:483"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/torture.at:483: bison -o input.c input.y"
at_fn_check_prepare_trace "torture.at:483"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:483"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:483: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "torture.at:483"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:483"
$at_failed && at_fn_log_failure
$at_traceon; }



# Below the limit of 200.
{ set +x
$as_echo "$at_srcdir/torture.at:486: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 20"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 20" "torture.at:486"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:486"
$at_failed && at_fn_log_failure
$at_traceon; }

# Two enlargements: 2 * 2 * 200.
{ set +x
$as_echo "$at_srcdir/torture.at:489: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 900"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 900" "torture.at:489"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:489"
$at_failed && at_fn_log_failure
$at_traceon; }

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the last possible).
{ set +x
$as_echo "$at_srcdir/torture.at:493: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 10000"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 10000" "torture.at:493"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 2 $at_status "$at_srcdir/torture.at:493"
$at_failed && at_fn_log_failure
$at_traceon; }


# The push parser can't use alloca since the stacks can't be locals.  This test
# just helps guarantee we don't let the YYSTACK_USE_ALLOCA feature affect
# push parsers.
# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

#if (defined __GNUC__ || defined __BUILTIN_VA_ARG_INCR \
     || defined _AIX || defined _MSC_VER || defined _ALLOCA_H)
# define YYSTACK_USE_ALLOCA 1
#endif

  static int yylex (void);
  static void yyerror (const char *msg);
%}
%define api.push-pull both

%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  if (yylval < 0)
    abort ();
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  char *endp;
  YYSTYPE yylval_init;
  if (argc != 2)
    abort ();
  yylval_init = strtol (argv[1], &endp, 10);
  if (! (argv[1] != endp
	 && 0 <= yylval_init && yylval_init <= INT_MAX
	 && errno != ERANGE))
    abort ();
  yydebug = 1;
  {
    int count;
    int status;
    for (count = 0; count < 2; ++count)
      {
        int new_status;
        yylval = yylval_init;
        new_status = yyparse ();
        if (count > 0 && new_status != status)
          abort ();
        status = new_status;
      }
    return status;
  }
}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/torture.at:499: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "torture.at:499"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:499"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/torture.at:499: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "torture.at:499"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:499"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/torture.at:499: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:499"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:499"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/torture.at:499: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:499"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:499"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/torture.at:499: bison -o input.c input.y"
at_fn_check_prepare_trace "torture.at:499"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:499"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:499: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "torture.at:499"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:499"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/torture.at:502: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 20"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 20" "torture.at:502"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:502"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:504: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 900"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 900" "torture.at:504"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:504"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:506: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 10000"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 10000" "torture.at:506"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 2 $at_status "$at_srcdir/torture.at:506"
$at_failed && at_fn_log_failure
$at_traceon; }




  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_215
#AT_START_216
at_fn_group_banner 216 'torture.at:520' \
  "Exploding the Stack Size with Malloc" "           " 15
at_xfail=no
(
  $as_echo "216. $at_setup_line: testing $at_desc ..."
  $at_traceon




# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#define YYSTACK_USE_ALLOCA 0
  static int yylex (void);
  static void yyerror (const char *msg);
%}

%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  if (yylval < 0)
    abort ();
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  char *endp;
  YYSTYPE yylval_init;
  if (argc != 2)
    abort ();
  yylval_init = strtol (argv[1], &endp, 10);
  if (! (argv[1] != endp
	 && 0 <= yylval_init && yylval_init <= INT_MAX
	 && errno != ERANGE))
    abort ();
  yydebug = 1;
  {
    int count;
    int status;
    for (count = 0; count < 2; ++count)
      {
        int new_status;
        yylval = yylval_init;
        new_status = yyparse ();
        if (count > 0 && new_status != status)
          abort ();
        status = new_status;
      }
    return status;
  }
}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/torture.at:524: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "torture.at:524"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:524"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/torture.at:524: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "torture.at:524"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:524"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/torture.at:524: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:524"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:524"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/torture.at:524: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:524"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:524"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/torture.at:524: bison -o input.c input.y"
at_fn_check_prepare_trace "torture.at:524"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:524"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:524: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "torture.at:524"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:524"
$at_failed && at_fn_log_failure
$at_traceon; }



# Below the limit of 200.
{ set +x
$as_echo "$at_srcdir/torture.at:527: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 20"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 20" "torture.at:527"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:527"
$at_failed && at_fn_log_failure
$at_traceon; }

# Two enlargements: 2 * 2 * 200.
{ set +x
$as_echo "$at_srcdir/torture.at:530: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 900"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 900" "torture.at:530"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:530"
$at_failed && at_fn_log_failure
$at_traceon; }

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the possible).
{ set +x
$as_echo "$at_srcdir/torture.at:534: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 10000"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 10000" "torture.at:534"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 2 $at_status "$at_srcdir/torture.at:534"
$at_failed && at_fn_log_failure
$at_traceon; }


# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#define YYSTACK_USE_ALLOCA 0
  static int yylex (void);
  static void yyerror (const char *msg);
%}
%define api.push-pull both

%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  if (yylval < 0)
    abort ();
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  char *endp;
  YYSTYPE yylval_init;
  if (argc != 2)
    abort ();
  yylval_init = strtol (argv[1], &endp, 10);
  if (! (argv[1] != endp
	 && 0 <= yylval_init && yylval_init <= INT_MAX
	 && errno != ERANGE))
    abort ();
  yydebug = 1;
  {
    int count;
    int status;
    for (count = 0; count < 2; ++count)
      {
        int new_status;
        yylval = yylval_init;
        new_status = yyparse ();
        if (count > 0 && new_status != status)
          abort ();
        status = new_status;
      }
    return status;
  }
}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/torture.at:537: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "torture.at:537"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:537"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/torture.at:537: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "torture.at:537"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:537"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/torture.at:537: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:537"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:537"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/torture.at:537: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "torture.at:537"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:537"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/torture.at:537: bison -o input.c input.y"
at_fn_check_prepare_trace "torture.at:537"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:537"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:537: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "torture.at:537"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:537"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/torture.at:540: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 20"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 20" "torture.at:540"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:542: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 900"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 900" "torture.at:542"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/torture.at:542"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/torture.at:544: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 10000"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 10000" "torture.at:544"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 2 $at_status "$at_srcdir/torture.at:544"
$at_failed && at_fn_log_failure
$at_traceon; }




  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_216
#AT_START_217
at_fn_group_banner 217 'existing.at:76' \
  "GNU AWK 3.1.0 Grammar: LALR(1)" "                 " 16
at_xfail=no
(
  $as_echo "217. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type lalr
%error-verbose

%token FUNC_CALL NAME REGEXP
%token ERROR
%token YNUMBER YSTRING
%token RELOP APPEND_OP
%token ASSIGNOP MATCHOP NEWLINE CONCAT_OP
%token LEX_BEGIN LEX_END LEX_IF LEX_ELSE LEX_RETURN LEX_DELETE
%token LEX_WHILE LEX_DO LEX_FOR LEX_BREAK LEX_CONTINUE
%token LEX_PRINT LEX_PRINTF LEX_NEXT LEX_EXIT LEX_FUNCTION
%token LEX_GETLINE LEX_NEXTFILE
%token LEX_IN
%token LEX_AND LEX_OR INCREMENT DECREMENT
%token LEX_BUILTIN LEX_LENGTH

/* Lowest to highest */
%right ASSIGNOP
%right '?' ':'
%left LEX_OR
%left LEX_AND
%left LEX_GETLINE
%nonassoc LEX_IN
%left FUNC_CALL LEX_BUILTIN LEX_LENGTH
%nonassoc ','
%nonassoc MATCHOP
%nonassoc RELOP '<' '>' '|' APPEND_OP TWOWAYIO
%left CONCAT_OP
%left YSTRING YNUMBER
%left '+' '-'
%left '*' '/' '%'
%right '!' UNARY
%right '^'
%left INCREMENT DECREMENT
%left '$'
%left '(' ')'


%%


start
	: opt_nls program opt_nls
	;

program
	: rule
	| program rule
	| error
	| program error
	| /* empty */
	;

rule
	: LEX_BEGIN {} action
	| LEX_END {}   action
	| LEX_BEGIN statement_term
	| LEX_END statement_term
	| pattern action
	| action
	| pattern statement_term
	| function_prologue function_body
	;

func_name
	: NAME
	| FUNC_CALL
	| lex_builtin
	;

lex_builtin
	: LEX_BUILTIN
	| LEX_LENGTH
	;

function_prologue
	: LEX_FUNCTION {} func_name '(' opt_param_list r_paren opt_nls
	;

function_body
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

pattern
	: exp
	| exp ',' exp
	;

regexp
	/*
	 * In this rule, want_regexp tells yylex that the next thing
	 * is a regexp so it should read up to the closing slash.
	 */
	: '/' {} REGEXP '/'
	;

action
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

statements
	: statement
	| statements statement
	| error
	| statements error
	;

statement_term
	: nls
	| semi opt_nls
	;

statement
	: semi opt_nls
	| l_brace r_brace
	| l_brace statements r_brace
	| if_statement
	| LEX_WHILE '(' exp r_paren opt_nls statement
	| LEX_DO opt_nls statement LEX_WHILE '(' exp r_paren opt_nls
	| LEX_FOR '(' NAME LEX_IN NAME r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls exp semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_BREAK statement_term
	| LEX_CONTINUE statement_term
	| print '(' expression_list r_paren output_redir statement_term
	| print opt_rexpression_list output_redir statement_term
	| LEX_NEXT statement_term
	| LEX_NEXTFILE statement_term
	| LEX_EXIT opt_exp statement_term
	| LEX_RETURN {} opt_exp statement_term
	| LEX_DELETE NAME '[' expression_list ']' statement_term
	| LEX_DELETE NAME  statement_term
	| exp statement_term
	;

print
	: LEX_PRINT
	| LEX_PRINTF
	;

if_statement
	: LEX_IF '(' exp r_paren opt_nls statement
	| LEX_IF '(' exp r_paren opt_nls statement
	     LEX_ELSE opt_nls statement
	;

nls
	: NEWLINE
	| nls NEWLINE
	;

opt_nls
	: /* empty */
	| nls
	;

input_redir
	: /* empty */
	| '<' simp_exp
	;

output_redir
	: /* empty */
	| '>' exp
	| APPEND_OP exp
	| '|' exp
	| TWOWAYIO exp
	;

opt_param_list
	: /* empty */
	| param_list
	;

param_list
	: NAME
	| param_list comma NAME
	| error
	| param_list error
	| param_list comma error
	;

/* optional expression, as in for loop */
opt_exp
	: /* empty */
	| exp
	;

opt_rexpression_list
	: /* empty */
	| rexpression_list
	;

rexpression_list
	: rexp
	| rexpression_list comma rexp
	| error
	| rexpression_list error
	| rexpression_list error rexp
	| rexpression_list comma error
	;

opt_expression_list
	: /* empty */
	| expression_list
	;

expression_list
	: exp
	| expression_list comma exp
	| error
	| expression_list error
	| expression_list error exp
	| expression_list comma error
	;

/* Expressions, not including the comma operator.  */
exp	: variable ASSIGNOP {} exp
	| '(' expression_list r_paren LEX_IN NAME
	| exp '|' LEX_GETLINE opt_variable
	| exp TWOWAYIO LEX_GETLINE opt_variable
	| LEX_GETLINE opt_variable input_redir
	| exp LEX_AND exp
	| exp LEX_OR exp
	| exp MATCHOP exp
	| regexp
	| '!' regexp %prec UNARY
	| exp LEX_IN NAME
	| exp RELOP exp
	| exp '<' exp
	| exp '>' exp
	| exp '?' exp ':' exp
	| simp_exp
	| exp simp_exp %prec CONCAT_OP
	;

rexp
	: variable ASSIGNOP {} rexp
	| rexp LEX_AND rexp
	| rexp LEX_OR rexp
	| LEX_GETLINE opt_variable input_redir
	| regexp
	| '!' regexp %prec UNARY
	| rexp MATCHOP rexp
	| rexp LEX_IN NAME
	| rexp RELOP rexp
	| rexp '?' rexp ':' rexp
	| simp_exp
	| rexp simp_exp %prec CONCAT_OP
	;

simp_exp
	: non_post_simp_exp
	/* Binary operators in order of decreasing precedence.  */
	| simp_exp '^' simp_exp
	| simp_exp '*' simp_exp
	| simp_exp '/' simp_exp
	| simp_exp '%' simp_exp
	| simp_exp '+' simp_exp
	| simp_exp '-' simp_exp
	| variable INCREMENT
	| variable DECREMENT
	;

non_post_simp_exp
	: '!' simp_exp %prec UNARY
	| '(' exp r_paren
	| LEX_BUILTIN
	  '(' opt_expression_list r_paren
	| LEX_LENGTH '(' opt_expression_list r_paren
	| LEX_LENGTH
	| FUNC_CALL '(' opt_expression_list r_paren
	| variable
	| INCREMENT variable
	| DECREMENT variable
	| YNUMBER
	| YSTRING
	| '-' simp_exp    %prec UNARY
	| '+' simp_exp    %prec UNARY
	;

opt_variable
	: /* empty */
	| variable
	;

variable
	: NAME
	| NAME '[' expression_list ']'
	| '$' non_post_simp_exp
	;

l_brace
	: '{' opt_nls
	;

r_brace
	: '}' opt_nls
	;

r_paren
	: ')'
	;

opt_semi
	: /* empty */
	| semi
	;

semi
	: ';'
	;

comma	: ',' opt_nls
	;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    LEX_GETLINE, '$', '!', YNUMBER, '*', YNUMBER, ';', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:76: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:76"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:76: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:76"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:76"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:76"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:76: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:76"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 65 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76: sed -n 's/^state //p' input.output | tail -1"
at_fn_check_prepare_notrace 'a shell pipeline' "existing.at:76"
( $at_check_trace; sed -n 's/^state //p' input.output | tail -1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "319
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76: sed 's/^%define lr.type .*\$//' input.y > input-lalr.y"
at_fn_check_prepare_dynamic "sed 's/^%define lr.type .*$//' input.y > input-lalr.y" "existing.at:76"
( $at_check_trace; sed 's/^%define lr.type .*$//' input.y > input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:76: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input-lalr.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:76"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:76: bison --xml=xml-tests/test.xml --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:76"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:76"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:76"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:76: bison --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:76"
( $at_check_trace; bison --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/existing.at:76: diff -u input-lalr.output input.output \\
           | sed -n '/^@@/,\$p' | sed 's/^ \$//'"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:76"
( $at_check_trace; diff -u input-lalr.output input.output \
           | sed -n '/^@@/,$p' | sed 's/^ $//'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "existing.at:76"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "existing.at:76"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '*', expecting NEWLINE or '{' or ';'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_217
#AT_START_218
at_fn_group_banner 218 'existing.at:76' \
  "GNU AWK 3.1.0 Grammar: IELR(1)" "                 " 16
at_xfail=no
(
  $as_echo "218. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type ielr
%error-verbose

%token FUNC_CALL NAME REGEXP
%token ERROR
%token YNUMBER YSTRING
%token RELOP APPEND_OP
%token ASSIGNOP MATCHOP NEWLINE CONCAT_OP
%token LEX_BEGIN LEX_END LEX_IF LEX_ELSE LEX_RETURN LEX_DELETE
%token LEX_WHILE LEX_DO LEX_FOR LEX_BREAK LEX_CONTINUE
%token LEX_PRINT LEX_PRINTF LEX_NEXT LEX_EXIT LEX_FUNCTION
%token LEX_GETLINE LEX_NEXTFILE
%token LEX_IN
%token LEX_AND LEX_OR INCREMENT DECREMENT
%token LEX_BUILTIN LEX_LENGTH

/* Lowest to highest */
%right ASSIGNOP
%right '?' ':'
%left LEX_OR
%left LEX_AND
%left LEX_GETLINE
%nonassoc LEX_IN
%left FUNC_CALL LEX_BUILTIN LEX_LENGTH
%nonassoc ','
%nonassoc MATCHOP
%nonassoc RELOP '<' '>' '|' APPEND_OP TWOWAYIO
%left CONCAT_OP
%left YSTRING YNUMBER
%left '+' '-'
%left '*' '/' '%'
%right '!' UNARY
%right '^'
%left INCREMENT DECREMENT
%left '$'
%left '(' ')'


%%


start
	: opt_nls program opt_nls
	;

program
	: rule
	| program rule
	| error
	| program error
	| /* empty */
	;

rule
	: LEX_BEGIN {} action
	| LEX_END {}   action
	| LEX_BEGIN statement_term
	| LEX_END statement_term
	| pattern action
	| action
	| pattern statement_term
	| function_prologue function_body
	;

func_name
	: NAME
	| FUNC_CALL
	| lex_builtin
	;

lex_builtin
	: LEX_BUILTIN
	| LEX_LENGTH
	;

function_prologue
	: LEX_FUNCTION {} func_name '(' opt_param_list r_paren opt_nls
	;

function_body
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

pattern
	: exp
	| exp ',' exp
	;

regexp
	/*
	 * In this rule, want_regexp tells yylex that the next thing
	 * is a regexp so it should read up to the closing slash.
	 */
	: '/' {} REGEXP '/'
	;

action
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

statements
	: statement
	| statements statement
	| error
	| statements error
	;

statement_term
	: nls
	| semi opt_nls
	;

statement
	: semi opt_nls
	| l_brace r_brace
	| l_brace statements r_brace
	| if_statement
	| LEX_WHILE '(' exp r_paren opt_nls statement
	| LEX_DO opt_nls statement LEX_WHILE '(' exp r_paren opt_nls
	| LEX_FOR '(' NAME LEX_IN NAME r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls exp semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_BREAK statement_term
	| LEX_CONTINUE statement_term
	| print '(' expression_list r_paren output_redir statement_term
	| print opt_rexpression_list output_redir statement_term
	| LEX_NEXT statement_term
	| LEX_NEXTFILE statement_term
	| LEX_EXIT opt_exp statement_term
	| LEX_RETURN {} opt_exp statement_term
	| LEX_DELETE NAME '[' expression_list ']' statement_term
	| LEX_DELETE NAME  statement_term
	| exp statement_term
	;

print
	: LEX_PRINT
	| LEX_PRINTF
	;

if_statement
	: LEX_IF '(' exp r_paren opt_nls statement
	| LEX_IF '(' exp r_paren opt_nls statement
	     LEX_ELSE opt_nls statement
	;

nls
	: NEWLINE
	| nls NEWLINE
	;

opt_nls
	: /* empty */
	| nls
	;

input_redir
	: /* empty */
	| '<' simp_exp
	;

output_redir
	: /* empty */
	| '>' exp
	| APPEND_OP exp
	| '|' exp
	| TWOWAYIO exp
	;

opt_param_list
	: /* empty */
	| param_list
	;

param_list
	: NAME
	| param_list comma NAME
	| error
	| param_list error
	| param_list comma error
	;

/* optional expression, as in for loop */
opt_exp
	: /* empty */
	| exp
	;

opt_rexpression_list
	: /* empty */
	| rexpression_list
	;

rexpression_list
	: rexp
	| rexpression_list comma rexp
	| error
	| rexpression_list error
	| rexpression_list error rexp
	| rexpression_list comma error
	;

opt_expression_list
	: /* empty */
	| expression_list
	;

expression_list
	: exp
	| expression_list comma exp
	| error
	| expression_list error
	| expression_list error exp
	| expression_list comma error
	;

/* Expressions, not including the comma operator.  */
exp	: variable ASSIGNOP {} exp
	| '(' expression_list r_paren LEX_IN NAME
	| exp '|' LEX_GETLINE opt_variable
	| exp TWOWAYIO LEX_GETLINE opt_variable
	| LEX_GETLINE opt_variable input_redir
	| exp LEX_AND exp
	| exp LEX_OR exp
	| exp MATCHOP exp
	| regexp
	| '!' regexp %prec UNARY
	| exp LEX_IN NAME
	| exp RELOP exp
	| exp '<' exp
	| exp '>' exp
	| exp '?' exp ':' exp
	| simp_exp
	| exp simp_exp %prec CONCAT_OP
	;

rexp
	: variable ASSIGNOP {} rexp
	| rexp LEX_AND rexp
	| rexp LEX_OR rexp
	| LEX_GETLINE opt_variable input_redir
	| regexp
	| '!' regexp %prec UNARY
	| rexp MATCHOP rexp
	| rexp LEX_IN NAME
	| rexp RELOP rexp
	| rexp '?' rexp ':' rexp
	| simp_exp
	| rexp simp_exp %prec CONCAT_OP
	;

simp_exp
	: non_post_simp_exp
	/* Binary operators in order of decreasing precedence.  */
	| simp_exp '^' simp_exp
	| simp_exp '*' simp_exp
	| simp_exp '/' simp_exp
	| simp_exp '%' simp_exp
	| simp_exp '+' simp_exp
	| simp_exp '-' simp_exp
	| variable INCREMENT
	| variable DECREMENT
	;

non_post_simp_exp
	: '!' simp_exp %prec UNARY
	| '(' exp r_paren
	| LEX_BUILTIN
	  '(' opt_expression_list r_paren
	| LEX_LENGTH '(' opt_expression_list r_paren
	| LEX_LENGTH
	| FUNC_CALL '(' opt_expression_list r_paren
	| variable
	| INCREMENT variable
	| DECREMENT variable
	| YNUMBER
	| YSTRING
	| '-' simp_exp    %prec UNARY
	| '+' simp_exp    %prec UNARY
	;

opt_variable
	: /* empty */
	| variable
	;

variable
	: NAME
	| NAME '[' expression_list ']'
	| '$' non_post_simp_exp
	;

l_brace
	: '{' opt_nls
	;

r_brace
	: '}' opt_nls
	;

r_paren
	: ')'
	;

opt_semi
	: /* empty */
	| semi
	;

semi
	: ';'
	;

comma	: ',' opt_nls
	;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    LEX_GETLINE, '$', '!', YNUMBER, '*', YNUMBER, ';', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:76: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:76"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:76: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:76"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:76"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:76"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:76: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:76"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 65 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76: sed -n 's/^state //p' input.output | tail -1"
at_fn_check_prepare_notrace 'a shell pipeline' "existing.at:76"
( $at_check_trace; sed -n 's/^state //p' input.output | tail -1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "328
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76: sed 's/^%define lr.type .*\$//' input.y > input-lalr.y"
at_fn_check_prepare_dynamic "sed 's/^%define lr.type .*$//' input.y > input-lalr.y" "existing.at:76"
( $at_check_trace; sed 's/^%define lr.type .*$//' input.y > input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:76: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input-lalr.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:76"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:76: bison --xml=xml-tests/test.xml --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:76"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:76"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:76"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:76: bison --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:76"
( $at_check_trace; bison --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/existing.at:76: diff -u input-lalr.output input.output \\
           | sed -n '/^@@/,\$p' | sed 's/^ \$//'"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:76"
( $at_check_trace; diff -u input-lalr.output input.output \
           | sed -n '/^@@/,$p' | sed 's/^ $//'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "@@ -712,7 +712,7 @@
   156         | . '\$' non_post_simp_exp

     NAME  shift, and go to state 9
-    '\$'   shift, and go to state 24
+    '\$'   shift, and go to state 320

     NAME      [reduce using rule 152 (opt_variable)]
     '\$'       [reduce using rule 152 (opt_variable)]
@@ -5379,7 +5379,7 @@
   156         | . '\$' non_post_simp_exp

     NAME  shift, and go to state 9
-    '\$'   shift, and go to state 24
+    '\$'   shift, and go to state 320

     NAME      [reduce using rule 152 (opt_variable)]
     '\$'       [reduce using rule 152 (opt_variable)]
@@ -5399,7 +5399,7 @@
   156         | . '\$' non_post_simp_exp

     NAME  shift, and go to state 9
-    '\$'   shift, and go to state 24
+    '\$'   shift, and go to state 320

     NAME      [reduce using rule 152 (opt_variable)]
     '\$'       [reduce using rule 152 (opt_variable)]
@@ -6214,7 +6214,7 @@
   156         | . '\$' non_post_simp_exp

     NAME  shift, and go to state 9
-    '\$'   shift, and go to state 24
+    '\$'   shift, and go to state 320

     NAME      [reduce using rule 152 (opt_variable)]
     '\$'       [reduce using rule 152 (opt_variable)]
@@ -11099,3 +11099,274 @@
    45 statement: LEX_FOR '(' opt_exp semi opt_nls exp semi opt_nls opt_exp r_paren opt_nls statement .

     \$default  reduce using rule 45 (statement)
+
+
+state 320
+
+  139 non_post_simp_exp: . '!' simp_exp
+  140                  | . '(' exp r_paren
+  141                  | . LEX_BUILTIN '(' opt_expression_list r_paren
+  142                  | . LEX_LENGTH '(' opt_expression_list r_paren
+  143                  | . LEX_LENGTH
+  144                  | . FUNC_CALL '(' opt_expression_list r_paren
+  145                  | . variable
+  146                  | . INCREMENT variable
+  147                  | . DECREMENT variable
+  148                  | . YNUMBER
+  149                  | . YSTRING
+  150                  | . '-' simp_exp
+  151                  | . '+' simp_exp
+  154 variable: . NAME
+  155         | . NAME '[' expression_list ']'
+  156         | . '\$' non_post_simp_exp
+  156         | '\$' . non_post_simp_exp
+
+    FUNC_CALL    shift, and go to state 8
+    NAME         shift, and go to state 9
+    YNUMBER      shift, and go to state 10
+    YSTRING      shift, and go to state 11
+    INCREMENT    shift, and go to state 321
+    DECREMENT    shift, and go to state 322
+    LEX_BUILTIN  shift, and go to state 18
+    LEX_LENGTH   shift, and go to state 19
+    '+'          shift, and go to state 323
+    '-'          shift, and go to state 324
+    '!'          shift, and go to state 325
+    '\$'          shift, and go to state 320
+    '('          shift, and go to state 55
+
+    non_post_simp_exp  go to state 62
+    variable           go to state 63
+
+
+state 321
+
+  146 non_post_simp_exp: INCREMENT . variable
+  154 variable: . NAME
+  155         | . NAME '[' expression_list ']'
+  156         | . '\$' non_post_simp_exp
+
+    NAME  shift, and go to state 9
+    '\$'   shift, and go to state 320
+
+    variable  go to state 50
+
+
+state 322
+
+  147 non_post_simp_exp: DECREMENT . variable
+  154 variable: . NAME
+  155         | . NAME '[' expression_list ']'
+  156         | . '\$' non_post_simp_exp
+
+    NAME  shift, and go to state 9
+    '\$'   shift, and go to state 320
+
+    variable  go to state 51
+
+
+state 323
+
+  130 simp_exp: . non_post_simp_exp
+  131         | . simp_exp '^' simp_exp
+  132         | . simp_exp '*' simp_exp
+  133         | . simp_exp '/' simp_exp
+  134         | . simp_exp '%' simp_exp
+  135         | . simp_exp '+' simp_exp
+  136         | . simp_exp '-' simp_exp
+  137         | . variable INCREMENT
+  138         | . variable DECREMENT
+  139 non_post_simp_exp: . '!' simp_exp
+  140                  | . '(' exp r_paren
+  141                  | . LEX_BUILTIN '(' opt_expression_list r_paren
+  142                  | . LEX_LENGTH '(' opt_expression_list r_paren
+  143                  | . LEX_LENGTH
+  144                  | . FUNC_CALL '(' opt_expression_list r_paren
+  145                  | . variable
+  146                  | . INCREMENT variable
+  147                  | . DECREMENT variable
+  148                  | . YNUMBER
+  149                  | . YSTRING
+  150                  | . '-' simp_exp
+  151                  | . '+' simp_exp
+  151                  | '+' . simp_exp
+  154 variable: . NAME
+  155         | . NAME '[' expression_list ']'
+  156         | . '\$' non_post_simp_exp
+
+    FUNC_CALL    shift, and go to state 8
+    NAME         shift, and go to state 9
+    YNUMBER      shift, and go to state 10
+    YSTRING      shift, and go to state 11
+    INCREMENT    shift, and go to state 16
+    DECREMENT    shift, and go to state 17
+    LEX_BUILTIN  shift, and go to state 18
+    LEX_LENGTH   shift, and go to state 19
+    '+'          shift, and go to state 20
+    '-'          shift, and go to state 21
+    '!'          shift, and go to state 54
+    '\$'          shift, and go to state 24
+    '('          shift, and go to state 55
+
+    simp_exp           go to state 326
+    non_post_simp_exp  go to state 35
+    variable           go to state 57
+
+
+state 324
+
+  130 simp_exp: . non_post_simp_exp
+  131         | . simp_exp '^' simp_exp
+  132         | . simp_exp '*' simp_exp
+  133         | . simp_exp '/' simp_exp
+  134         | . simp_exp '%' simp_exp
+  135         | . simp_exp '+' simp_exp
+  136         | . simp_exp '-' simp_exp
+  137         | . variable INCREMENT
+  138         | . variable DECREMENT
+  139 non_post_simp_exp: . '!' simp_exp
+  140                  | . '(' exp r_paren
+  141                  | . LEX_BUILTIN '(' opt_expression_list r_paren
+  142                  | . LEX_LENGTH '(' opt_expression_list r_paren
+  143                  | . LEX_LENGTH
+  144                  | . FUNC_CALL '(' opt_expression_list r_paren
+  145                  | . variable
+  146                  | . INCREMENT variable
+  147                  | . DECREMENT variable
+  148                  | . YNUMBER
+  149                  | . YSTRING
+  150                  | . '-' simp_exp
+  150                  | '-' . simp_exp
+  151                  | . '+' simp_exp
+  154 variable: . NAME
+  155         | . NAME '[' expression_list ']'
+  156         | . '\$' non_post_simp_exp
+
+    FUNC_CALL    shift, and go to state 8
+    NAME         shift, and go to state 9
+    YNUMBER      shift, and go to state 10
+    YSTRING      shift, and go to state 11
+    INCREMENT    shift, and go to state 16
+    DECREMENT    shift, and go to state 17
+    LEX_BUILTIN  shift, and go to state 18
+    LEX_LENGTH   shift, and go to state 19
+    '+'          shift, and go to state 20
+    '-'          shift, and go to state 21
+    '!'          shift, and go to state 54
+    '\$'          shift, and go to state 24
+    '('          shift, and go to state 55
+
+    simp_exp           go to state 327
+    non_post_simp_exp  go to state 35
+    variable           go to state 57
+
+
+state 325
+
+  130 simp_exp: . non_post_simp_exp
+  131         | . simp_exp '^' simp_exp
+  132         | . simp_exp '*' simp_exp
+  133         | . simp_exp '/' simp_exp
+  134         | . simp_exp '%' simp_exp
+  135         | . simp_exp '+' simp_exp
+  136         | . simp_exp '-' simp_exp
+  137         | . variable INCREMENT
+  138         | . variable DECREMENT
+  139 non_post_simp_exp: . '!' simp_exp
+  139                  | '!' . simp_exp
+  140                  | . '(' exp r_paren
+  141                  | . LEX_BUILTIN '(' opt_expression_list r_paren
+  142                  | . LEX_LENGTH '(' opt_expression_list r_paren
+  143                  | . LEX_LENGTH
+  144                  | . FUNC_CALL '(' opt_expression_list r_paren
+  145                  | . variable
+  146                  | . INCREMENT variable
+  147                  | . DECREMENT variable
+  148                  | . YNUMBER
+  149                  | . YSTRING
+  150                  | . '-' simp_exp
+  151                  | . '+' simp_exp
+  154 variable: . NAME
+  155         | . NAME '[' expression_list ']'
+  156         | . '\$' non_post_simp_exp
+
+    FUNC_CALL    shift, and go to state 8
+    NAME         shift, and go to state 9
+    YNUMBER      shift, and go to state 10
+    YSTRING      shift, and go to state 11
+    INCREMENT    shift, and go to state 16
+    DECREMENT    shift, and go to state 17
+    LEX_BUILTIN  shift, and go to state 18
+    LEX_LENGTH   shift, and go to state 19
+    '+'          shift, and go to state 20
+    '-'          shift, and go to state 21
+    '!'          shift, and go to state 54
+    '\$'          shift, and go to state 24
+    '('          shift, and go to state 55
+
+    simp_exp           go to state 328
+    non_post_simp_exp  go to state 35
+    variable           go to state 57
+
+
+state 326
+
+  131 simp_exp: simp_exp . '^' simp_exp
+  132         | simp_exp . '*' simp_exp
+  133         | simp_exp . '/' simp_exp
+  134         | simp_exp . '%' simp_exp
+  135         | simp_exp . '+' simp_exp
+  136         | simp_exp . '-' simp_exp
+  151 non_post_simp_exp: '+' simp_exp .  [error, FUNC_CALL, NAME, YNUMBER, YSTRING, RELOP, APPEND_OP, MATCHOP, NEWLINE, LEX_IN, LEX_AND, LEX_OR, INCREMENT, DECREMENT, LEX_BUILTIN, LEX_LENGTH, '?', ':', ',', '<', '>', '|', TWOWAYIO, '+', '-', '!', '\$', '(', ')', ']', '{', ';']
+
+    '*'  shift, and go to state 89
+    '/'  shift, and go to state 90
+    '%'  shift, and go to state 91
+    '^'  shift, and go to state 92
+
+    \$default  reduce using rule 151 (non_post_simp_exp)
+
+    Conflict between rule 151 and token '+' resolved as reduce ('+' < UNARY).
+    Conflict between rule 151 and token '-' resolved as reduce ('-' < UNARY).
+
+
+state 327
+
+  131 simp_exp: simp_exp . '^' simp_exp
+  132         | simp_exp . '*' simp_exp
+  133         | simp_exp . '/' simp_exp
+  134         | simp_exp . '%' simp_exp
+  135         | simp_exp . '+' simp_exp
+  136         | simp_exp . '-' simp_exp
+  150 non_post_simp_exp: '-' simp_exp .  [error, FUNC_CALL, NAME, YNUMBER, YSTRING, RELOP, APPEND_OP, MATCHOP, NEWLINE, LEX_IN, LEX_AND, LEX_OR, INCREMENT, DECREMENT, LEX_BUILTIN, LEX_LENGTH, '?', ':', ',', '<', '>', '|', TWOWAYIO, '+', '-', '!', '\$', '(', ')', ']', '{', ';']
+
+    '*'  shift, and go to state 89
+    '/'  shift, and go to state 90
+    '%'  shift, and go to state 91
+    '^'  shift, and go to state 92
+
+    \$default  reduce using rule 150 (non_post_simp_exp)
+
+    Conflict between rule 150 and token '+' resolved as reduce ('+' < UNARY).
+    Conflict between rule 150 and token '-' resolved as reduce ('-' < UNARY).
+
+
+state 328
+
+  131 simp_exp: simp_exp . '^' simp_exp
+  132         | simp_exp . '*' simp_exp
+  133         | simp_exp . '/' simp_exp
+  134         | simp_exp . '%' simp_exp
+  135         | simp_exp . '+' simp_exp
+  136         | simp_exp . '-' simp_exp
+  139 non_post_simp_exp: '!' simp_exp .  [error, FUNC_CALL, NAME, YNUMBER, YSTRING, RELOP, APPEND_OP, MATCHOP, NEWLINE, LEX_IN, LEX_AND, LEX_OR, INCREMENT, DECREMENT, LEX_BUILTIN, LEX_LENGTH, '?', ':', ',', '<', '>', '|', TWOWAYIO, '+', '-', '!', '\$', '(', ')', ']', '{', ';']
+
+    '*'  shift, and go to state 89
+    '/'  shift, and go to state 90
+    '%'  shift, and go to state 91
+    '^'  shift, and go to state 92
+
+    \$default  reduce using rule 139 (non_post_simp_exp)
+
+    Conflict between rule 139 and token '+' resolved as reduce ('+' < UNARY).
+    Conflict between rule 139 and token '-' resolved as reduce ('-' < UNARY).
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "existing.at:76"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "existing.at:76"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_218
#AT_START_219
at_fn_group_banner 219 'existing.at:76' \
  "GNU AWK 3.1.0 Grammar: Canonical LR(1)" "         " 16
at_xfail=no
(
  $as_echo "219. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type canonical-lr
%error-verbose

%token FUNC_CALL NAME REGEXP
%token ERROR
%token YNUMBER YSTRING
%token RELOP APPEND_OP
%token ASSIGNOP MATCHOP NEWLINE CONCAT_OP
%token LEX_BEGIN LEX_END LEX_IF LEX_ELSE LEX_RETURN LEX_DELETE
%token LEX_WHILE LEX_DO LEX_FOR LEX_BREAK LEX_CONTINUE
%token LEX_PRINT LEX_PRINTF LEX_NEXT LEX_EXIT LEX_FUNCTION
%token LEX_GETLINE LEX_NEXTFILE
%token LEX_IN
%token LEX_AND LEX_OR INCREMENT DECREMENT
%token LEX_BUILTIN LEX_LENGTH

/* Lowest to highest */
%right ASSIGNOP
%right '?' ':'
%left LEX_OR
%left LEX_AND
%left LEX_GETLINE
%nonassoc LEX_IN
%left FUNC_CALL LEX_BUILTIN LEX_LENGTH
%nonassoc ','
%nonassoc MATCHOP
%nonassoc RELOP '<' '>' '|' APPEND_OP TWOWAYIO
%left CONCAT_OP
%left YSTRING YNUMBER
%left '+' '-'
%left '*' '/' '%'
%right '!' UNARY
%right '^'
%left INCREMENT DECREMENT
%left '$'
%left '(' ')'


%%


start
	: opt_nls program opt_nls
	;

program
	: rule
	| program rule
	| error
	| program error
	| /* empty */
	;

rule
	: LEX_BEGIN {} action
	| LEX_END {}   action
	| LEX_BEGIN statement_term
	| LEX_END statement_term
	| pattern action
	| action
	| pattern statement_term
	| function_prologue function_body
	;

func_name
	: NAME
	| FUNC_CALL
	| lex_builtin
	;

lex_builtin
	: LEX_BUILTIN
	| LEX_LENGTH
	;

function_prologue
	: LEX_FUNCTION {} func_name '(' opt_param_list r_paren opt_nls
	;

function_body
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

pattern
	: exp
	| exp ',' exp
	;

regexp
	/*
	 * In this rule, want_regexp tells yylex that the next thing
	 * is a regexp so it should read up to the closing slash.
	 */
	: '/' {} REGEXP '/'
	;

action
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

statements
	: statement
	| statements statement
	| error
	| statements error
	;

statement_term
	: nls
	| semi opt_nls
	;

statement
	: semi opt_nls
	| l_brace r_brace
	| l_brace statements r_brace
	| if_statement
	| LEX_WHILE '(' exp r_paren opt_nls statement
	| LEX_DO opt_nls statement LEX_WHILE '(' exp r_paren opt_nls
	| LEX_FOR '(' NAME LEX_IN NAME r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls exp semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_BREAK statement_term
	| LEX_CONTINUE statement_term
	| print '(' expression_list r_paren output_redir statement_term
	| print opt_rexpression_list output_redir statement_term
	| LEX_NEXT statement_term
	| LEX_NEXTFILE statement_term
	| LEX_EXIT opt_exp statement_term
	| LEX_RETURN {} opt_exp statement_term
	| LEX_DELETE NAME '[' expression_list ']' statement_term
	| LEX_DELETE NAME  statement_term
	| exp statement_term
	;

print
	: LEX_PRINT
	| LEX_PRINTF
	;

if_statement
	: LEX_IF '(' exp r_paren opt_nls statement
	| LEX_IF '(' exp r_paren opt_nls statement
	     LEX_ELSE opt_nls statement
	;

nls
	: NEWLINE
	| nls NEWLINE
	;

opt_nls
	: /* empty */
	| nls
	;

input_redir
	: /* empty */
	| '<' simp_exp
	;

output_redir
	: /* empty */
	| '>' exp
	| APPEND_OP exp
	| '|' exp
	| TWOWAYIO exp
	;

opt_param_list
	: /* empty */
	| param_list
	;

param_list
	: NAME
	| param_list comma NAME
	| error
	| param_list error
	| param_list comma error
	;

/* optional expression, as in for loop */
opt_exp
	: /* empty */
	| exp
	;

opt_rexpression_list
	: /* empty */
	| rexpression_list
	;

rexpression_list
	: rexp
	| rexpression_list comma rexp
	| error
	| rexpression_list error
	| rexpression_list error rexp
	| rexpression_list comma error
	;

opt_expression_list
	: /* empty */
	| expression_list
	;

expression_list
	: exp
	| expression_list comma exp
	| error
	| expression_list error
	| expression_list error exp
	| expression_list comma error
	;

/* Expressions, not including the comma operator.  */
exp	: variable ASSIGNOP {} exp
	| '(' expression_list r_paren LEX_IN NAME
	| exp '|' LEX_GETLINE opt_variable
	| exp TWOWAYIO LEX_GETLINE opt_variable
	| LEX_GETLINE opt_variable input_redir
	| exp LEX_AND exp
	| exp LEX_OR exp
	| exp MATCHOP exp
	| regexp
	| '!' regexp %prec UNARY
	| exp LEX_IN NAME
	| exp RELOP exp
	| exp '<' exp
	| exp '>' exp
	| exp '?' exp ':' exp
	| simp_exp
	| exp simp_exp %prec CONCAT_OP
	;

rexp
	: variable ASSIGNOP {} rexp
	| rexp LEX_AND rexp
	| rexp LEX_OR rexp
	| LEX_GETLINE opt_variable input_redir
	| regexp
	| '!' regexp %prec UNARY
	| rexp MATCHOP rexp
	| rexp LEX_IN NAME
	| rexp RELOP rexp
	| rexp '?' rexp ':' rexp
	| simp_exp
	| rexp simp_exp %prec CONCAT_OP
	;

simp_exp
	: non_post_simp_exp
	/* Binary operators in order of decreasing precedence.  */
	| simp_exp '^' simp_exp
	| simp_exp '*' simp_exp
	| simp_exp '/' simp_exp
	| simp_exp '%' simp_exp
	| simp_exp '+' simp_exp
	| simp_exp '-' simp_exp
	| variable INCREMENT
	| variable DECREMENT
	;

non_post_simp_exp
	: '!' simp_exp %prec UNARY
	| '(' exp r_paren
	| LEX_BUILTIN
	  '(' opt_expression_list r_paren
	| LEX_LENGTH '(' opt_expression_list r_paren
	| LEX_LENGTH
	| FUNC_CALL '(' opt_expression_list r_paren
	| variable
	| INCREMENT variable
	| DECREMENT variable
	| YNUMBER
	| YSTRING
	| '-' simp_exp    %prec UNARY
	| '+' simp_exp    %prec UNARY
	;

opt_variable
	: /* empty */
	| variable
	;

variable
	: NAME
	| NAME '[' expression_list ']'
	| '$' non_post_simp_exp
	;

l_brace
	: '{' opt_nls
	;

r_brace
	: '}' opt_nls
	;

r_paren
	: ')'
	;

opt_semi
	: /* empty */
	| semi
	;

semi
	: ';'
	;

comma	: ',' opt_nls
	;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    LEX_GETLINE, '$', '!', YNUMBER, '*', YNUMBER, ';', 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

{ set +x
$as_echo "$at_srcdir/existing.at:76: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:76"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 265 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76: sed -n 's/^state //p' input.output | tail -1"
at_fn_check_prepare_notrace 'a shell pipeline' "existing.at:76"
( $at_check_trace; sed -n 's/^state //p' input.output | tail -1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2358
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/existing.at:76: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "existing.at:76"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:76:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "existing.at:76"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_219
#AT_START_220
at_fn_group_banner 220 'existing.at:780' \
  "GNU Cim Grammar: LALR(1)" "                       " 16
at_xfail=no
(
  $as_echo "220. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type lalr
%union {}

%token
	HACTIVATE HAFTER /*HAND*/ HARRAY HAT
	HBEFORE HBEGIN HBOOLEAN
	HCHARACTER HCLASS /*HCOMMENT*/ HCONC
	HDELAY HDO
	HELSE HEND HEQ /*HEQV*/ HEXTERNAL
	HFOR
	HGE HGO HGOTO HGT
	HHIDDEN
	HIF /*HIMP*/ HIN HINNER HINSPECT HINTEGER HIS
	HLABEL HLE HLONG HLT
	HNAME HNE HNEW HNONE /*HNOT*/ HNOTEXT
	/*HOR*/ HOTHERWISE
	HPRIOR HPROCEDURE HPROTECTED
	HQUA
	HREACTIVATE HREAL HREF
	HSHORT HSTEP HSWITCH
	HTEXT HTHEN HTHIS HTO
	HUNTIL
	HVALUE HVAR HVIRTUAL
	HWHEN HWHILE

	HASSIGNVALUE HASSIGNREF
	/*HDOT*/ HPAREXPSEPARATOR HLABELSEPARATOR HSTATEMENTSEPARATOR
	HBEGPAR HENDPAR
	HEQR HNER
	HADD HSUB HMUL HDIV HINTDIV HEXP
	HDOTDOTDOT

%token HIDENTIFIER
%token HBOOLEANKONST HINTEGERKONST HCHARACTERKONST
%token HREALKONST
%token HTEXTKONST


%right HASSIGN
%left   HORELSE
%left   HANDTHEN
%left   HEQV
%left   HIMP
%left   HOR
%left   HAND

%left   HNOT

%left HVALRELOPERATOR HREFRELOPERATOR HOBJRELOPERATOR

%left	HCONC

%left HTERMOPERATOR
%left UNEAR
%left HFACTOROPERATOR
%left         HPRIMARYOPERATOR

%left   HQUA

%left   HDOT

%start  MAIN_MODULE


%%


/* GRAMATIKK FOR PROGRAM MODULES */
MAIN_MODULE     :       {}
			MODULS
		|	error HSTATEMENTSEPARATOR MBEE_DECLSTMS
		;
EXT_DECLARATION	:	HEXTERNAL
			MBEE_TYPE
			HPROCEDURE
				{}
			EXT_LIST
		|
			HEXTERNAL
			HIDENTIFIER
			HPROCEDURE
				{}
			HIDENTIFIER {}
			EXTERNAL_KIND_ITEM
		|	HEXTERNAL
			HCLASS
				{}
			EXT_LIST

		;
EXTERNAL_KIND_ITEM:	EXT_IDENT
			HOBJRELOPERATOR
				{}
			MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{}
			HEADING EMPTY_BLOCK
				{}
/*		|
			EXT_IDENT
				{}
			MBEE_REST_EXT_LIST
		;
MBEE_REST_EXT_LIST:	/* EMPTY
		|	HPAREXPSEPARATOR EXT_KIND_LIST
		;
EXT_KIND_LIST	:	EXT_KIND_ITEM
		|	EXT_KIND_LIST HPAREXPSEPARATOR EXT_KIND_ITEM
		;
EXT_KIND_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{}*/
		;
EMPTY_BLOCK	:	/*EMPT*/
		|	HBEGIN HEND
		;
EXT_LIST	:	EXT_ITEM
		|	EXT_LIST HPAREXPSEPARATOR EXT_ITEM
		;
EXT_ITEM	:	HIDENTIFIER
			EXT_IDENT
		;
EXT_IDENT	:	/* EMPTY */
		|	HVALRELOPERATOR {}
			HTEXTKONST
		;
/* GRAMATIKK FOR TYPER */
NO_TYPE         :       /*EMPT*/
		;
MBEE_TYPE       :       NO_TYPE
		|       TYPE
		;
TYPE            :       HREF HBEGPAR
			HIDENTIFIER
				{}
			HENDPAR
		|       HTEXT
		|       HBOOLEAN
		|       HCHARACTER
		|       HSHORT HINTEGER
		|       HINTEGER
		|       HREAL
		|       HLONG HREAL
		;

/* GRAMATIKK FOR DEL AV SETNINGER */
MBEE_ELSE_PART  :       /*EMPT*/
/*		|	HELSE
			HIF
			EXPRESSION
			HTHEN   {}
			BLOCK   {}
			MBEE_ELSE_PART          {}*/
		|       HELSE   {}
			BLOCK
		;
FOR_LIST        :       FOR_LIST_ELEMENT
		|       FOR_LIST_ELEMENT
			HPAREXPSEPARATOR
			FOR_LIST
		;
FOR_LIST_ELEMENT:       EXPRESSION
			MBEE_F_L_EL_R_PT
		;
MBEE_F_L_EL_R_PT:       /*EMPT*/
		|       HWHILE
			EXPRESSION
		|       HSTEP
			EXPRESSION
			HUNTIL
			EXPRESSION
		;
GOTO            :       HGO
			HTO
		|       HGOTO
		;
CONN_STATE_R_PT :       WHEN_CLAUSE_LIST
		|       HDO   {}
			BLOCK
		;
WHEN_CLAUSE_LIST:       HWHEN
			HIDENTIFIER
			HDO    {}
			BLOCK
		|       WHEN_CLAUSE_LIST
			HWHEN
			HIDENTIFIER
			HDO    {}
			BLOCK
		;
MBEE_OTWI_CLAUS :       /*EMPT*/
		|       HOTHERWISE {}

			BLOCK
		;
ACTIVATOR	:	HACTIVATE
		|	HREACTIVATE
		;
SCHEDULE	:	/*EMPT*/
		|	ATDELAY EXPRESSION	{}
			PRIOR
		|	BEFOREAFTER		{}
			EXPRESSION
		;
ATDELAY		:	HAT
		|	HDELAY
		;
BEFOREAFTER	:	HBEFORE
		|	HAFTER
		;
PRIOR		:	/*EMPT*/
		|	HPRIOR
		;
/* GRAMATIKK FOR SETNINGER OG DEKLARASJONER */
MODULSTATEMENT  :       HWHILE
			EXPRESSION
			HDO     {}
			BLOCK
		|       HIF
			EXPRESSION
			HTHEN   {}
			BLOCK   {}
			MBEE_ELSE_PART
		|       HFOR
			HIDENTIFIER
			HASSIGN {}
			FOR_LIST
			HDO     {}
			BLOCK
		|       GOTO
			EXPRESSION
		|       HINSPECT
			EXPRESSION              {}
			CONN_STATE_R_PT
				{}
			MBEE_OTWI_CLAUS
		|       HINNER
		|       HIDENTIFIER
			HLABELSEPARATOR
				{}
			DECLSTATEMENT
		|       EXPRESSION_SIMP
			HBEGIN
				{}
			IMPORT_SPEC_MODULE
				{}
			MBEE_DECLSTMS
			HEND
		|	EXPRESSION_SIMP HBEGIN error HSTATEMENTSEPARATOR
			MBEE_DECLSTMS HEND
		|	EXPRESSION_SIMP HBEGIN error HEND
		|       EXPRESSION_SIMP
		|	ACTIVATOR EXPRESSION SCHEDULE
		|       HBEGIN
				{}
			MBEE_DECLSTMS
			HEND
		|       MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{}
			HEADING BLOCK
		|       HIDENTIFIER
			HCLASS
			NO_TYPE
				{}
			IMPORT_SPEC_MODULE
			HIDENTIFIER
				{}
			HEADING
			BLOCK
		|       HCLASS
			NO_TYPE
			HIDENTIFIER
				{}
			HEADING
			BLOCK
		|       EXT_DECLARATION
		|       /*EMPT*/
		;
IMPORT_SPEC_MODULE:
		;
DECLSTATEMENT	:	MODULSTATEMENT
		|       TYPE
			HIDENTIFIER
			MBEE_CONSTANT
			HPAREXPSEPARATOR
				{}
			IDENTIFIER_LISTC
		|       TYPE
			HIDENTIFIER
			MBEE_CONSTANT
		|       MBEE_TYPE
			HARRAY  {}
			ARR_SEGMENT_LIST
		|       HSWITCH
			HIDENTIFIER
			HASSIGN {}
			SWITCH_LIST
		;
BLOCK           :       DECLSTATEMENT
		|       HBEGIN MBEE_DECLSTMS HEND
		|	HBEGIN error HSTATEMENTSEPARATOR MBEE_DECLSTMS HEND
		|	HBEGIN error HEND
		;
MBEE_DECLSTMS   :       MBEE_DECLSTMSU
		;
MBEE_DECLSTMSU  :       DECLSTATEMENT
		|       MBEE_DECLSTMSU
			HSTATEMENTSEPARATOR
			DECLSTATEMENT
		;
MODULS		:	MODULSTATEMENT
		|	MODULS HSTATEMENTSEPARATOR MODULSTATEMENT
		;
/* GRAMATIKK FOR DEL AV DEKLARASJONER */
ARR_SEGMENT_LIST:       ARR_SEGMENT
		|       ARR_SEGMENT_LIST
			HPAREXPSEPARATOR
			ARR_SEGMENT
		;
ARR_SEGMENT	:       ARRAY_SEGMENT
			HBEGPAR
			BAUND_PAIR_LIST HENDPAR
		;
ARRAY_SEGMENT   :       ARRAY_SEGMENT_EL        {}

		|       ARRAY_SEGMENT_EL
			HPAREXPSEPARATOR
			ARRAY_SEGMENT
		;
ARRAY_SEGMENT_EL:       HIDENTIFIER
		;
BAUND_PAIR_LIST :       BAUND_PAIR
		|       BAUND_PAIR
			HPAREXPSEPARATOR
			BAUND_PAIR_LIST
		;
BAUND_PAIR      :       EXPRESSION
			HLABELSEPARATOR
			EXPRESSION
		;
SWITCH_LIST     :       EXPRESSION
		|       EXPRESSION
			HPAREXPSEPARATOR
			SWITCH_LIST
		;
HEADING         :       MBEE_FMAL_PAR_P HSTATEMENTSEPARATOR {}
			MBEE_MODE_PART  {}
			MBEE_SPEC_PART  {}
			MBEE_PROT_PART  {}
			MBEE_VIRT_PART
		;
MBEE_FMAL_PAR_P :       /*EMPT*/
		|       FMAL_PAR_PART
		;
FMAL_PAR_PART   :       HBEGPAR NO_TYPE
			MBEE_LISTV HENDPAR
		;
MBEE_LISTV      :       /*EMPT*/
		|       LISTV
		;
LISTV           :       HIDENTIFIER
		|	FPP_CATEG HDOTDOTDOT
		|       HIDENTIFIER     {}
			HPAREXPSEPARATOR LISTV
		|       FPP_SPEC
		|       FPP_SPEC
			HPAREXPSEPARATOR LISTV
		;
FPP_HEADING     :       HBEGPAR NO_TYPE
			FPP_MBEE_LISTV HENDPAR
		;
FPP_MBEE_LISTV  :       /*EMPT*/
		|       FPP_LISTV
		;
FPP_LISTV       :	FPP_CATEG HDOTDOTDOT
		|       FPP_SPEC
		|       FPP_SPEC
			HPAREXPSEPARATOR LISTV
		;
FPP_SPEC        :       FPP_CATEG SPECIFIER HIDENTIFIER
		|	FPP_CATEG FPP_PROC_DECL_IN_SPEC
		;
FPP_CATEG       :       HNAME HLABELSEPARATOR
		|       HVALUE HLABELSEPARATOR
		|       HVAR HLABELSEPARATOR
		|       /*EMPT*/
		;
FPP_PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
			HIDENTIFIER
					{}
			FPP_HEADING {} { /* Yes, two "final" actions. */ }
		;
IDENTIFIER_LISTV:       HIDENTIFIER
		|	HDOTDOTDOT
		|       HIDENTIFIER     {}
			HPAREXPSEPARATOR IDENTIFIER_LISTV
		;
MBEE_MODE_PART  :       /*EMPT*/
		|       MODE_PART
		;
MODE_PART       :       NAME_PART
		|       VALUE_PART
		|       VAR_PART
		|       NAME_PART VALUE_PART
		|       VALUE_PART NAME_PART
		|       NAME_PART VAR_PART
		|       VAR_PART NAME_PART
		|       VALUE_PART VAR_PART
		|       VAR_PART VALUE_PART
		|       VAR_PART NAME_PART VALUE_PART
		|       NAME_PART VAR_PART VALUE_PART
		|       NAME_PART VALUE_PART VAR_PART
		|       VAR_PART VALUE_PART NAME_PART
		|       VALUE_PART VAR_PART NAME_PART
		|       VALUE_PART NAME_PART VAR_PART
		;
NAME_PART       :       HNAME           {}
			IDENTIFIER_LISTV
			HSTATEMENTSEPARATOR
		;
VAR_PART        :       HVAR            {}
			IDENTIFIER_LISTV
			HSTATEMENTSEPARATOR
		;
VALUE_PART      :       HVALUE          {}
			IDENTIFIER_LISTV HSTATEMENTSEPARATOR
		;
MBEE_SPEC_PART  :       /*EMPT*/
		|       SPEC_PART
		;
SPEC_PART       :       ONE_SPEC
		|       SPEC_PART ONE_SPEC
		;
ONE_SPEC	:	SPECIFIER IDENTIFIER_LIST HSTATEMENTSEPARATOR
		|	NO_TYPE HPROCEDURE HIDENTIFIER HOBJRELOPERATOR
			  {}
			PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
		|       FPP_PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
		|       MBEE_TYPE HPROCEDURE HIDENTIFIER HSTATEMENTSEPARATOR
		|       MBEE_TYPE HPROCEDURE HIDENTIFIER HPAREXPSEPARATOR
			IDENTIFIER_LIST HSTATEMENTSEPARATOR
		;
SPECIFIER       :       TYPE
		|       MBEE_TYPE
			HARRAY
		|       HLABEL
		|       HSWITCH
		;
PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
			HIDENTIFIER
					{}
			HEADING
					{}
			MBEE_BEGIN_END
		;
MBEE_BEGIN_END	:	/* EMPTY */
		|	HBEGIN HEND
		;
MBEE_PROT_PART  :       /*EMPT*/
		|       PROTECTION_PART
		;
PROTECTION_PART :       PROT_SPECIFIER IDENTIFIER_LIST
			HSTATEMENTSEPARATOR
		|       PROTECTION_PART  PROT_SPECIFIER
			IDENTIFIER_LIST HSTATEMENTSEPARATOR
		;
PROT_SPECIFIER  :       HHIDDEN
		|       HPROTECTED
		|       HHIDDEN
			HPROTECTED
		|       HPROTECTED
			HHIDDEN
		;
MBEE_VIRT_PART  :       /*EMPT*/
		|       VIRTUAL_PART
		;
VIRTUAL_PART    :       HVIRTUAL
			HLABELSEPARATOR
			MBEE_SPEC_PART
		;
IDENTIFIER_LIST :       HIDENTIFIER
		|       IDENTIFIER_LIST HPAREXPSEPARATOR
			HIDENTIFIER
		;
IDENTIFIER_LISTC:       HIDENTIFIER
			MBEE_CONSTANT
		|       IDENTIFIER_LISTC HPAREXPSEPARATOR
			HIDENTIFIER
			MBEE_CONSTANT
		;
MBEE_CONSTANT	:	/* EMPTY */
		|	HVALRELOPERATOR
				{}
			EXPRESSION
		;

/* GRAMATIKK FOR UTTRYKK */
EXPRESSION      :       EXPRESSION_SIMP
		|       HIF
			EXPRESSION
			HTHEN
			EXPRESSION
			HELSE
			EXPRESSION
		;
EXPRESSION_SIMP :	EXPRESSION_SIMP
			HASSIGN
			EXPRESSION
		|

			EXPRESSION_SIMP
			HCONC
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP HOR
			HELSE
			EXPRESSION_SIMP
			%prec HORELSE
		|       EXPRESSION_SIMP HAND
			HTHEN
			EXPRESSION_SIMP
			%prec HANDTHEN
		|       EXPRESSION_SIMP
			HEQV EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HIMP EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HOR EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HAND EXPRESSION_SIMP
		|       HNOT EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HVALRELOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HREFRELOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HOBJRELOPERATOR
			EXPRESSION_SIMP
		|       HTERMOPERATOR
			EXPRESSION_SIMP %prec UNEAR
		|       EXPRESSION_SIMP
			HTERMOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HFACTOROPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HPRIMARYOPERATOR
			EXPRESSION_SIMP
		|       HBEGPAR
			EXPRESSION HENDPAR
		|       HTEXTKONST
		|       HCHARACTERKONST
		|       HREALKONST
		|       HINTEGERKONST
		|       HBOOLEANKONST
		|       HNONE
		|       HIDENTIFIER
				{}
			MBEE_ARG_R_PT
		|       HTHIS HIDENTIFIER
		|       HNEW
			HIDENTIFIER
			ARG_R_PT
		|       EXPRESSION_SIMP
			HDOT
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HQUA HIDENTIFIER
		;
ARG_R_PT        :       /*EMPTY*/
		|       HBEGPAR
			ARGUMENT_LIST HENDPAR
		;
MBEE_ARG_R_PT   :       /*EMPTY*/
		|       HBEGPAR
			ARGUMENT_LIST HENDPAR
		;
ARGUMENT_LIST   :       EXPRESSION
		|       EXPRESSION
			HPAREXPSEPARATOR
			ARGUMENT_LIST
		;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:780: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:780"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:780: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:780: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:780"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:780: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:780"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:780: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 78 shift/reduce, 10 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780: sed -n 's/^state //p' input.output | tail -1"
at_fn_check_prepare_notrace 'a shell pipeline' "existing.at:780"
( $at_check_trace; sed -n 's/^state //p' input.output | tail -1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "442
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780: sed 's/^%define lr.type .*\$//' input.y > input-lalr.y"
at_fn_check_prepare_dynamic "sed 's/^%define lr.type .*$//' input.y > input-lalr.y" "existing.at:780"
( $at_check_trace; sed 's/^%define lr.type .*$//' input.y > input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:780: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input-lalr.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:780"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:780: bison --xml=xml-tests/test.xml --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:780: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:780"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:780: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:780"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:780: bison --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; bison --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/existing.at:780: diff -u input-lalr.output input.output \\
           | sed -n '/^@@/,\$p' | sed 's/^ \$//'"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:780"
( $at_check_trace; diff -u input-lalr.output input.output \
           | sed -n '/^@@/,$p' | sed 's/^ $//'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }
{ set +x
$as_echo "$at_srcdir/existing.at:780: grep '^State.*conflicts:' input.output"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; grep '^State.*conflicts:' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "State 64 conflicts: 14 shift/reduce
State 164 conflicts: 1 shift/reduce
State 201 conflicts: 33 shift/reduce, 4 reduce/reduce
State 206 conflicts: 1 shift/reduce
State 240 conflicts: 1 shift/reduce
State 335 conflicts: 9 shift/reduce, 2 reduce/reduce
State 356 conflicts: 1 shift/reduce
State 360 conflicts: 9 shift/reduce, 2 reduce/reduce
State 427 conflicts: 9 shift/reduce, 2 reduce/reduce
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "existing.at:780"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "existing.at:780"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_220
#AT_START_221
at_fn_group_banner 221 'existing.at:780' \
  "GNU Cim Grammar: IELR(1)" "                       " 16
at_xfail=no
(
  $as_echo "221. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type ielr
%union {}

%token
	HACTIVATE HAFTER /*HAND*/ HARRAY HAT
	HBEFORE HBEGIN HBOOLEAN
	HCHARACTER HCLASS /*HCOMMENT*/ HCONC
	HDELAY HDO
	HELSE HEND HEQ /*HEQV*/ HEXTERNAL
	HFOR
	HGE HGO HGOTO HGT
	HHIDDEN
	HIF /*HIMP*/ HIN HINNER HINSPECT HINTEGER HIS
	HLABEL HLE HLONG HLT
	HNAME HNE HNEW HNONE /*HNOT*/ HNOTEXT
	/*HOR*/ HOTHERWISE
	HPRIOR HPROCEDURE HPROTECTED
	HQUA
	HREACTIVATE HREAL HREF
	HSHORT HSTEP HSWITCH
	HTEXT HTHEN HTHIS HTO
	HUNTIL
	HVALUE HVAR HVIRTUAL
	HWHEN HWHILE

	HASSIGNVALUE HASSIGNREF
	/*HDOT*/ HPAREXPSEPARATOR HLABELSEPARATOR HSTATEMENTSEPARATOR
	HBEGPAR HENDPAR
	HEQR HNER
	HADD HSUB HMUL HDIV HINTDIV HEXP
	HDOTDOTDOT

%token HIDENTIFIER
%token HBOOLEANKONST HINTEGERKONST HCHARACTERKONST
%token HREALKONST
%token HTEXTKONST


%right HASSIGN
%left   HORELSE
%left   HANDTHEN
%left   HEQV
%left   HIMP
%left   HOR
%left   HAND

%left   HNOT

%left HVALRELOPERATOR HREFRELOPERATOR HOBJRELOPERATOR

%left	HCONC

%left HTERMOPERATOR
%left UNEAR
%left HFACTOROPERATOR
%left         HPRIMARYOPERATOR

%left   HQUA

%left   HDOT

%start  MAIN_MODULE


%%


/* GRAMATIKK FOR PROGRAM MODULES */
MAIN_MODULE     :       {}
			MODULS
		|	error HSTATEMENTSEPARATOR MBEE_DECLSTMS
		;
EXT_DECLARATION	:	HEXTERNAL
			MBEE_TYPE
			HPROCEDURE
				{}
			EXT_LIST
		|
			HEXTERNAL
			HIDENTIFIER
			HPROCEDURE
				{}
			HIDENTIFIER {}
			EXTERNAL_KIND_ITEM
		|	HEXTERNAL
			HCLASS
				{}
			EXT_LIST

		;
EXTERNAL_KIND_ITEM:	EXT_IDENT
			HOBJRELOPERATOR
				{}
			MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{}
			HEADING EMPTY_BLOCK
				{}
/*		|
			EXT_IDENT
				{}
			MBEE_REST_EXT_LIST
		;
MBEE_REST_EXT_LIST:	/* EMPTY
		|	HPAREXPSEPARATOR EXT_KIND_LIST
		;
EXT_KIND_LIST	:	EXT_KIND_ITEM
		|	EXT_KIND_LIST HPAREXPSEPARATOR EXT_KIND_ITEM
		;
EXT_KIND_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{}*/
		;
EMPTY_BLOCK	:	/*EMPT*/
		|	HBEGIN HEND
		;
EXT_LIST	:	EXT_ITEM
		|	EXT_LIST HPAREXPSEPARATOR EXT_ITEM
		;
EXT_ITEM	:	HIDENTIFIER
			EXT_IDENT
		;
EXT_IDENT	:	/* EMPTY */
		|	HVALRELOPERATOR {}
			HTEXTKONST
		;
/* GRAMATIKK FOR TYPER */
NO_TYPE         :       /*EMPT*/
		;
MBEE_TYPE       :       NO_TYPE
		|       TYPE
		;
TYPE            :       HREF HBEGPAR
			HIDENTIFIER
				{}
			HENDPAR
		|       HTEXT
		|       HBOOLEAN
		|       HCHARACTER
		|       HSHORT HINTEGER
		|       HINTEGER
		|       HREAL
		|       HLONG HREAL
		;

/* GRAMATIKK FOR DEL AV SETNINGER */
MBEE_ELSE_PART  :       /*EMPT*/
/*		|	HELSE
			HIF
			EXPRESSION
			HTHEN   {}
			BLOCK   {}
			MBEE_ELSE_PART          {}*/
		|       HELSE   {}
			BLOCK
		;
FOR_LIST        :       FOR_LIST_ELEMENT
		|       FOR_LIST_ELEMENT
			HPAREXPSEPARATOR
			FOR_LIST
		;
FOR_LIST_ELEMENT:       EXPRESSION
			MBEE_F_L_EL_R_PT
		;
MBEE_F_L_EL_R_PT:       /*EMPT*/
		|       HWHILE
			EXPRESSION
		|       HSTEP
			EXPRESSION
			HUNTIL
			EXPRESSION
		;
GOTO            :       HGO
			HTO
		|       HGOTO
		;
CONN_STATE_R_PT :       WHEN_CLAUSE_LIST
		|       HDO   {}
			BLOCK
		;
WHEN_CLAUSE_LIST:       HWHEN
			HIDENTIFIER
			HDO    {}
			BLOCK
		|       WHEN_CLAUSE_LIST
			HWHEN
			HIDENTIFIER
			HDO    {}
			BLOCK
		;
MBEE_OTWI_CLAUS :       /*EMPT*/
		|       HOTHERWISE {}

			BLOCK
		;
ACTIVATOR	:	HACTIVATE
		|	HREACTIVATE
		;
SCHEDULE	:	/*EMPT*/
		|	ATDELAY EXPRESSION	{}
			PRIOR
		|	BEFOREAFTER		{}
			EXPRESSION
		;
ATDELAY		:	HAT
		|	HDELAY
		;
BEFOREAFTER	:	HBEFORE
		|	HAFTER
		;
PRIOR		:	/*EMPT*/
		|	HPRIOR
		;
/* GRAMATIKK FOR SETNINGER OG DEKLARASJONER */
MODULSTATEMENT  :       HWHILE
			EXPRESSION
			HDO     {}
			BLOCK
		|       HIF
			EXPRESSION
			HTHEN   {}
			BLOCK   {}
			MBEE_ELSE_PART
		|       HFOR
			HIDENTIFIER
			HASSIGN {}
			FOR_LIST
			HDO     {}
			BLOCK
		|       GOTO
			EXPRESSION
		|       HINSPECT
			EXPRESSION              {}
			CONN_STATE_R_PT
				{}
			MBEE_OTWI_CLAUS
		|       HINNER
		|       HIDENTIFIER
			HLABELSEPARATOR
				{}
			DECLSTATEMENT
		|       EXPRESSION_SIMP
			HBEGIN
				{}
			IMPORT_SPEC_MODULE
				{}
			MBEE_DECLSTMS
			HEND
		|	EXPRESSION_SIMP HBEGIN error HSTATEMENTSEPARATOR
			MBEE_DECLSTMS HEND
		|	EXPRESSION_SIMP HBEGIN error HEND
		|       EXPRESSION_SIMP
		|	ACTIVATOR EXPRESSION SCHEDULE
		|       HBEGIN
				{}
			MBEE_DECLSTMS
			HEND
		|       MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{}
			HEADING BLOCK
		|       HIDENTIFIER
			HCLASS
			NO_TYPE
				{}
			IMPORT_SPEC_MODULE
			HIDENTIFIER
				{}
			HEADING
			BLOCK
		|       HCLASS
			NO_TYPE
			HIDENTIFIER
				{}
			HEADING
			BLOCK
		|       EXT_DECLARATION
		|       /*EMPT*/
		;
IMPORT_SPEC_MODULE:
		;
DECLSTATEMENT	:	MODULSTATEMENT
		|       TYPE
			HIDENTIFIER
			MBEE_CONSTANT
			HPAREXPSEPARATOR
				{}
			IDENTIFIER_LISTC
		|       TYPE
			HIDENTIFIER
			MBEE_CONSTANT
		|       MBEE_TYPE
			HARRAY  {}
			ARR_SEGMENT_LIST
		|       HSWITCH
			HIDENTIFIER
			HASSIGN {}
			SWITCH_LIST
		;
BLOCK           :       DECLSTATEMENT
		|       HBEGIN MBEE_DECLSTMS HEND
		|	HBEGIN error HSTATEMENTSEPARATOR MBEE_DECLSTMS HEND
		|	HBEGIN error HEND
		;
MBEE_DECLSTMS   :       MBEE_DECLSTMSU
		;
MBEE_DECLSTMSU  :       DECLSTATEMENT
		|       MBEE_DECLSTMSU
			HSTATEMENTSEPARATOR
			DECLSTATEMENT
		;
MODULS		:	MODULSTATEMENT
		|	MODULS HSTATEMENTSEPARATOR MODULSTATEMENT
		;
/* GRAMATIKK FOR DEL AV DEKLARASJONER */
ARR_SEGMENT_LIST:       ARR_SEGMENT
		|       ARR_SEGMENT_LIST
			HPAREXPSEPARATOR
			ARR_SEGMENT
		;
ARR_SEGMENT	:       ARRAY_SEGMENT
			HBEGPAR
			BAUND_PAIR_LIST HENDPAR
		;
ARRAY_SEGMENT   :       ARRAY_SEGMENT_EL        {}

		|       ARRAY_SEGMENT_EL
			HPAREXPSEPARATOR
			ARRAY_SEGMENT
		;
ARRAY_SEGMENT_EL:       HIDENTIFIER
		;
BAUND_PAIR_LIST :       BAUND_PAIR
		|       BAUND_PAIR
			HPAREXPSEPARATOR
			BAUND_PAIR_LIST
		;
BAUND_PAIR      :       EXPRESSION
			HLABELSEPARATOR
			EXPRESSION
		;
SWITCH_LIST     :       EXPRESSION
		|       EXPRESSION
			HPAREXPSEPARATOR
			SWITCH_LIST
		;
HEADING         :       MBEE_FMAL_PAR_P HSTATEMENTSEPARATOR {}
			MBEE_MODE_PART  {}
			MBEE_SPEC_PART  {}
			MBEE_PROT_PART  {}
			MBEE_VIRT_PART
		;
MBEE_FMAL_PAR_P :       /*EMPT*/
		|       FMAL_PAR_PART
		;
FMAL_PAR_PART   :       HBEGPAR NO_TYPE
			MBEE_LISTV HENDPAR
		;
MBEE_LISTV      :       /*EMPT*/
		|       LISTV
		;
LISTV           :       HIDENTIFIER
		|	FPP_CATEG HDOTDOTDOT
		|       HIDENTIFIER     {}
			HPAREXPSEPARATOR LISTV
		|       FPP_SPEC
		|       FPP_SPEC
			HPAREXPSEPARATOR LISTV
		;
FPP_HEADING     :       HBEGPAR NO_TYPE
			FPP_MBEE_LISTV HENDPAR
		;
FPP_MBEE_LISTV  :       /*EMPT*/
		|       FPP_LISTV
		;
FPP_LISTV       :	FPP_CATEG HDOTDOTDOT
		|       FPP_SPEC
		|       FPP_SPEC
			HPAREXPSEPARATOR LISTV
		;
FPP_SPEC        :       FPP_CATEG SPECIFIER HIDENTIFIER
		|	FPP_CATEG FPP_PROC_DECL_IN_SPEC
		;
FPP_CATEG       :       HNAME HLABELSEPARATOR
		|       HVALUE HLABELSEPARATOR
		|       HVAR HLABELSEPARATOR
		|       /*EMPT*/
		;
FPP_PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
			HIDENTIFIER
					{}
			FPP_HEADING {} { /* Yes, two "final" actions. */ }
		;
IDENTIFIER_LISTV:       HIDENTIFIER
		|	HDOTDOTDOT
		|       HIDENTIFIER     {}
			HPAREXPSEPARATOR IDENTIFIER_LISTV
		;
MBEE_MODE_PART  :       /*EMPT*/
		|       MODE_PART
		;
MODE_PART       :       NAME_PART
		|       VALUE_PART
		|       VAR_PART
		|       NAME_PART VALUE_PART
		|       VALUE_PART NAME_PART
		|       NAME_PART VAR_PART
		|       VAR_PART NAME_PART
		|       VALUE_PART VAR_PART
		|       VAR_PART VALUE_PART
		|       VAR_PART NAME_PART VALUE_PART
		|       NAME_PART VAR_PART VALUE_PART
		|       NAME_PART VALUE_PART VAR_PART
		|       VAR_PART VALUE_PART NAME_PART
		|       VALUE_PART VAR_PART NAME_PART
		|       VALUE_PART NAME_PART VAR_PART
		;
NAME_PART       :       HNAME           {}
			IDENTIFIER_LISTV
			HSTATEMENTSEPARATOR
		;
VAR_PART        :       HVAR            {}
			IDENTIFIER_LISTV
			HSTATEMENTSEPARATOR
		;
VALUE_PART      :       HVALUE          {}
			IDENTIFIER_LISTV HSTATEMENTSEPARATOR
		;
MBEE_SPEC_PART  :       /*EMPT*/
		|       SPEC_PART
		;
SPEC_PART       :       ONE_SPEC
		|       SPEC_PART ONE_SPEC
		;
ONE_SPEC	:	SPECIFIER IDENTIFIER_LIST HSTATEMENTSEPARATOR
		|	NO_TYPE HPROCEDURE HIDENTIFIER HOBJRELOPERATOR
			  {}
			PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
		|       FPP_PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
		|       MBEE_TYPE HPROCEDURE HIDENTIFIER HSTATEMENTSEPARATOR
		|       MBEE_TYPE HPROCEDURE HIDENTIFIER HPAREXPSEPARATOR
			IDENTIFIER_LIST HSTATEMENTSEPARATOR
		;
SPECIFIER       :       TYPE
		|       MBEE_TYPE
			HARRAY
		|       HLABEL
		|       HSWITCH
		;
PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
			HIDENTIFIER
					{}
			HEADING
					{}
			MBEE_BEGIN_END
		;
MBEE_BEGIN_END	:	/* EMPTY */
		|	HBEGIN HEND
		;
MBEE_PROT_PART  :       /*EMPT*/
		|       PROTECTION_PART
		;
PROTECTION_PART :       PROT_SPECIFIER IDENTIFIER_LIST
			HSTATEMENTSEPARATOR
		|       PROTECTION_PART  PROT_SPECIFIER
			IDENTIFIER_LIST HSTATEMENTSEPARATOR
		;
PROT_SPECIFIER  :       HHIDDEN
		|       HPROTECTED
		|       HHIDDEN
			HPROTECTED
		|       HPROTECTED
			HHIDDEN
		;
MBEE_VIRT_PART  :       /*EMPT*/
		|       VIRTUAL_PART
		;
VIRTUAL_PART    :       HVIRTUAL
			HLABELSEPARATOR
			MBEE_SPEC_PART
		;
IDENTIFIER_LIST :       HIDENTIFIER
		|       IDENTIFIER_LIST HPAREXPSEPARATOR
			HIDENTIFIER
		;
IDENTIFIER_LISTC:       HIDENTIFIER
			MBEE_CONSTANT
		|       IDENTIFIER_LISTC HPAREXPSEPARATOR
			HIDENTIFIER
			MBEE_CONSTANT
		;
MBEE_CONSTANT	:	/* EMPTY */
		|	HVALRELOPERATOR
				{}
			EXPRESSION
		;

/* GRAMATIKK FOR UTTRYKK */
EXPRESSION      :       EXPRESSION_SIMP
		|       HIF
			EXPRESSION
			HTHEN
			EXPRESSION
			HELSE
			EXPRESSION
		;
EXPRESSION_SIMP :	EXPRESSION_SIMP
			HASSIGN
			EXPRESSION
		|

			EXPRESSION_SIMP
			HCONC
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP HOR
			HELSE
			EXPRESSION_SIMP
			%prec HORELSE
		|       EXPRESSION_SIMP HAND
			HTHEN
			EXPRESSION_SIMP
			%prec HANDTHEN
		|       EXPRESSION_SIMP
			HEQV EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HIMP EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HOR EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HAND EXPRESSION_SIMP
		|       HNOT EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HVALRELOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HREFRELOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HOBJRELOPERATOR
			EXPRESSION_SIMP
		|       HTERMOPERATOR
			EXPRESSION_SIMP %prec UNEAR
		|       EXPRESSION_SIMP
			HTERMOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HFACTOROPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HPRIMARYOPERATOR
			EXPRESSION_SIMP
		|       HBEGPAR
			EXPRESSION HENDPAR
		|       HTEXTKONST
		|       HCHARACTERKONST
		|       HREALKONST
		|       HINTEGERKONST
		|       HBOOLEANKONST
		|       HNONE
		|       HIDENTIFIER
				{}
			MBEE_ARG_R_PT
		|       HTHIS HIDENTIFIER
		|       HNEW
			HIDENTIFIER
			ARG_R_PT
		|       EXPRESSION_SIMP
			HDOT
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HQUA HIDENTIFIER
		;
ARG_R_PT        :       /*EMPTY*/
		|       HBEGPAR
			ARGUMENT_LIST HENDPAR
		;
MBEE_ARG_R_PT   :       /*EMPTY*/
		|       HBEGPAR
			ARGUMENT_LIST HENDPAR
		;
ARGUMENT_LIST   :       EXPRESSION
		|       EXPRESSION
			HPAREXPSEPARATOR
			ARGUMENT_LIST
		;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:780: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:780"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:780: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:780: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:780"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:780: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:780"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:780: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 78 shift/reduce, 10 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780: sed -n 's/^state //p' input.output | tail -1"
at_fn_check_prepare_notrace 'a shell pipeline' "existing.at:780"
( $at_check_trace; sed -n 's/^state //p' input.output | tail -1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "442
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780: sed 's/^%define lr.type .*\$//' input.y > input-lalr.y"
at_fn_check_prepare_dynamic "sed 's/^%define lr.type .*$//' input.y > input-lalr.y" "existing.at:780"
( $at_check_trace; sed 's/^%define lr.type .*$//' input.y > input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:780: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input-lalr.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:780"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:780: bison --xml=xml-tests/test.xml --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:780: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:780"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:780: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:780"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:780: bison --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; bison --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/existing.at:780: diff -u input-lalr.output input.output \\
           | sed -n '/^@@/,\$p' | sed 's/^ \$//'"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:780"
( $at_check_trace; diff -u input-lalr.output input.output \
           | sed -n '/^@@/,$p' | sed 's/^ $//'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }
{ set +x
$as_echo "$at_srcdir/existing.at:780: grep '^State.*conflicts:' input.output"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; grep '^State.*conflicts:' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "State 64 conflicts: 14 shift/reduce
State 164 conflicts: 1 shift/reduce
State 201 conflicts: 33 shift/reduce, 4 reduce/reduce
State 206 conflicts: 1 shift/reduce
State 240 conflicts: 1 shift/reduce
State 335 conflicts: 9 shift/reduce, 2 reduce/reduce
State 356 conflicts: 1 shift/reduce
State 360 conflicts: 9 shift/reduce, 2 reduce/reduce
State 427 conflicts: 9 shift/reduce, 2 reduce/reduce
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "existing.at:780"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "existing.at:780"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_221
#AT_START_222
at_fn_group_banner 222 'existing.at:780' \
  "GNU Cim Grammar: Canonical LR(1)" "               " 16
at_xfail=no
(
  $as_echo "222. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type canonical-lr
%union {}

%token
	HACTIVATE HAFTER /*HAND*/ HARRAY HAT
	HBEFORE HBEGIN HBOOLEAN
	HCHARACTER HCLASS /*HCOMMENT*/ HCONC
	HDELAY HDO
	HELSE HEND HEQ /*HEQV*/ HEXTERNAL
	HFOR
	HGE HGO HGOTO HGT
	HHIDDEN
	HIF /*HIMP*/ HIN HINNER HINSPECT HINTEGER HIS
	HLABEL HLE HLONG HLT
	HNAME HNE HNEW HNONE /*HNOT*/ HNOTEXT
	/*HOR*/ HOTHERWISE
	HPRIOR HPROCEDURE HPROTECTED
	HQUA
	HREACTIVATE HREAL HREF
	HSHORT HSTEP HSWITCH
	HTEXT HTHEN HTHIS HTO
	HUNTIL
	HVALUE HVAR HVIRTUAL
	HWHEN HWHILE

	HASSIGNVALUE HASSIGNREF
	/*HDOT*/ HPAREXPSEPARATOR HLABELSEPARATOR HSTATEMENTSEPARATOR
	HBEGPAR HENDPAR
	HEQR HNER
	HADD HSUB HMUL HDIV HINTDIV HEXP
	HDOTDOTDOT

%token HIDENTIFIER
%token HBOOLEANKONST HINTEGERKONST HCHARACTERKONST
%token HREALKONST
%token HTEXTKONST


%right HASSIGN
%left   HORELSE
%left   HANDTHEN
%left   HEQV
%left   HIMP
%left   HOR
%left   HAND

%left   HNOT

%left HVALRELOPERATOR HREFRELOPERATOR HOBJRELOPERATOR

%left	HCONC

%left HTERMOPERATOR
%left UNEAR
%left HFACTOROPERATOR
%left         HPRIMARYOPERATOR

%left   HQUA

%left   HDOT

%start  MAIN_MODULE


%%


/* GRAMATIKK FOR PROGRAM MODULES */
MAIN_MODULE     :       {}
			MODULS
		|	error HSTATEMENTSEPARATOR MBEE_DECLSTMS
		;
EXT_DECLARATION	:	HEXTERNAL
			MBEE_TYPE
			HPROCEDURE
				{}
			EXT_LIST
		|
			HEXTERNAL
			HIDENTIFIER
			HPROCEDURE
				{}
			HIDENTIFIER {}
			EXTERNAL_KIND_ITEM
		|	HEXTERNAL
			HCLASS
				{}
			EXT_LIST

		;
EXTERNAL_KIND_ITEM:	EXT_IDENT
			HOBJRELOPERATOR
				{}
			MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{}
			HEADING EMPTY_BLOCK
				{}
/*		|
			EXT_IDENT
				{}
			MBEE_REST_EXT_LIST
		;
MBEE_REST_EXT_LIST:	/* EMPTY
		|	HPAREXPSEPARATOR EXT_KIND_LIST
		;
EXT_KIND_LIST	:	EXT_KIND_ITEM
		|	EXT_KIND_LIST HPAREXPSEPARATOR EXT_KIND_ITEM
		;
EXT_KIND_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{}*/
		;
EMPTY_BLOCK	:	/*EMPT*/
		|	HBEGIN HEND
		;
EXT_LIST	:	EXT_ITEM
		|	EXT_LIST HPAREXPSEPARATOR EXT_ITEM
		;
EXT_ITEM	:	HIDENTIFIER
			EXT_IDENT
		;
EXT_IDENT	:	/* EMPTY */
		|	HVALRELOPERATOR {}
			HTEXTKONST
		;
/* GRAMATIKK FOR TYPER */
NO_TYPE         :       /*EMPT*/
		;
MBEE_TYPE       :       NO_TYPE
		|       TYPE
		;
TYPE            :       HREF HBEGPAR
			HIDENTIFIER
				{}
			HENDPAR
		|       HTEXT
		|       HBOOLEAN
		|       HCHARACTER
		|       HSHORT HINTEGER
		|       HINTEGER
		|       HREAL
		|       HLONG HREAL
		;

/* GRAMATIKK FOR DEL AV SETNINGER */
MBEE_ELSE_PART  :       /*EMPT*/
/*		|	HELSE
			HIF
			EXPRESSION
			HTHEN   {}
			BLOCK   {}
			MBEE_ELSE_PART          {}*/
		|       HELSE   {}
			BLOCK
		;
FOR_LIST        :       FOR_LIST_ELEMENT
		|       FOR_LIST_ELEMENT
			HPAREXPSEPARATOR
			FOR_LIST
		;
FOR_LIST_ELEMENT:       EXPRESSION
			MBEE_F_L_EL_R_PT
		;
MBEE_F_L_EL_R_PT:       /*EMPT*/
		|       HWHILE
			EXPRESSION
		|       HSTEP
			EXPRESSION
			HUNTIL
			EXPRESSION
		;
GOTO            :       HGO
			HTO
		|       HGOTO
		;
CONN_STATE_R_PT :       WHEN_CLAUSE_LIST
		|       HDO   {}
			BLOCK
		;
WHEN_CLAUSE_LIST:       HWHEN
			HIDENTIFIER
			HDO    {}
			BLOCK
		|       WHEN_CLAUSE_LIST
			HWHEN
			HIDENTIFIER
			HDO    {}
			BLOCK
		;
MBEE_OTWI_CLAUS :       /*EMPT*/
		|       HOTHERWISE {}

			BLOCK
		;
ACTIVATOR	:	HACTIVATE
		|	HREACTIVATE
		;
SCHEDULE	:	/*EMPT*/
		|	ATDELAY EXPRESSION	{}
			PRIOR
		|	BEFOREAFTER		{}
			EXPRESSION
		;
ATDELAY		:	HAT
		|	HDELAY
		;
BEFOREAFTER	:	HBEFORE
		|	HAFTER
		;
PRIOR		:	/*EMPT*/
		|	HPRIOR
		;
/* GRAMATIKK FOR SETNINGER OG DEKLARASJONER */
MODULSTATEMENT  :       HWHILE
			EXPRESSION
			HDO     {}
			BLOCK
		|       HIF
			EXPRESSION
			HTHEN   {}
			BLOCK   {}
			MBEE_ELSE_PART
		|       HFOR
			HIDENTIFIER
			HASSIGN {}
			FOR_LIST
			HDO     {}
			BLOCK
		|       GOTO
			EXPRESSION
		|       HINSPECT
			EXPRESSION              {}
			CONN_STATE_R_PT
				{}
			MBEE_OTWI_CLAUS
		|       HINNER
		|       HIDENTIFIER
			HLABELSEPARATOR
				{}
			DECLSTATEMENT
		|       EXPRESSION_SIMP
			HBEGIN
				{}
			IMPORT_SPEC_MODULE
				{}
			MBEE_DECLSTMS
			HEND
		|	EXPRESSION_SIMP HBEGIN error HSTATEMENTSEPARATOR
			MBEE_DECLSTMS HEND
		|	EXPRESSION_SIMP HBEGIN error HEND
		|       EXPRESSION_SIMP
		|	ACTIVATOR EXPRESSION SCHEDULE
		|       HBEGIN
				{}
			MBEE_DECLSTMS
			HEND
		|       MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{}
			HEADING BLOCK
		|       HIDENTIFIER
			HCLASS
			NO_TYPE
				{}
			IMPORT_SPEC_MODULE
			HIDENTIFIER
				{}
			HEADING
			BLOCK
		|       HCLASS
			NO_TYPE
			HIDENTIFIER
				{}
			HEADING
			BLOCK
		|       EXT_DECLARATION
		|       /*EMPT*/
		;
IMPORT_SPEC_MODULE:
		;
DECLSTATEMENT	:	MODULSTATEMENT
		|       TYPE
			HIDENTIFIER
			MBEE_CONSTANT
			HPAREXPSEPARATOR
				{}
			IDENTIFIER_LISTC
		|       TYPE
			HIDENTIFIER
			MBEE_CONSTANT
		|       MBEE_TYPE
			HARRAY  {}
			ARR_SEGMENT_LIST
		|       HSWITCH
			HIDENTIFIER
			HASSIGN {}
			SWITCH_LIST
		;
BLOCK           :       DECLSTATEMENT
		|       HBEGIN MBEE_DECLSTMS HEND
		|	HBEGIN error HSTATEMENTSEPARATOR MBEE_DECLSTMS HEND
		|	HBEGIN error HEND
		;
MBEE_DECLSTMS   :       MBEE_DECLSTMSU
		;
MBEE_DECLSTMSU  :       DECLSTATEMENT
		|       MBEE_DECLSTMSU
			HSTATEMENTSEPARATOR
			DECLSTATEMENT
		;
MODULS		:	MODULSTATEMENT
		|	MODULS HSTATEMENTSEPARATOR MODULSTATEMENT
		;
/* GRAMATIKK FOR DEL AV DEKLARASJONER */
ARR_SEGMENT_LIST:       ARR_SEGMENT
		|       ARR_SEGMENT_LIST
			HPAREXPSEPARATOR
			ARR_SEGMENT
		;
ARR_SEGMENT	:       ARRAY_SEGMENT
			HBEGPAR
			BAUND_PAIR_LIST HENDPAR
		;
ARRAY_SEGMENT   :       ARRAY_SEGMENT_EL        {}

		|       ARRAY_SEGMENT_EL
			HPAREXPSEPARATOR
			ARRAY_SEGMENT
		;
ARRAY_SEGMENT_EL:       HIDENTIFIER
		;
BAUND_PAIR_LIST :       BAUND_PAIR
		|       BAUND_PAIR
			HPAREXPSEPARATOR
			BAUND_PAIR_LIST
		;
BAUND_PAIR      :       EXPRESSION
			HLABELSEPARATOR
			EXPRESSION
		;
SWITCH_LIST     :       EXPRESSION
		|       EXPRESSION
			HPAREXPSEPARATOR
			SWITCH_LIST
		;
HEADING         :       MBEE_FMAL_PAR_P HSTATEMENTSEPARATOR {}
			MBEE_MODE_PART  {}
			MBEE_SPEC_PART  {}
			MBEE_PROT_PART  {}
			MBEE_VIRT_PART
		;
MBEE_FMAL_PAR_P :       /*EMPT*/
		|       FMAL_PAR_PART
		;
FMAL_PAR_PART   :       HBEGPAR NO_TYPE
			MBEE_LISTV HENDPAR
		;
MBEE_LISTV      :       /*EMPT*/
		|       LISTV
		;
LISTV           :       HIDENTIFIER
		|	FPP_CATEG HDOTDOTDOT
		|       HIDENTIFIER     {}
			HPAREXPSEPARATOR LISTV
		|       FPP_SPEC
		|       FPP_SPEC
			HPAREXPSEPARATOR LISTV
		;
FPP_HEADING     :       HBEGPAR NO_TYPE
			FPP_MBEE_LISTV HENDPAR
		;
FPP_MBEE_LISTV  :       /*EMPT*/
		|       FPP_LISTV
		;
FPP_LISTV       :	FPP_CATEG HDOTDOTDOT
		|       FPP_SPEC
		|       FPP_SPEC
			HPAREXPSEPARATOR LISTV
		;
FPP_SPEC        :       FPP_CATEG SPECIFIER HIDENTIFIER
		|	FPP_CATEG FPP_PROC_DECL_IN_SPEC
		;
FPP_CATEG       :       HNAME HLABELSEPARATOR
		|       HVALUE HLABELSEPARATOR
		|       HVAR HLABELSEPARATOR
		|       /*EMPT*/
		;
FPP_PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
			HIDENTIFIER
					{}
			FPP_HEADING {} { /* Yes, two "final" actions. */ }
		;
IDENTIFIER_LISTV:       HIDENTIFIER
		|	HDOTDOTDOT
		|       HIDENTIFIER     {}
			HPAREXPSEPARATOR IDENTIFIER_LISTV
		;
MBEE_MODE_PART  :       /*EMPT*/
		|       MODE_PART
		;
MODE_PART       :       NAME_PART
		|       VALUE_PART
		|       VAR_PART
		|       NAME_PART VALUE_PART
		|       VALUE_PART NAME_PART
		|       NAME_PART VAR_PART
		|       VAR_PART NAME_PART
		|       VALUE_PART VAR_PART
		|       VAR_PART VALUE_PART
		|       VAR_PART NAME_PART VALUE_PART
		|       NAME_PART VAR_PART VALUE_PART
		|       NAME_PART VALUE_PART VAR_PART
		|       VAR_PART VALUE_PART NAME_PART
		|       VALUE_PART VAR_PART NAME_PART
		|       VALUE_PART NAME_PART VAR_PART
		;
NAME_PART       :       HNAME           {}
			IDENTIFIER_LISTV
			HSTATEMENTSEPARATOR
		;
VAR_PART        :       HVAR            {}
			IDENTIFIER_LISTV
			HSTATEMENTSEPARATOR
		;
VALUE_PART      :       HVALUE          {}
			IDENTIFIER_LISTV HSTATEMENTSEPARATOR
		;
MBEE_SPEC_PART  :       /*EMPT*/
		|       SPEC_PART
		;
SPEC_PART       :       ONE_SPEC
		|       SPEC_PART ONE_SPEC
		;
ONE_SPEC	:	SPECIFIER IDENTIFIER_LIST HSTATEMENTSEPARATOR
		|	NO_TYPE HPROCEDURE HIDENTIFIER HOBJRELOPERATOR
			  {}
			PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
		|       FPP_PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
		|       MBEE_TYPE HPROCEDURE HIDENTIFIER HSTATEMENTSEPARATOR
		|       MBEE_TYPE HPROCEDURE HIDENTIFIER HPAREXPSEPARATOR
			IDENTIFIER_LIST HSTATEMENTSEPARATOR
		;
SPECIFIER       :       TYPE
		|       MBEE_TYPE
			HARRAY
		|       HLABEL
		|       HSWITCH
		;
PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
			HIDENTIFIER
					{}
			HEADING
					{}
			MBEE_BEGIN_END
		;
MBEE_BEGIN_END	:	/* EMPTY */
		|	HBEGIN HEND
		;
MBEE_PROT_PART  :       /*EMPT*/
		|       PROTECTION_PART
		;
PROTECTION_PART :       PROT_SPECIFIER IDENTIFIER_LIST
			HSTATEMENTSEPARATOR
		|       PROTECTION_PART  PROT_SPECIFIER
			IDENTIFIER_LIST HSTATEMENTSEPARATOR
		;
PROT_SPECIFIER  :       HHIDDEN
		|       HPROTECTED
		|       HHIDDEN
			HPROTECTED
		|       HPROTECTED
			HHIDDEN
		;
MBEE_VIRT_PART  :       /*EMPT*/
		|       VIRTUAL_PART
		;
VIRTUAL_PART    :       HVIRTUAL
			HLABELSEPARATOR
			MBEE_SPEC_PART
		;
IDENTIFIER_LIST :       HIDENTIFIER
		|       IDENTIFIER_LIST HPAREXPSEPARATOR
			HIDENTIFIER
		;
IDENTIFIER_LISTC:       HIDENTIFIER
			MBEE_CONSTANT
		|       IDENTIFIER_LISTC HPAREXPSEPARATOR
			HIDENTIFIER
			MBEE_CONSTANT
		;
MBEE_CONSTANT	:	/* EMPTY */
		|	HVALRELOPERATOR
				{}
			EXPRESSION
		;

/* GRAMATIKK FOR UTTRYKK */
EXPRESSION      :       EXPRESSION_SIMP
		|       HIF
			EXPRESSION
			HTHEN
			EXPRESSION
			HELSE
			EXPRESSION
		;
EXPRESSION_SIMP :	EXPRESSION_SIMP
			HASSIGN
			EXPRESSION
		|

			EXPRESSION_SIMP
			HCONC
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP HOR
			HELSE
			EXPRESSION_SIMP
			%prec HORELSE
		|       EXPRESSION_SIMP HAND
			HTHEN
			EXPRESSION_SIMP
			%prec HANDTHEN
		|       EXPRESSION_SIMP
			HEQV EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HIMP EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HOR EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HAND EXPRESSION_SIMP
		|       HNOT EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HVALRELOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HREFRELOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HOBJRELOPERATOR
			EXPRESSION_SIMP
		|       HTERMOPERATOR
			EXPRESSION_SIMP %prec UNEAR
		|       EXPRESSION_SIMP
			HTERMOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HFACTOROPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HPRIMARYOPERATOR
			EXPRESSION_SIMP
		|       HBEGPAR
			EXPRESSION HENDPAR
		|       HTEXTKONST
		|       HCHARACTERKONST
		|       HREALKONST
		|       HINTEGERKONST
		|       HBOOLEANKONST
		|       HNONE
		|       HIDENTIFIER
				{}
			MBEE_ARG_R_PT
		|       HTHIS HIDENTIFIER
		|       HNEW
			HIDENTIFIER
			ARG_R_PT
		|       EXPRESSION_SIMP
			HDOT
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HQUA HIDENTIFIER
		;
ARG_R_PT        :       /*EMPTY*/
		|       HBEGPAR
			ARGUMENT_LIST HENDPAR
		;
MBEE_ARG_R_PT   :       /*EMPTY*/
		|       HBEGPAR
			ARGUMENT_LIST HENDPAR
		;
ARGUMENT_LIST   :       EXPRESSION
		|       EXPRESSION
			HPAREXPSEPARATOR
			ARGUMENT_LIST
		;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

{ set +x
$as_echo "$at_srcdir/existing.at:780: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:780"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1876 shift/reduce, 144 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780: sed -n 's/^state //p' input.output | tail -1"
at_fn_check_prepare_notrace 'a shell pipeline' "existing.at:780"
( $at_check_trace; sed -n 's/^state //p' input.output | tail -1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "10425
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/existing.at:780: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "existing.at:780"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:780:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "existing.at:780"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:780"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_222
#AT_START_223
at_fn_group_banner 223 'existing.at:1401' \
  "GNU pic (Groff 1.18.1) Grammar: LALR(1)" "        " 16
at_xfail=no
(
  $as_echo "223. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type lalr
%error-verbose
%union {}

%token LABEL
%token VARIABLE
%token NUMBER
%token TEXT
%token COMMAND_LINE
%token DELIMITED
%token ORDINAL
%token TH
%token LEFT_ARROW_HEAD
%token RIGHT_ARROW_HEAD
%token DOUBLE_ARROW_HEAD
%token LAST
%token UP
%token DOWN
%token LEFT
%token RIGHT
%token BOX
%token CIRCLE
%token ELLIPSE
%token ARC
%token LINE
%token ARROW
%token MOVE
%token SPLINE
%token HEIGHT
%token RADIUS
%token WIDTH
%token DIAMETER
%token FROM
%token TO
%token AT
%token WITH
%token BY
%token THEN
%token SOLID
%token DOTTED
%token DASHED
%token CHOP
%token SAME
%token INVISIBLE
%token LJUST
%token RJUST
%token ABOVE
%token BELOW
%token OF
%token THE
%token WAY
%token BETWEEN
%token AND
%token HERE
%token DOT_N
%token DOT_E
%token DOT_W
%token DOT_S
%token DOT_NE
%token DOT_SE
%token DOT_NW
%token DOT_SW
%token DOT_C
%token DOT_START
%token DOT_END
%token DOT_X
%token DOT_Y
%token DOT_HT
%token DOT_WID
%token DOT_RAD
%token SIN
%token COS
%token ATAN2
%token LOG
%token EXP
%token SQRT
%token K_MAX
%token K_MIN
%token INT
%token RAND
%token SRAND
%token COPY
%token THRU
%token TOP
%token BOTTOM
%token UPPER
%token LOWER
%token SH
%token PRINT
%token CW
%token CCW
%token FOR
%token DO
%token IF
%token ELSE
%token ANDAND
%token OROR
%token NOTEQUAL
%token EQUALEQUAL
%token LESSEQUAL
%token GREATEREQUAL
%token LEFT_CORNER
%token RIGHT_CORNER
%token NORTH
%token SOUTH
%token EAST
%token WEST
%token CENTER
%token END
%token START
%token RESET
%token UNTIL
%token PLOT
%token THICKNESS
%token FILL
%token COLORED
%token OUTLINED
%token SHADED
%token ALIGNED
%token SPRINTF
%token COMMAND

%left '.'

/* this ensures that plot 17 "%g" parses as (plot 17 "%g") */
%left PLOT
%left TEXT SPRINTF

/* give text adjustments higher precedence than TEXT, so that
box "foo" above ljust == box ("foo" above ljust)
*/

%left LJUST RJUST ABOVE BELOW

%left LEFT RIGHT
/* Give attributes that take an optional expression a higher
precedence than left and right, so that eg `line chop left'
parses properly. */
%left CHOP SOLID DASHED DOTTED UP DOWN FILL COLORED OUTLINED
%left LABEL

%left VARIABLE NUMBER '(' SIN COS ATAN2 LOG EXP SQRT K_MAX K_MIN INT RAND SRAND LAST
%left ORDINAL HERE '`'

%left BOX CIRCLE ELLIPSE ARC LINE ARROW SPLINE '[' /* ] */

/* these need to be lower than '-' */
%left HEIGHT RADIUS WIDTH DIAMETER FROM TO AT THICKNESS

/* these must have higher precedence than CHOP so that `label %prec CHOP'
works */
%left DOT_N DOT_E DOT_W DOT_S DOT_NE DOT_SE DOT_NW DOT_SW DOT_C
%left DOT_START DOT_END TOP BOTTOM LEFT_CORNER RIGHT_CORNER
%left UPPER LOWER NORTH SOUTH EAST WEST CENTER START END

%left ','
%left OROR
%left ANDAND
%left EQUALEQUAL NOTEQUAL
%left '<' '>' LESSEQUAL GREATEREQUAL

%left BETWEEN OF
%left AND

%left '+' '-'
%left '*' '/' '%'
%right '!'
%right '^'


%%


top:
	optional_separator
	| element_list
	;

element_list:
	optional_separator middle_element_list optional_separator
	;

middle_element_list:
	element
	| middle_element_list separator element
	;

optional_separator:
	/* empty */
	| separator
	;

separator:
	';'
	| separator ';'
	;

placeless_element:
	VARIABLE '=' any_expr
	| VARIABLE ':' '=' any_expr
	| UP
	| DOWN
	| LEFT
	| RIGHT
	| COMMAND_LINE
	| COMMAND print_args
	| PRINT print_args
	| SH
		{}
	  DELIMITED
	| COPY TEXT
	| COPY TEXT THRU
		{}
	  DELIMITED
		{}
	  until
	| COPY THRU
		{}
	  DELIMITED
		{}
	  until
	| FOR VARIABLE '=' expr TO expr optional_by DO
		{}
	  DELIMITED
	| simple_if
	| simple_if ELSE
		{}
	  DELIMITED
	| reset_variables
	| RESET
	;

reset_variables:
	RESET VARIABLE
	| reset_variables VARIABLE
	| reset_variables ',' VARIABLE
	;

print_args:
	print_arg
	| print_args print_arg
	;

print_arg:
	expr							%prec ','
	| text
	| position						%prec ','
	;

simple_if:
	IF any_expr THEN
		{}
	DELIMITED
	;

until:
	/* empty */
	| UNTIL TEXT
	;

any_expr:
	expr
	| text_expr
	;

text_expr:
	text EQUALEQUAL text
	| text NOTEQUAL text
	| text_expr ANDAND text_expr
	| text_expr ANDAND expr
	| expr ANDAND text_expr
	| text_expr OROR text_expr
	| text_expr OROR expr
	| expr OROR text_expr
	| '!' text_expr
	;

optional_by:
	/* empty */
	| BY expr
	| BY '*' expr
	;

element:
	object_spec
	| LABEL ':' optional_separator element
	| LABEL ':' optional_separator position_not_place
	| LABEL ':' optional_separator place
	| '{' {} element_list '}'
		{}
	  optional_element
	| placeless_element
	;

optional_element:
	/* empty */
	| element
	;

object_spec:
	BOX
	| CIRCLE
	| ELLIPSE
	| ARC
	| LINE
	| ARROW
	| MOVE
	| SPLINE
	| text							%prec TEXT
	| PLOT expr
	| PLOT expr text
	| '['
		{}
	  element_list ']'
	| object_spec HEIGHT expr
	| object_spec RADIUS expr
	| object_spec WIDTH expr
	| object_spec DIAMETER expr
	| object_spec expr					%prec HEIGHT
	| object_spec UP
	| object_spec UP expr
	| object_spec DOWN
	| object_spec DOWN expr
	| object_spec RIGHT
	| object_spec RIGHT expr
	| object_spec LEFT
	| object_spec LEFT expr
	| object_spec FROM position
	| object_spec TO position
	| object_spec AT position
	| object_spec WITH path
	| object_spec WITH position				%prec ','
	| object_spec BY expr_pair
	| object_spec THEN
	| object_spec SOLID
	| object_spec DOTTED
	| object_spec DOTTED expr
	| object_spec DASHED
	| object_spec DASHED expr
	| object_spec FILL
	| object_spec FILL expr
	| object_spec SHADED text
	| object_spec COLORED text
	| object_spec OUTLINED text
	| object_spec CHOP
	| object_spec CHOP expr
	| object_spec SAME
	| object_spec INVISIBLE
	| object_spec LEFT_ARROW_HEAD
	| object_spec RIGHT_ARROW_HEAD
	| object_spec DOUBLE_ARROW_HEAD
	| object_spec CW
	| object_spec CCW
	| object_spec text					%prec TEXT
	| object_spec LJUST
	| object_spec RJUST
	| object_spec ABOVE
	| object_spec BELOW
	| object_spec THICKNESS expr
	| object_spec ALIGNED
	;

text:
	TEXT
	| SPRINTF '(' TEXT sprintf_args ')'
	;

sprintf_args:
	/* empty */
	| sprintf_args ',' expr
	;

position:
	position_not_place
	| place
	;

position_not_place:
	expr_pair
	| position '+' expr_pair
	| position '-' expr_pair
	| '(' position ',' position ')'
	| expr between position AND position
	| expr '<' position ',' position '>'
	;

between:
	BETWEEN
	| OF THE WAY BETWEEN
	;

expr_pair:
	expr ',' expr
	| '(' expr_pair ')'
	;

place:
	/* line at A left == line (at A) left */
	label							%prec CHOP
	| label corner
	| corner label
	| corner OF label
	| HERE
	;

label:
	LABEL
	| nth_primitive
	| label '.' LABEL
	;

ordinal:
	ORDINAL
	| '`' any_expr TH
	;

optional_ordinal_last:
	LAST
	| ordinal LAST
	;

nth_primitive:
	ordinal object_type
	| optional_ordinal_last object_type
	;

object_type:
	BOX
	| CIRCLE
	| ELLIPSE
	| ARC
	| LINE
	| ARROW
	| SPLINE
	| '[' ']'
	| TEXT
	;

label_path:
	'.' LABEL
	| label_path '.' LABEL
	;

relative_path:
	corner							%prec CHOP
	/* give this a lower precedence than LEFT and RIGHT so that
	   [A: box] with .A left == [A: box] with (.A left) */
	| label_path						%prec TEXT
	| label_path corner
	;

path:
	relative_path
	| '(' relative_path ',' relative_path ')'
		{}
	/* The rest of these rules are a compatibility sop. */
	| ORDINAL LAST object_type relative_path
	| LAST object_type relative_path
	| ORDINAL object_type relative_path
	| LABEL relative_path
	;

corner:
	DOT_N
	| DOT_E
	| DOT_W
	| DOT_S
	| DOT_NE
	| DOT_SE
	| DOT_NW
	| DOT_SW
	| DOT_C
	| DOT_START
	| DOT_END
	| TOP
	| BOTTOM
	| LEFT
	| RIGHT
	| UPPER LEFT
	| LOWER LEFT
	| UPPER RIGHT
	| LOWER RIGHT
	| LEFT_CORNER
	| RIGHT_CORNER
	| UPPER LEFT_CORNER
	| LOWER LEFT_CORNER
	| UPPER RIGHT_CORNER
	| LOWER RIGHT_CORNER
	| NORTH
	| SOUTH
	| EAST
	| WEST
	| CENTER
	| START
	| END
	;

expr:
	VARIABLE
	| NUMBER
	| place DOT_X
	| place DOT_Y
	| place DOT_HT
	| place DOT_WID
	| place DOT_RAD
	| expr '+' expr
	| expr '-' expr
	| expr '*' expr
	| expr '/' expr
	| expr '%' expr
	| expr '^' expr
	| '-' expr						%prec '!'
	| '(' any_expr ')'
	| SIN '(' any_expr ')'
	| COS '(' any_expr ')'
	| ATAN2 '(' any_expr ',' any_expr ')'
	| LOG '(' any_expr ')'
	| EXP '(' any_expr ')'
	| SQRT '(' any_expr ')'
	| K_MAX '(' any_expr ',' any_expr ')'
	| K_MIN '(' any_expr ',' any_expr ')'
	| INT '(' any_expr ')'
	| RAND '(' any_expr ')'
	| RAND '(' ')'
	| SRAND '(' any_expr ')'
	| expr '<' expr
	| expr LESSEQUAL expr
	| expr '>' expr
	| expr GREATEREQUAL expr
	| expr EQUALEQUAL expr
	| expr NOTEQUAL expr
	| expr ANDAND expr
	| expr OROR expr
	| '!' expr
	;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    VARIABLE, '=', LABEL, LEFT, DOT_X, 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:1401: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:1401"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:1401: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:1401"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:1401: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:1401"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:1401: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:1401"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:1401: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:1401"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:471.11-48: warning: rule useless in parser due to conflicts: path: ORDINAL LAST object_type relative_path
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401: sed -n 's/^state //p' input.output | tail -1"
at_fn_check_prepare_notrace 'a shell pipeline' "existing.at:1401"
( $at_check_trace; sed -n 's/^state //p' input.output | tail -1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "422
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401: sed 's/^%define lr.type .*\$//' input.y > input-lalr.y"
at_fn_check_prepare_dynamic "sed 's/^%define lr.type .*$//' input.y > input-lalr.y" "existing.at:1401"
( $at_check_trace; sed 's/^%define lr.type .*$//' input.y > input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:1401: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input-lalr.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:1401"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:1401: bison --xml=xml-tests/test.xml --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:1401"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:1401: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:1401"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:1401: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:1401"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:1401: bison --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:1401"
( $at_check_trace; bison --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/existing.at:1401: diff -u input-lalr.output input.output \\
           | sed -n '/^@@/,\$p' | sed 's/^ \$//'"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:1401"
( $at_check_trace; diff -u input-lalr.output input.output \
           | sed -n '/^@@/,$p' | sed 's/^ $//'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "existing.at:1401"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "existing.at:1401"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected LEFT
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_223
#AT_START_224
at_fn_group_banner 224 'existing.at:1401' \
  "GNU pic (Groff 1.18.1) Grammar: IELR(1)" "        " 16
at_xfail=no
(
  $as_echo "224. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type ielr
%error-verbose
%union {}

%token LABEL
%token VARIABLE
%token NUMBER
%token TEXT
%token COMMAND_LINE
%token DELIMITED
%token ORDINAL
%token TH
%token LEFT_ARROW_HEAD
%token RIGHT_ARROW_HEAD
%token DOUBLE_ARROW_HEAD
%token LAST
%token UP
%token DOWN
%token LEFT
%token RIGHT
%token BOX
%token CIRCLE
%token ELLIPSE
%token ARC
%token LINE
%token ARROW
%token MOVE
%token SPLINE
%token HEIGHT
%token RADIUS
%token WIDTH
%token DIAMETER
%token FROM
%token TO
%token AT
%token WITH
%token BY
%token THEN
%token SOLID
%token DOTTED
%token DASHED
%token CHOP
%token SAME
%token INVISIBLE
%token LJUST
%token RJUST
%token ABOVE
%token BELOW
%token OF
%token THE
%token WAY
%token BETWEEN
%token AND
%token HERE
%token DOT_N
%token DOT_E
%token DOT_W
%token DOT_S
%token DOT_NE
%token DOT_SE
%token DOT_NW
%token DOT_SW
%token DOT_C
%token DOT_START
%token DOT_END
%token DOT_X
%token DOT_Y
%token DOT_HT
%token DOT_WID
%token DOT_RAD
%token SIN
%token COS
%token ATAN2
%token LOG
%token EXP
%token SQRT
%token K_MAX
%token K_MIN
%token INT
%token RAND
%token SRAND
%token COPY
%token THRU
%token TOP
%token BOTTOM
%token UPPER
%token LOWER
%token SH
%token PRINT
%token CW
%token CCW
%token FOR
%token DO
%token IF
%token ELSE
%token ANDAND
%token OROR
%token NOTEQUAL
%token EQUALEQUAL
%token LESSEQUAL
%token GREATEREQUAL
%token LEFT_CORNER
%token RIGHT_CORNER
%token NORTH
%token SOUTH
%token EAST
%token WEST
%token CENTER
%token END
%token START
%token RESET
%token UNTIL
%token PLOT
%token THICKNESS
%token FILL
%token COLORED
%token OUTLINED
%token SHADED
%token ALIGNED
%token SPRINTF
%token COMMAND

%left '.'

/* this ensures that plot 17 "%g" parses as (plot 17 "%g") */
%left PLOT
%left TEXT SPRINTF

/* give text adjustments higher precedence than TEXT, so that
box "foo" above ljust == box ("foo" above ljust)
*/

%left LJUST RJUST ABOVE BELOW

%left LEFT RIGHT
/* Give attributes that take an optional expression a higher
precedence than left and right, so that eg `line chop left'
parses properly. */
%left CHOP SOLID DASHED DOTTED UP DOWN FILL COLORED OUTLINED
%left LABEL

%left VARIABLE NUMBER '(' SIN COS ATAN2 LOG EXP SQRT K_MAX K_MIN INT RAND SRAND LAST
%left ORDINAL HERE '`'

%left BOX CIRCLE ELLIPSE ARC LINE ARROW SPLINE '[' /* ] */

/* these need to be lower than '-' */
%left HEIGHT RADIUS WIDTH DIAMETER FROM TO AT THICKNESS

/* these must have higher precedence than CHOP so that `label %prec CHOP'
works */
%left DOT_N DOT_E DOT_W DOT_S DOT_NE DOT_SE DOT_NW DOT_SW DOT_C
%left DOT_START DOT_END TOP BOTTOM LEFT_CORNER RIGHT_CORNER
%left UPPER LOWER NORTH SOUTH EAST WEST CENTER START END

%left ','
%left OROR
%left ANDAND
%left EQUALEQUAL NOTEQUAL
%left '<' '>' LESSEQUAL GREATEREQUAL

%left BETWEEN OF
%left AND

%left '+' '-'
%left '*' '/' '%'
%right '!'
%right '^'


%%


top:
	optional_separator
	| element_list
	;

element_list:
	optional_separator middle_element_list optional_separator
	;

middle_element_list:
	element
	| middle_element_list separator element
	;

optional_separator:
	/* empty */
	| separator
	;

separator:
	';'
	| separator ';'
	;

placeless_element:
	VARIABLE '=' any_expr
	| VARIABLE ':' '=' any_expr
	| UP
	| DOWN
	| LEFT
	| RIGHT
	| COMMAND_LINE
	| COMMAND print_args
	| PRINT print_args
	| SH
		{}
	  DELIMITED
	| COPY TEXT
	| COPY TEXT THRU
		{}
	  DELIMITED
		{}
	  until
	| COPY THRU
		{}
	  DELIMITED
		{}
	  until
	| FOR VARIABLE '=' expr TO expr optional_by DO
		{}
	  DELIMITED
	| simple_if
	| simple_if ELSE
		{}
	  DELIMITED
	| reset_variables
	| RESET
	;

reset_variables:
	RESET VARIABLE
	| reset_variables VARIABLE
	| reset_variables ',' VARIABLE
	;

print_args:
	print_arg
	| print_args print_arg
	;

print_arg:
	expr							%prec ','
	| text
	| position						%prec ','
	;

simple_if:
	IF any_expr THEN
		{}
	DELIMITED
	;

until:
	/* empty */
	| UNTIL TEXT
	;

any_expr:
	expr
	| text_expr
	;

text_expr:
	text EQUALEQUAL text
	| text NOTEQUAL text
	| text_expr ANDAND text_expr
	| text_expr ANDAND expr
	| expr ANDAND text_expr
	| text_expr OROR text_expr
	| text_expr OROR expr
	| expr OROR text_expr
	| '!' text_expr
	;

optional_by:
	/* empty */
	| BY expr
	| BY '*' expr
	;

element:
	object_spec
	| LABEL ':' optional_separator element
	| LABEL ':' optional_separator position_not_place
	| LABEL ':' optional_separator place
	| '{' {} element_list '}'
		{}
	  optional_element
	| placeless_element
	;

optional_element:
	/* empty */
	| element
	;

object_spec:
	BOX
	| CIRCLE
	| ELLIPSE
	| ARC
	| LINE
	| ARROW
	| MOVE
	| SPLINE
	| text							%prec TEXT
	| PLOT expr
	| PLOT expr text
	| '['
		{}
	  element_list ']'
	| object_spec HEIGHT expr
	| object_spec RADIUS expr
	| object_spec WIDTH expr
	| object_spec DIAMETER expr
	| object_spec expr					%prec HEIGHT
	| object_spec UP
	| object_spec UP expr
	| object_spec DOWN
	| object_spec DOWN expr
	| object_spec RIGHT
	| object_spec RIGHT expr
	| object_spec LEFT
	| object_spec LEFT expr
	| object_spec FROM position
	| object_spec TO position
	| object_spec AT position
	| object_spec WITH path
	| object_spec WITH position				%prec ','
	| object_spec BY expr_pair
	| object_spec THEN
	| object_spec SOLID
	| object_spec DOTTED
	| object_spec DOTTED expr
	| object_spec DASHED
	| object_spec DASHED expr
	| object_spec FILL
	| object_spec FILL expr
	| object_spec SHADED text
	| object_spec COLORED text
	| object_spec OUTLINED text
	| object_spec CHOP
	| object_spec CHOP expr
	| object_spec SAME
	| object_spec INVISIBLE
	| object_spec LEFT_ARROW_HEAD
	| object_spec RIGHT_ARROW_HEAD
	| object_spec DOUBLE_ARROW_HEAD
	| object_spec CW
	| object_spec CCW
	| object_spec text					%prec TEXT
	| object_spec LJUST
	| object_spec RJUST
	| object_spec ABOVE
	| object_spec BELOW
	| object_spec THICKNESS expr
	| object_spec ALIGNED
	;

text:
	TEXT
	| SPRINTF '(' TEXT sprintf_args ')'
	;

sprintf_args:
	/* empty */
	| sprintf_args ',' expr
	;

position:
	position_not_place
	| place
	;

position_not_place:
	expr_pair
	| position '+' expr_pair
	| position '-' expr_pair
	| '(' position ',' position ')'
	| expr between position AND position
	| expr '<' position ',' position '>'
	;

between:
	BETWEEN
	| OF THE WAY BETWEEN
	;

expr_pair:
	expr ',' expr
	| '(' expr_pair ')'
	;

place:
	/* line at A left == line (at A) left */
	label							%prec CHOP
	| label corner
	| corner label
	| corner OF label
	| HERE
	;

label:
	LABEL
	| nth_primitive
	| label '.' LABEL
	;

ordinal:
	ORDINAL
	| '`' any_expr TH
	;

optional_ordinal_last:
	LAST
	| ordinal LAST
	;

nth_primitive:
	ordinal object_type
	| optional_ordinal_last object_type
	;

object_type:
	BOX
	| CIRCLE
	| ELLIPSE
	| ARC
	| LINE
	| ARROW
	| SPLINE
	| '[' ']'
	| TEXT
	;

label_path:
	'.' LABEL
	| label_path '.' LABEL
	;

relative_path:
	corner							%prec CHOP
	/* give this a lower precedence than LEFT and RIGHT so that
	   [A: box] with .A left == [A: box] with (.A left) */
	| label_path						%prec TEXT
	| label_path corner
	;

path:
	relative_path
	| '(' relative_path ',' relative_path ')'
		{}
	/* The rest of these rules are a compatibility sop. */
	| ORDINAL LAST object_type relative_path
	| LAST object_type relative_path
	| ORDINAL object_type relative_path
	| LABEL relative_path
	;

corner:
	DOT_N
	| DOT_E
	| DOT_W
	| DOT_S
	| DOT_NE
	| DOT_SE
	| DOT_NW
	| DOT_SW
	| DOT_C
	| DOT_START
	| DOT_END
	| TOP
	| BOTTOM
	| LEFT
	| RIGHT
	| UPPER LEFT
	| LOWER LEFT
	| UPPER RIGHT
	| LOWER RIGHT
	| LEFT_CORNER
	| RIGHT_CORNER
	| UPPER LEFT_CORNER
	| LOWER LEFT_CORNER
	| UPPER RIGHT_CORNER
	| LOWER RIGHT_CORNER
	| NORTH
	| SOUTH
	| EAST
	| WEST
	| CENTER
	| START
	| END
	;

expr:
	VARIABLE
	| NUMBER
	| place DOT_X
	| place DOT_Y
	| place DOT_HT
	| place DOT_WID
	| place DOT_RAD
	| expr '+' expr
	| expr '-' expr
	| expr '*' expr
	| expr '/' expr
	| expr '%' expr
	| expr '^' expr
	| '-' expr						%prec '!'
	| '(' any_expr ')'
	| SIN '(' any_expr ')'
	| COS '(' any_expr ')'
	| ATAN2 '(' any_expr ',' any_expr ')'
	| LOG '(' any_expr ')'
	| EXP '(' any_expr ')'
	| SQRT '(' any_expr ')'
	| K_MAX '(' any_expr ',' any_expr ')'
	| K_MIN '(' any_expr ',' any_expr ')'
	| INT '(' any_expr ')'
	| RAND '(' any_expr ')'
	| RAND '(' ')'
	| SRAND '(' any_expr ')'
	| expr '<' expr
	| expr LESSEQUAL expr
	| expr '>' expr
	| expr GREATEREQUAL expr
	| expr EQUALEQUAL expr
	| expr NOTEQUAL expr
	| expr ANDAND expr
	| expr OROR expr
	| '!' expr
	;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    VARIABLE, '=', LABEL, LEFT, DOT_X, 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:1401: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:1401"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:1401: bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:1401"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:1401: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:1401"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:1401: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:1401"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:1401: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:1401"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:471.11-48: warning: rule useless in parser due to conflicts: path: ORDINAL LAST object_type relative_path
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401: sed -n 's/^state //p' input.output | tail -1"
at_fn_check_prepare_notrace 'a shell pipeline' "existing.at:1401"
( $at_check_trace; sed -n 's/^state //p' input.output | tail -1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "427
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401: sed 's/^%define lr.type .*\$//' input.y > input-lalr.y"
at_fn_check_prepare_dynamic "sed 's/^%define lr.type .*$//' input.y > input-lalr.y" "existing.at:1401"
( $at_check_trace; sed 's/^%define lr.type .*$//' input.y > input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/existing.at:1401: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input-lalr.y"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:1401"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/existing.at:1401: bison --xml=xml-tests/test.xml --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:1401"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/existing.at:1401: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:1401"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/existing.at:1401: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "existing.at:1401"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/existing.at:1401: bison --report=all input-lalr.y"
at_fn_check_prepare_trace "existing.at:1401"
( $at_check_trace; bison --report=all input-lalr.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/existing.at:1401: diff -u input-lalr.output input.output \\
           | sed -n '/^@@/,\$p' | sed 's/^ \$//'"
at_fn_check_prepare_notrace 'an embedded newline' "existing.at:1401"
( $at_check_trace; diff -u input-lalr.output input.output \
           | sed -n '/^@@/,$p' | sed 's/^ $//'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "@@ -1223,7 +1223,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -1377,7 +1377,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -1854,7 +1854,7 @@

     text                   go to state 162
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -2047,7 +2047,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -2571,7 +2571,7 @@
     position_not_place     go to state 99
     expr_pair              go to state 191
     place                  go to state 101
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -2732,7 +2732,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -2875,7 +2875,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -3018,7 +3018,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -3256,7 +3256,7 @@

 state 102

-  146 place: label .  [\$end, LABEL, VARIABLE, NUMBER, TEXT, ORDINAL, LEFT_ARROW_HEAD, RIGHT_ARROW_HEAD, DOUBLE_ARROW_HEAD, LAST, UP, DOWN, LEFT, RIGHT, HEIGHT, RADIUS, WIDTH, DIAMETER, FROM, TO, AT, WITH, BY, THEN, SOLID, DOTTED, DASHED, CHOP, SAME, INVISIBLE, LJUST, RJUST, ABOVE, BELOW, AND, HERE, DOT_X, DOT_Y, DOT_HT, DOT_WID, DOT_RAD, SIN, COS, ATAN2, LOG, EXP, SQRT, K_MAX, K_MIN, INT, RAND, SRAND, CW, CCW, THICKNESS, FILL, COLORED, OUTLINED, SHADED, ALIGNED, SPRINTF, '(', '\`', ',', '>', '+', '-', '!', ';', '}', ']', ')']
+  146 place: label .  [\$end, LABEL, VARIABLE, NUMBER, TEXT, ORDINAL, LEFT_ARROW_HEAD, RIGHT_ARROW_HEAD, DOUBLE_ARROW_HEAD, LAST, UP, DOWN, LEFT, RIGHT, HEIGHT, RADIUS, WIDTH, DIAMETER, FROM, TO, AT, WITH, BY, THEN, SOLID, DOTTED, DASHED, CHOP, SAME, INVISIBLE, LJUST, RJUST, ABOVE, BELOW, HERE, DOT_X, DOT_Y, DOT_HT, DOT_WID, DOT_RAD, SIN, COS, ATAN2, LOG, EXP, SQRT, K_MAX, K_MIN, INT, RAND, SRAND, CW, CCW, THICKNESS, FILL, COLORED, OUTLINED, SHADED, ALIGNED, SPRINTF, '(', '\`', '+', '-', '!', ';', '}', ']']
   147      | label . corner
   153 label: label . '.' LABEL
   180 corner: . DOT_N
@@ -3645,7 +3645,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -3804,7 +3804,7 @@
     text_expr              go to state 239
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -4481,7 +4481,7 @@
     \$default  reduce using rule 89 (object_spec)

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -4673,7 +4673,7 @@
     \$default  reduce using rule 91 (object_spec)

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -4867,7 +4867,7 @@
     \$default  reduce using rule 95 (object_spec)

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -5065,7 +5065,7 @@
     \$default  reduce using rule 93 (object_spec)

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -5260,7 +5260,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -5403,7 +5403,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -5546,7 +5546,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -5689,7 +5689,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -6475,7 +6475,7 @@

     expr_pair              go to state 280
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -6633,7 +6633,7 @@
     \$default  reduce using rule 105 (object_spec)

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -6825,7 +6825,7 @@
     \$default  reduce using rule 107 (object_spec)

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -7017,7 +7017,7 @@
     \$default  reduce using rule 114 (object_spec)

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -7264,7 +7264,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -7408,7 +7408,7 @@
     \$default  reduce using rule 109 (object_spec)

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -7819,12 +7819,12 @@
     position_not_place     go to state 296
     expr_pair              go to state 100
     place                  go to state 297
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
     corner                 go to state 106
-    expr                   go to state 266
+    expr                   go to state 424


 state 165
@@ -7987,7 +7987,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -8172,7 +8172,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -8333,7 +8333,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -8494,7 +8494,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -8655,7 +8655,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -8816,7 +8816,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -8977,7 +8977,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -9138,7 +9138,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -9299,7 +9299,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -9460,7 +9460,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -9623,7 +9623,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -9784,7 +9784,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -9921,7 +9921,7 @@

     \$default  reduce using rule 47 (any_expr)

-    between  go to state 237
+    between  go to state 425


 state 193
@@ -10152,7 +10152,7 @@

     expr_pair              go to state 317
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -10298,7 +10298,7 @@

     expr_pair              go to state 318
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -10622,7 +10622,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -10765,7 +10765,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -10908,7 +10908,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -11051,7 +11051,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -11194,7 +11194,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -11337,7 +11337,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -11480,7 +11480,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -11637,7 +11637,7 @@
     position_not_place     go to state 99
     expr_pair              go to state 100
     place                  go to state 101
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -11780,7 +11780,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -11923,7 +11923,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -12066,7 +12066,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -12209,7 +12209,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -12352,7 +12352,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -12495,7 +12495,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -12638,7 +12638,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -12794,12 +12794,12 @@
     position_not_place     go to state 99
     expr_pair              go to state 100
     place                  go to state 101
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
     corner                 go to state 106
-    expr                   go to state 266
+    expr                   go to state 424


 state 238
@@ -12937,7 +12937,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -13160,7 +13160,7 @@
     text_expr              go to state 342
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -13319,7 +13319,7 @@
     text_expr              go to state 344
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -13502,7 +13502,7 @@
     text_expr              go to state 348
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -13661,7 +13661,7 @@
     text_expr              go to state 350
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -13804,7 +13804,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -14747,7 +14747,7 @@
     position_not_place     go to state 99
     expr_pair              go to state 191
     place                  go to state 101
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -15074,7 +15074,7 @@
     text                   go to state 113
     expr_pair              go to state 365
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -15693,12 +15693,12 @@
     position_not_place     go to state 99
     expr_pair              go to state 100
     place                  go to state 101
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
     corner                 go to state 106
-    expr                   go to state 266
+    expr                   go to state 424


 state 315
@@ -16124,7 +16124,7 @@

     \$default  reduce using rule 239 (expr)

-    between  go to state 237
+    between  go to state 425

     Conflict between rule 239 and token OF resolved as shift ('<' < OF).
     Conflict between rule 239 and token BETWEEN resolved as shift ('<' < BETWEEN).
@@ -17234,7 +17234,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -17416,7 +17416,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -17577,7 +17577,7 @@
     text_expr              go to state 112
     text                   go to state 113
     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -17772,12 +17772,12 @@
     position_not_place     go to state 99
     expr_pair              go to state 100
     place                  go to state 101
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
     corner                 go to state 106
-    expr                   go to state 266
+    expr                   go to state 424


 state 383
@@ -18071,7 +18071,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -18221,7 +18221,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -18830,7 +18830,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -18987,7 +18987,7 @@
     '!'           shift, and go to state 94

     place                  go to state 114
-    label                  go to state 102
+    label                  go to state 423
     ordinal                go to state 103
     optional_ordinal_last  go to state 104
     nth_primitive          go to state 105
@@ -19089,3 +19089,440 @@
    29 placeless_element: FOR VARIABLE '=' expr TO expr optional_by DO \$@6 DELIMITED .

     \$default  reduce using rule 29 (placeless_element)
+
+
+state 423
+
+  146 place: label .  [\$end, AND, DOT_X, DOT_Y, DOT_HT, DOT_WID, DOT_RAD, ',', '>', '+', '-', ';', '}', ']', ')']
+  147      | label . corner
+  153 label: label . '.' LABEL
+  180 corner: . DOT_N
+  181       | . DOT_E
+  182       | . DOT_W
+  183       | . DOT_S
+  184       | . DOT_NE
+  185       | . DOT_SE
+  186       | . DOT_NW
+  187       | . DOT_SW
+  188       | . DOT_C
+  189       | . DOT_START
+  190       | . DOT_END
+  191       | . TOP
+  192       | . BOTTOM
+  193       | . LEFT
+  194       | . RIGHT
+  195       | . UPPER LEFT
+  196       | . LOWER LEFT
+  197       | . UPPER RIGHT
+  198       | . LOWER RIGHT
+  199       | . LEFT_CORNER
+  200       | . RIGHT_CORNER
+  201       | . UPPER LEFT_CORNER
+  202       | . LOWER LEFT_CORNER
+  203       | . UPPER RIGHT_CORNER
+  204       | . LOWER RIGHT_CORNER
+  205       | . NORTH
+  206       | . SOUTH
+  207       | . EAST
+  208       | . WEST
+  209       | . CENTER
+  210       | . START
+  211       | . END
+
+    LEFT          shift, and go to state 53
+    RIGHT         shift, and go to state 54
+    DOT_N         shift, and go to state 56
+    DOT_E         shift, and go to state 57
+    DOT_W         shift, and go to state 58
+    DOT_S         shift, and go to state 59
+    DOT_NE        shift, and go to state 60
+    DOT_SE        shift, and go to state 61
+    DOT_NW        shift, and go to state 62
+    DOT_SW        shift, and go to state 63
+    DOT_C         shift, and go to state 64
+    DOT_START     shift, and go to state 65
+    DOT_END       shift, and go to state 66
+    TOP           shift, and go to state 78
+    BOTTOM        shift, and go to state 79
+    UPPER         shift, and go to state 80
+    LOWER         shift, and go to state 81
+    LEFT_CORNER   shift, and go to state 82
+    RIGHT_CORNER  shift, and go to state 83
+    NORTH         shift, and go to state 84
+    SOUTH         shift, and go to state 85
+    EAST          shift, and go to state 86
+    WEST          shift, and go to state 87
+    CENTER        shift, and go to state 88
+    END           shift, and go to state 89
+    START         shift, and go to state 90
+    '.'           shift, and go to state 204
+
+    \$default  reduce using rule 146 (place)
+
+    corner  go to state 205
+
+
+state 424
+
+  140 position_not_place: expr . between position AND position
+  141                   | expr . '<' position ',' position '>'
+  142 between: . BETWEEN
+  143        | . OF THE WAY BETWEEN
+  144 expr_pair: expr . ',' expr
+  219 expr: expr . '+' expr
+  220     | expr . '-' expr
+  221     | expr . '*' expr
+  222     | expr . '/' expr
+  223     | expr . '%' expr
+  224     | expr . '^' expr
+  239     | expr . '<' expr
+  240     | expr . LESSEQUAL expr
+  241     | expr . '>' expr
+  242     | expr . GREATEREQUAL expr
+  243     | expr . EQUALEQUAL expr
+  244     | expr . NOTEQUAL expr
+  245     | expr . ANDAND expr
+  246     | expr . OROR expr
+
+    OF            shift, and go to state 220
+    BETWEEN       shift, and go to state 221
+    ANDAND        shift, and go to state 222
+    OROR          shift, and go to state 223
+    NOTEQUAL      shift, and go to state 224
+    EQUALEQUAL    shift, and go to state 225
+    LESSEQUAL     shift, and go to state 226
+    GREATEREQUAL  shift, and go to state 227
+    ','           shift, and go to state 228
+    '<'           shift, and go to state 229
+    '>'           shift, and go to state 230
+    '+'           shift, and go to state 231
+    '-'           shift, and go to state 232
+    '*'           shift, and go to state 233
+    '/'           shift, and go to state 234
+    '%'           shift, and go to state 235
+    '^'           shift, and go to state 236
+
+    between  go to state 425
+
+
+state 425
+
+  134 position: . position_not_place
+  135         | . place
+  136 position_not_place: . expr_pair
+  137                   | . position '+' expr_pair
+  138                   | . position '-' expr_pair
+  139                   | . '(' position ',' position ')'
+  140                   | . expr between position AND position
+  140                   | expr between . position AND position
+  141                   | . expr '<' position ',' position '>'
+  144 expr_pair: . expr ',' expr
+  145          | . '(' expr_pair ')'
+  146 place: . label
+  147      | . label corner
+  148      | . corner label
+  149      | . corner OF label
+  150      | . HERE
+  151 label: . LABEL
+  152      | . nth_primitive
+  153      | . label '.' LABEL
+  154 ordinal: . ORDINAL
+  155        | . '\`' any_expr TH
+  156 optional_ordinal_last: . LAST
+  157                      | . ordinal LAST
+  158 nth_primitive: . ordinal object_type
+  159              | . optional_ordinal_last object_type
+  180 corner: . DOT_N
+  181       | . DOT_E
+  182       | . DOT_W
+  183       | . DOT_S
+  184       | . DOT_NE
+  185       | . DOT_SE
+  186       | . DOT_NW
+  187       | . DOT_SW
+  188       | . DOT_C
+  189       | . DOT_START
+  190       | . DOT_END
+  191       | . TOP
+  192       | . BOTTOM
+  193       | . LEFT
+  194       | . RIGHT
+  195       | . UPPER LEFT
+  196       | . LOWER LEFT
+  197       | . UPPER RIGHT
+  198       | . LOWER RIGHT
+  199       | . LEFT_CORNER
+  200       | . RIGHT_CORNER
+  201       | . UPPER LEFT_CORNER
+  202       | . LOWER LEFT_CORNER
+  203       | . UPPER RIGHT_CORNER
+  204       | . LOWER RIGHT_CORNER
+  205       | . NORTH
+  206       | . SOUTH
+  207       | . EAST
+  208       | . WEST
+  209       | . CENTER
+  210       | . START
+  211       | . END
+  212 expr: . VARIABLE
+  213     | . NUMBER
+  214     | . place DOT_X
+  215     | . place DOT_Y
+  216     | . place DOT_HT
+  217     | . place DOT_WID
+  218     | . place DOT_RAD
+  219     | . expr '+' expr
+  220     | . expr '-' expr
+  221     | . expr '*' expr
+  222     | . expr '/' expr
+  223     | . expr '%' expr
+  224     | . expr '^' expr
+  225     | . '-' expr
+  226     | . '(' any_expr ')'
+  227     | . SIN '(' any_expr ')'
+  228     | . COS '(' any_expr ')'
+  229     | . ATAN2 '(' any_expr ',' any_expr ')'
+  230     | . LOG '(' any_expr ')'
+  231     | . EXP '(' any_expr ')'
+  232     | . SQRT '(' any_expr ')'
+  233     | . K_MAX '(' any_expr ',' any_expr ')'
+  234     | . K_MIN '(' any_expr ',' any_expr ')'
+  235     | . INT '(' any_expr ')'
+  236     | . RAND '(' any_expr ')'
+  237     | . RAND '(' ')'
+  238     | . SRAND '(' any_expr ')'
+  239     | . expr '<' expr
+  240     | . expr LESSEQUAL expr
+  241     | . expr '>' expr
+  242     | . expr GREATEREQUAL expr
+  243     | . expr EQUALEQUAL expr
+  244     | . expr NOTEQUAL expr
+  245     | . expr ANDAND expr
+  246     | . expr OROR expr
+  247     | . '!' expr
+
+    LABEL         shift, and go to state 48
+    VARIABLE      shift, and go to state 49
+    NUMBER        shift, and go to state 50
+    ORDINAL       shift, and go to state 51
+    LAST          shift, and go to state 52
+    LEFT          shift, and go to state 53
+    RIGHT         shift, and go to state 54
+    HERE          shift, and go to state 55
+    DOT_N         shift, and go to state 56
+    DOT_E         shift, and go to state 57
+    DOT_W         shift, and go to state 58
+    DOT_S         shift, and go to state 59
+    DOT_NE        shift, and go to state 60
+    DOT_SE        shift, and go to state 61
+    DOT_NW        shift, and go to state 62
+    DOT_SW        shift, and go to state 63
+    DOT_C         shift, and go to state 64
+    DOT_START     shift, and go to state 65
+    DOT_END       shift, and go to state 66
+    SIN           shift, and go to state 67
+    COS           shift, and go to state 68
+    ATAN2         shift, and go to state 69
+    LOG           shift, and go to state 70
+    EXP           shift, and go to state 71
+    SQRT          shift, and go to state 72
+    K_MAX         shift, and go to state 73
+    K_MIN         shift, and go to state 74
+    INT           shift, and go to state 75
+    RAND          shift, and go to state 76
+    SRAND         shift, and go to state 77
+    TOP           shift, and go to state 78
+    BOTTOM        shift, and go to state 79
+    UPPER         shift, and go to state 80
+    LOWER         shift, and go to state 81
+    LEFT_CORNER   shift, and go to state 82
+    RIGHT_CORNER  shift, and go to state 83
+    NORTH         shift, and go to state 84
+    SOUTH         shift, and go to state 85
+    EAST          shift, and go to state 86
+    WEST          shift, and go to state 87
+    CENTER        shift, and go to state 88
+    END           shift, and go to state 89
+    START         shift, and go to state 90
+    '('           shift, and go to state 91
+    '\`'           shift, and go to state 92
+    '-'           shift, and go to state 93
+    '!'           shift, and go to state 94
+
+    position               go to state 426
+    position_not_place     go to state 99
+    expr_pair              go to state 100
+    place                  go to state 101
+    label                  go to state 423
+    ordinal                go to state 103
+    optional_ordinal_last  go to state 104
+    nth_primitive          go to state 105
+    corner                 go to state 106
+    expr                   go to state 424
+
+
+state 426
+
+  137 position_not_place: position . '+' expr_pair
+  138                   | position . '-' expr_pair
+  140                   | expr between position . AND position
+
+    AND  shift, and go to state 427
+    '+'  shift, and go to state 197
+    '-'  shift, and go to state 198
+
+
+state 427
+
+  134 position: . position_not_place
+  135         | . place
+  136 position_not_place: . expr_pair
+  137                   | . position '+' expr_pair
+  138                   | . position '-' expr_pair
+  139                   | . '(' position ',' position ')'
+  140                   | . expr between position AND position
+  140                   | expr between position AND . position
+  141                   | . expr '<' position ',' position '>'
+  144 expr_pair: . expr ',' expr
+  145          | . '(' expr_pair ')'
+  146 place: . label
+  147      | . label corner
+  148      | . corner label
+  149      | . corner OF label
+  150      | . HERE
+  151 label: . LABEL
+  152      | . nth_primitive
+  153      | . label '.' LABEL
+  154 ordinal: . ORDINAL
+  155        | . '\`' any_expr TH
+  156 optional_ordinal_last: . LAST
+  157                      | . ordinal LAST
+  158 nth_primitive: . ordinal object_type
+  159              | . optional_ordinal_last object_type
+  180 corner: . DOT_N
+  181       | . DOT_E
+  182       | . DOT_W
+  183       | . DOT_S
+  184       | . DOT_NE
+  185       | . DOT_SE
+  186       | . DOT_NW
+  187       | . DOT_SW
+  188       | . DOT_C
+  189       | . DOT_START
+  190       | . DOT_END
+  191       | . TOP
+  192       | . BOTTOM
+  193       | . LEFT
+  194       | . RIGHT
+  195       | . UPPER LEFT
+  196       | . LOWER LEFT
+  197       | . UPPER RIGHT
+  198       | . LOWER RIGHT
+  199       | . LEFT_CORNER
+  200       | . RIGHT_CORNER
+  201       | . UPPER LEFT_CORNER
+  202       | . LOWER LEFT_CORNER
+  203       | . UPPER RIGHT_CORNER
+  204       | . LOWER RIGHT_CORNER
+  205       | . NORTH
+  206       | . SOUTH
+  207       | . EAST
+  208       | . WEST
+  209       | . CENTER
+  210       | . START
+  211       | . END
+  212 expr: . VARIABLE
+  213     | . NUMBER
+  214     | . place DOT_X
+  215     | . place DOT_Y
+  216     | . place DOT_HT
+  217     | . place DOT_WID
+  218     | . place DOT_RAD
+  219     | . expr '+' expr
+  220     | . expr '-' expr
+  221     | . expr '*' expr
+  222     | . expr '/' expr
+  223     | . expr '%' expr
+  224     | . expr '^' expr
+  225     | . '-' expr
+  226     | . '(' any_expr ')'
+  227     | . SIN '(' any_expr ')'
+  228     | . COS '(' any_expr ')'
+  229     | . ATAN2 '(' any_expr ',' any_expr ')'
+  230     | . LOG '(' any_expr ')'
+  231     | . EXP '(' any_expr ')'
+  232     | . SQRT '(' any_expr ')'
+  233     | . K_MAX '(' any_expr ',' any_expr ')'
+  234     | . K_MIN '(' any_expr ',' any_expr ')'
+  235     | . INT '(' any_expr ')'
+  236     | . RAND '(' any_expr ')'
+  237     | . RAND '(' ')'
+  238     | . SRAND '(' any_expr ')'
+  239     | . expr '<' expr
+  240     | . expr LESSEQUAL expr
+  241     | . expr '>' expr
+  242     | . expr GREATEREQUAL expr
+  243     | . expr EQUALEQUAL expr
+  244     | . expr NOTEQUAL expr
+  245     | . expr ANDAND expr
+  246     | . expr OROR expr
+  247     | . '!' expr
+
+    LABEL         shift, and go to state 48
+    VARIABLE      shift, and go to state 49
+    NUMBER        shift, and go to state 50
+    ORDINAL       shift, and go to state 51
+    LAST          shift, and go to state 52
+    LEFT          shift, and go to state 53
+    RIGHT         shift, and go to state 54
+    HERE          shift, and go to state 55
+    DOT_N         shift, and go to state 56
+    DOT_E         shift, and go to state 57
+    DOT_W         shift, and go to state 58
+    DOT_S         shift, and go to state 59
+    DOT_NE        shift, and go to state 60
+    DOT_SE        shift, and go to state 61
+    DOT_NW        shift, and go to state 62
+    DOT_SW        shift, and go to state 63
+    DOT_C         shift, and go to state 64
+    DOT_START     shift, and go to state 65
+    DOT_END       shift, and go to state 66
+    SIN           shift, and go to state 67
+    COS           shift, and go to state 68
+    ATAN2         shift, and go to state 69
+    LOG           shift, and go to state 70
+    EXP           shift, and go to state 71
+    SQRT          shift, and go to state 72
+    K_MAX         shift, and go to state 73
+    K_MIN         shift, and go to state 74
+    INT           shift, and go to state 75
+    RAND          shift, and go to state 76
+    SRAND         shift, and go to state 77
+    TOP           shift, and go to state 78
+    BOTTOM        shift, and go to state 79
+    UPPER         shift, and go to state 80
+    LOWER         shift, and go to state 81
+    LEFT_CORNER   shift, and go to state 82
+    RIGHT_CORNER  shift, and go to state 83
+    NORTH         shift, and go to state 84
+    SOUTH         shift, and go to state 85
+    EAST          shift, and go to state 86
+    WEST          shift, and go to state 87
+    CENTER        shift, and go to state 88
+    END           shift, and go to state 89
+    START         shift, and go to state 90
+    '('           shift, and go to state 91
+    '\`'           shift, and go to state 92
+    '-'           shift, and go to state 93
+    '!'           shift, and go to state 94
+
+    position               go to state 402
+    position_not_place     go to state 99
+    expr_pair              go to state 100
+    place                  go to state 101
+    label                  go to state 423
+    ordinal                go to state 103
+    optional_ordinal_last  go to state 104
+    nth_primitive          go to state 105
+    corner                 go to state 106
+    expr                   go to state 424
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "existing.at:1401"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "existing.at:1401"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_224
#AT_START_225
at_fn_group_banner 225 'existing.at:1401' \
  "GNU pic (Groff 1.18.1) Grammar: Canonical LR(1)" "" 16
at_xfail=no
(
  $as_echo "225. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

%define lr.type canonical-lr
%error-verbose
%union {}

%token LABEL
%token VARIABLE
%token NUMBER
%token TEXT
%token COMMAND_LINE
%token DELIMITED
%token ORDINAL
%token TH
%token LEFT_ARROW_HEAD
%token RIGHT_ARROW_HEAD
%token DOUBLE_ARROW_HEAD
%token LAST
%token UP
%token DOWN
%token LEFT
%token RIGHT
%token BOX
%token CIRCLE
%token ELLIPSE
%token ARC
%token LINE
%token ARROW
%token MOVE
%token SPLINE
%token HEIGHT
%token RADIUS
%token WIDTH
%token DIAMETER
%token FROM
%token TO
%token AT
%token WITH
%token BY
%token THEN
%token SOLID
%token DOTTED
%token DASHED
%token CHOP
%token SAME
%token INVISIBLE
%token LJUST
%token RJUST
%token ABOVE
%token BELOW
%token OF
%token THE
%token WAY
%token BETWEEN
%token AND
%token HERE
%token DOT_N
%token DOT_E
%token DOT_W
%token DOT_S
%token DOT_NE
%token DOT_SE
%token DOT_NW
%token DOT_SW
%token DOT_C
%token DOT_START
%token DOT_END
%token DOT_X
%token DOT_Y
%token DOT_HT
%token DOT_WID
%token DOT_RAD
%token SIN
%token COS
%token ATAN2
%token LOG
%token EXP
%token SQRT
%token K_MAX
%token K_MIN
%token INT
%token RAND
%token SRAND
%token COPY
%token THRU
%token TOP
%token BOTTOM
%token UPPER
%token LOWER
%token SH
%token PRINT
%token CW
%token CCW
%token FOR
%token DO
%token IF
%token ELSE
%token ANDAND
%token OROR
%token NOTEQUAL
%token EQUALEQUAL
%token LESSEQUAL
%token GREATEREQUAL
%token LEFT_CORNER
%token RIGHT_CORNER
%token NORTH
%token SOUTH
%token EAST
%token WEST
%token CENTER
%token END
%token START
%token RESET
%token UNTIL
%token PLOT
%token THICKNESS
%token FILL
%token COLORED
%token OUTLINED
%token SHADED
%token ALIGNED
%token SPRINTF
%token COMMAND

%left '.'

/* this ensures that plot 17 "%g" parses as (plot 17 "%g") */
%left PLOT
%left TEXT SPRINTF

/* give text adjustments higher precedence than TEXT, so that
box "foo" above ljust == box ("foo" above ljust)
*/

%left LJUST RJUST ABOVE BELOW

%left LEFT RIGHT
/* Give attributes that take an optional expression a higher
precedence than left and right, so that eg `line chop left'
parses properly. */
%left CHOP SOLID DASHED DOTTED UP DOWN FILL COLORED OUTLINED
%left LABEL

%left VARIABLE NUMBER '(' SIN COS ATAN2 LOG EXP SQRT K_MAX K_MIN INT RAND SRAND LAST
%left ORDINAL HERE '`'

%left BOX CIRCLE ELLIPSE ARC LINE ARROW SPLINE '[' /* ] */

/* these need to be lower than '-' */
%left HEIGHT RADIUS WIDTH DIAMETER FROM TO AT THICKNESS

/* these must have higher precedence than CHOP so that `label %prec CHOP'
works */
%left DOT_N DOT_E DOT_W DOT_S DOT_NE DOT_SE DOT_NW DOT_SW DOT_C
%left DOT_START DOT_END TOP BOTTOM LEFT_CORNER RIGHT_CORNER
%left UPPER LOWER NORTH SOUTH EAST WEST CENTER START END

%left ','
%left OROR
%left ANDAND
%left EQUALEQUAL NOTEQUAL
%left '<' '>' LESSEQUAL GREATEREQUAL

%left BETWEEN OF
%left AND

%left '+' '-'
%left '*' '/' '%'
%right '!'
%right '^'


%%


top:
	optional_separator
	| element_list
	;

element_list:
	optional_separator middle_element_list optional_separator
	;

middle_element_list:
	element
	| middle_element_list separator element
	;

optional_separator:
	/* empty */
	| separator
	;

separator:
	';'
	| separator ';'
	;

placeless_element:
	VARIABLE '=' any_expr
	| VARIABLE ':' '=' any_expr
	| UP
	| DOWN
	| LEFT
	| RIGHT
	| COMMAND_LINE
	| COMMAND print_args
	| PRINT print_args
	| SH
		{}
	  DELIMITED
	| COPY TEXT
	| COPY TEXT THRU
		{}
	  DELIMITED
		{}
	  until
	| COPY THRU
		{}
	  DELIMITED
		{}
	  until
	| FOR VARIABLE '=' expr TO expr optional_by DO
		{}
	  DELIMITED
	| simple_if
	| simple_if ELSE
		{}
	  DELIMITED
	| reset_variables
	| RESET
	;

reset_variables:
	RESET VARIABLE
	| reset_variables VARIABLE
	| reset_variables ',' VARIABLE
	;

print_args:
	print_arg
	| print_args print_arg
	;

print_arg:
	expr							%prec ','
	| text
	| position						%prec ','
	;

simple_if:
	IF any_expr THEN
		{}
	DELIMITED
	;

until:
	/* empty */
	| UNTIL TEXT
	;

any_expr:
	expr
	| text_expr
	;

text_expr:
	text EQUALEQUAL text
	| text NOTEQUAL text
	| text_expr ANDAND text_expr
	| text_expr ANDAND expr
	| expr ANDAND text_expr
	| text_expr OROR text_expr
	| text_expr OROR expr
	| expr OROR text_expr
	| '!' text_expr
	;

optional_by:
	/* empty */
	| BY expr
	| BY '*' expr
	;

element:
	object_spec
	| LABEL ':' optional_separator element
	| LABEL ':' optional_separator position_not_place
	| LABEL ':' optional_separator place
	| '{' {} element_list '}'
		{}
	  optional_element
	| placeless_element
	;

optional_element:
	/* empty */
	| element
	;

object_spec:
	BOX
	| CIRCLE
	| ELLIPSE
	| ARC
	| LINE
	| ARROW
	| MOVE
	| SPLINE
	| text							%prec TEXT
	| PLOT expr
	| PLOT expr text
	| '['
		{}
	  element_list ']'
	| object_spec HEIGHT expr
	| object_spec RADIUS expr
	| object_spec WIDTH expr
	| object_spec DIAMETER expr
	| object_spec expr					%prec HEIGHT
	| object_spec UP
	| object_spec UP expr
	| object_spec DOWN
	| object_spec DOWN expr
	| object_spec RIGHT
	| object_spec RIGHT expr
	| object_spec LEFT
	| object_spec LEFT expr
	| object_spec FROM position
	| object_spec TO position
	| object_spec AT position
	| object_spec WITH path
	| object_spec WITH position				%prec ','
	| object_spec BY expr_pair
	| object_spec THEN
	| object_spec SOLID
	| object_spec DOTTED
	| object_spec DOTTED expr
	| object_spec DASHED
	| object_spec DASHED expr
	| object_spec FILL
	| object_spec FILL expr
	| object_spec SHADED text
	| object_spec COLORED text
	| object_spec OUTLINED text
	| object_spec CHOP
	| object_spec CHOP expr
	| object_spec SAME
	| object_spec INVISIBLE
	| object_spec LEFT_ARROW_HEAD
	| object_spec RIGHT_ARROW_HEAD
	| object_spec DOUBLE_ARROW_HEAD
	| object_spec CW
	| object_spec CCW
	| object_spec text					%prec TEXT
	| object_spec LJUST
	| object_spec RJUST
	| object_spec ABOVE
	| object_spec BELOW
	| object_spec THICKNESS expr
	| object_spec ALIGNED
	;

text:
	TEXT
	| SPRINTF '(' TEXT sprintf_args ')'
	;

sprintf_args:
	/* empty */
	| sprintf_args ',' expr
	;

position:
	position_not_place
	| place
	;

position_not_place:
	expr_pair
	| position '+' expr_pair
	| position '-' expr_pair
	| '(' position ',' position ')'
	| expr between position AND position
	| expr '<' position ',' position '>'
	;

between:
	BETWEEN
	| OF THE WAY BETWEEN
	;

expr_pair:
	expr ',' expr
	| '(' expr_pair ')'
	;

place:
	/* line at A left == line (at A) left */
	label							%prec CHOP
	| label corner
	| corner label
	| corner OF label
	| HERE
	;

label:
	LABEL
	| nth_primitive
	| label '.' LABEL
	;

ordinal:
	ORDINAL
	| '`' any_expr TH
	;

optional_ordinal_last:
	LAST
	| ordinal LAST
	;

nth_primitive:
	ordinal object_type
	| optional_ordinal_last object_type
	;

object_type:
	BOX
	| CIRCLE
	| ELLIPSE
	| ARC
	| LINE
	| ARROW
	| SPLINE
	| '[' ']'
	| TEXT
	;

label_path:
	'.' LABEL
	| label_path '.' LABEL
	;

relative_path:
	corner							%prec CHOP
	/* give this a lower precedence than LEFT and RIGHT so that
	   [A: box] with .A left == [A: box] with (.A left) */
	| label_path						%prec TEXT
	| label_path corner
	;

path:
	relative_path
	| '(' relative_path ',' relative_path ')'
		{}
	/* The rest of these rules are a compatibility sop. */
	| ORDINAL LAST object_type relative_path
	| LAST object_type relative_path
	| ORDINAL object_type relative_path
	| LABEL relative_path
	;

corner:
	DOT_N
	| DOT_E
	| DOT_W
	| DOT_S
	| DOT_NE
	| DOT_SE
	| DOT_NW
	| DOT_SW
	| DOT_C
	| DOT_START
	| DOT_END
	| TOP
	| BOTTOM
	| LEFT
	| RIGHT
	| UPPER LEFT
	| LOWER LEFT
	| UPPER RIGHT
	| LOWER RIGHT
	| LEFT_CORNER
	| RIGHT_CORNER
	| UPPER LEFT_CORNER
	| LOWER LEFT_CORNER
	| UPPER RIGHT_CORNER
	| LOWER RIGHT_CORNER
	| NORTH
	| SOUTH
	| EAST
	| WEST
	| CENTER
	| START
	| END
	;

expr:
	VARIABLE
	| NUMBER
	| place DOT_X
	| place DOT_Y
	| place DOT_HT
	| place DOT_WID
	| place DOT_RAD
	| expr '+' expr
	| expr '-' expr
	| expr '*' expr
	| expr '/' expr
	| expr '%' expr
	| expr '^' expr
	| '-' expr						%prec '!'
	| '(' any_expr ')'
	| SIN '(' any_expr ')'
	| COS '(' any_expr ')'
	| ATAN2 '(' any_expr ',' any_expr ')'
	| LOG '(' any_expr ')'
	| EXP '(' any_expr ')'
	| SQRT '(' any_expr ')'
	| K_MAX '(' any_expr ',' any_expr ')'
	| K_MIN '(' any_expr ',' any_expr ')'
	| INT '(' any_expr ')'
	| RAND '(' any_expr ')'
	| RAND '(' ')'
	| SRAND '(' any_expr ')'
	| expr '<' expr
	| expr LESSEQUAL expr
	| expr '>' expr
	| expr GREATEREQUAL expr
	| expr EQUALEQUAL expr
	| expr NOTEQUAL expr
	| expr ANDAND expr
	| expr OROR expr
	| '!' expr
	;


%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    VARIABLE, '=', LABEL, LEFT, DOT_X, 0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

{ set +x
$as_echo "$at_srcdir/existing.at:1401: bison --report=all --defines -o input.c input.y"
at_fn_check_prepare_trace "existing.at:1401"
( $at_check_trace; bison --report=all --defines -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:471.11-48: warning: rule useless in parser due to conflicts: path: ORDINAL LAST object_type relative_path
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401: sed -n 's/^state //p' input.output | tail -1"
at_fn_check_prepare_notrace 'a shell pipeline' "existing.at:1401"
( $at_check_trace; sed -n 's/^state //p' input.output | tail -1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "4833
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }




{ set +x
$as_echo "$at_srcdir/existing.at:1401: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "existing.at:1401"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/existing.at:1401:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "existing.at:1401"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/existing.at:1401"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_225
#AT_START_226
at_fn_group_banner 226 'regression.at:26' \
  "Trivial grammars" "                               " 17
at_xfail=no
(
  $as_echo "226. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
void yyerror (char const *);
int yylex (void);
#define YYSTYPE int *
%}

%error-verbose

%%

program: 'x';
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:42: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:42"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:42"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:42: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "regression.at:42"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:42"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:42: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:42"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:42"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:42: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:42"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:42"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:42: bison -o input.c input.y"
at_fn_check_prepare_trace "regression.at:42"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:42"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:43: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c" "regression.at:43"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:43"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:44: \$CC \$CFLAGS \$CPPFLAGS -o input.o -DYYDEBUG -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o input.o -DYYDEBUG -c input.c" "regression.at:44"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o input.o -DYYDEBUG -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:44"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_226
#AT_START_227
at_fn_group_banner 227 'regression.at:54' \
  "YYSTYPE typedef" "                                " 17
at_xfail=no
(
  $as_echo "227. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
void yyerror (char const *);
int yylex (void);
typedef union { char const *val; } YYSTYPE;
%}

%type <val> program

%%

program: { $$ = ""; };
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:70: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:70"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:70: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "regression.at:70"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:70: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:70"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:70: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:70"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:70: bison -o input.c input.y"
at_fn_check_prepare_trace "regression.at:70"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:70"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:71: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c" "regression.at:71"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:71"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_227
#AT_START_228
at_fn_group_banner 228 'regression.at:82' \
  "Early token definitions with --yacc" "            " 17
at_xfail=no
(
  $as_echo "228. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Found in GCJ: they expect the tokens to be defined before the user
# prologue, so that they can use the token definitions in it.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
void yyerror (const char *s);
int yylex (void);
%}

%union
{
  int val;
};
%{
#ifndef MY_TOKEN
# error "MY_TOKEN not defined."
#endif
%}
%token MY_TOKEN
%%
exp: MY_TOKEN;
%%
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:108: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -y -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:108"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -y -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:108"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:108: bison --xml=xml-tests/test.xml -y -o input.c input.y"
at_fn_check_prepare_trace "regression.at:108"
( $at_check_trace; bison --xml=xml-tests/test.xml -y -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:108"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:108: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:108"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:108"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:108: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:108"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:108"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:108: bison -y -o input.c input.y"
at_fn_check_prepare_trace "regression.at:108"
( $at_check_trace; bison -y -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:108"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:109: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c" "regression.at:109"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:109"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_228
#AT_START_229
at_fn_group_banner 229 'regression.at:120' \
  "Early token definitions without --yacc" "         " 17
at_xfail=no
(
  $as_echo "229. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Found in GCJ: they expect the tokens to be defined before the user
# prologue, so that they can use the token definitions in it.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <stdio.h>
void yyerror (const char *s);
int yylex (void);
void print_my_token (void);
%}

%union
{
  int val;
};
%{
void
print_my_token (void)
{
  enum yytokentype my_token = MY_TOKEN;
  printf ("%d\n", my_token);
}
%}
%token MY_TOKEN
%%
exp: MY_TOKEN;
%%
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:151: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:151"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:151"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:151: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "regression.at:151"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:151"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:151: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:151"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:151"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:151: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:151"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:151"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:151: bison -o input.c input.y"
at_fn_check_prepare_trace "regression.at:151"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:151"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:152: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c" "regression.at:152"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:152"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_229
#AT_START_230
at_fn_group_banner 230 'regression.at:163' \
  "Braces parsing" "                                 " 17
at_xfail=no
(
  $as_echo "230. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
/* Bison used to swallow the character after `}'. */

%%
exp: { tests = {{{{{{{{{{}}}}}}}}}}; };
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:173: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:173"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:173: bison --xml=xml-tests/test.xml -v -o input.c input.y"
at_fn_check_prepare_trace "regression.at:173"
( $at_check_trace; bison --xml=xml-tests/test.xml -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:173: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:173"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:173: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:173"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:173: bison -v -o input.c input.y"
at_fn_check_prepare_trace "regression.at:173"
( $at_check_trace; bison -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:175: grep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c"
at_fn_check_prepare_trace "regression.at:175"
( $at_check_trace; grep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:175"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_230
#AT_START_231
at_fn_group_banner 231 'regression.at:185' \
  "Duplicate string" "                               " 17
at_xfail=no
(
  $as_echo "231. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
/* `Bison -v' used to dump core when two tokens are defined with the same
   string, as LE and GE below. */

%token NUM
%token LE "<="
%token GE "<="

%%
exp: '(' exp ')' | NUM ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:200: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:200"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:200: bison --xml=xml-tests/test.xml -v -o input.c input.y"
at_fn_check_prepare_trace "regression.at:200"
( $at_check_trace; bison --xml=xml-tests/test.xml -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:200"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:200"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:200: bison -v -o input.c input.y"
at_fn_check_prepare_trace "regression.at:200"
( $at_check_trace; bison -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:6.8-14: warning: symbol \`\"<=\"' used more than once as a literal string
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_231
#AT_START_232
at_fn_group_banner 232 'regression.at:211' \
  "Rule Line Numbers" "                              " 17
at_xfail=no
(
  $as_echo "232. $at_setup_line: testing $at_desc ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%%
expr:
'a'

{

}

'b'

{

}

|


{


}

'c'

{

};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:245: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c -v input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:245"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c -v input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:245"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:245: bison --xml=xml-tests/test.xml -o input.c -v input.y"
at_fn_check_prepare_trace "regression.at:245"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c -v input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:245"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:245: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:245"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:245"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:245: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:245"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:245"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:245: bison -o input.c -v input.y"
at_fn_check_prepare_trace "regression.at:245"
( $at_check_trace; bison -o input.c -v input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:245"
$at_failed && at_fn_log_failure
$at_traceon; }


# Check the contents of the report.
{ set +x
$as_echo "$at_srcdir/regression.at:248: cat input.output"
at_fn_check_prepare_trace "regression.at:248"
( $at_check_trace; cat input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Grammar

    0 \$accept: expr \$end

    1 \$@1: /* empty */

    2 expr: 'a' \$@1 'b'

    3 \$@2: /* empty */

    4 expr: \$@2 'c'


Terminals, with rules where they appear

\$end (0) 0
'a' (97) 2
'b' (98) 2
'c' (99) 4
error (256)


Nonterminals, with rules where they appear

\$accept (6)
    on left: 0
expr (7)
    on left: 2 4, on right: 0
\$@1 (8)
    on left: 1, on right: 2
\$@2 (9)
    on left: 3, on right: 4


state 0

    0 \$accept: . expr \$end

    'a'  shift, and go to state 1

    \$default  reduce using rule 3 (\$@2)

    expr  go to state 2
    \$@2   go to state 3


state 1

    2 expr: 'a' . \$@1 'b'

    \$default  reduce using rule 1 (\$@1)

    \$@1  go to state 4


state 2

    0 \$accept: expr . \$end

    \$end  shift, and go to state 5


state 3

    4 expr: \$@2 . 'c'

    'c'  shift, and go to state 6


state 4

    2 expr: 'a' \$@1 . 'b'

    'b'  shift, and go to state 7


state 5

    0 \$accept: expr \$end .

    \$default  accept


state 6

    4 expr: \$@2 'c' .

    \$default  reduce using rule 4 (expr)


state 7

    2 expr: 'a' \$@1 'b' .

    \$default  reduce using rule 2 (expr)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:248"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_232
#AT_START_233
at_fn_group_banner 233 'regression.at:355' \
  "Mixing %token styles" "                           " 17
at_xfail=no
(
  $as_echo "233. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Taken from the documentation.
cat >input.y <<'_ATEOF'
%token  <operator>  OR      "||"
%token  <operator>  LE 134  "<="
%left  OR  "<="
%%
exp: ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:367: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:367"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:367"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:367: bison --xml=xml-tests/test.xml -v -o input.c input.y"
at_fn_check_prepare_trace "regression.at:367"
( $at_check_trace; bison --xml=xml-tests/test.xml -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:367"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:367: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:367"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:367"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:367: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:367"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:367"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:367: bison -v -o input.c input.y"
at_fn_check_prepare_trace "regression.at:367"
( $at_check_trace; bison -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:367"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_233
#AT_START_234
at_fn_group_banner 234 'regression.at:378' \
  "Invalid inputs" "                                 " 17
at_xfail=no
(
  $as_echo "234. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%%
?
default: 'a' }
%&
%a-does-not-exist
%-
%{
_ATEOF



{ set +x
$as_echo "$at_srcdir/regression.at:390: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "regression.at:390"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:2.1: invalid character: \`?'
input.y:3.14: invalid character: \`}'
input.y:4.1: invalid character: \`%'
input.y:4.2: invalid character: \`&'
input.y:5.1-17: invalid directive: \`%a-does-not-exist'
input.y:6.1-2: invalid directive: \`%-'
input.y:7.1-8.0: missing \`%}' at end of file
input.y:7.1-8.0: syntax error, unexpected %{...%}
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:390"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_234
#AT_START_235
at_fn_group_banner 235 'regression.at:404' \
  "Invalid inputs with {}" "                         " 17
at_xfail=no
(
  $as_echo "235. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'

%destructor
%initial-action
%lex-param
%parse-param
%printer
%union
_ATEOF



{ set +x
$as_echo "$at_srcdir/regression.at:416: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "regression.at:416"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:3.1-15: syntax error, unexpected %initial-action, expecting {...}
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:416"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_235
#AT_START_236
at_fn_group_banner 236 'regression.at:429' \
  "Token definitions" "                              " 17
at_xfail=no
(
  $as_echo "236. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison managed, when fed with `%token 'f' "f"' to #define 'f'!
cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <stdlib.h>
#include <stdio.h>
void yyerror (const char *s);
int yylex (void);
%}
%error-verbose
%token MYEOF 0 "end of file"
%token 'a' "a"
%token B_TOKEN "b"
%token C_TOKEN 'c'
%token 'd' D_TOKEN
%token SPECIAL "\\\'\?\"\a\b\f\n\r\t\v\001\201\x001\x000081??!"
%token SPECIAL "\\\'\?\"\a\b\f\n\r\t\v\001\201\x001\x000081??!"
%%
exp: "a" "\\\'\?\"\a\b\f\n\r\t\v\001\201\x001\x000081??!";
%%
void
yyerror (char const *s)
{
  fprintf (stderr, "%s\n", s);
}

int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return SPECIAL;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# Checking the warning message guarantees that the trigraph "??!" isn't
# unnecessarily escaped here even though it would need to be if encoded in a
# C-string literal.  Also notice that unnecessary escaping, such as "\?", from
# the user specification is eliminated.
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:476: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:476"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:476"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:476: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "regression.at:476"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:476"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:476: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:476"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:476"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:476: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:476"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:476"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:476: bison -o input.c input.y"
at_fn_check_prepare_trace "regression.at:476"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:22.8-14: warning: symbol SPECIAL redeclared
input.y:22.8-63: warning: symbol \`\"\\\\'?\\\"\\a\\b\\f\\n\\r\\t\\v\\001\\201\\001\\201??!\"' used more than once as a literal string
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:476"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:480: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "regression.at:480"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:480"
$at_failed && at_fn_log_failure
$at_traceon; }


# Checking the error message here guarantees that yytname, which does contain
# C-string literals, does have the trigraph escaped correctly.  Thus, the
# symbol name reported by the parser is exactly the same as that reported by
# Bison itself.
cat >experr <<'_ATEOF'
syntax error, unexpected "\\'?\"\a\b\f\n\r\t\v\001\201\001\201??!", expecting a
_ATEOF

{ set +x
$as_echo "$at_srcdir/regression.at:489:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "regression.at:489"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
$at_diff experr "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:489"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_236
#AT_START_237
at_fn_group_banner 237 'regression.at:499' \
  "Characters Escapes" "                             " 17
at_xfail=no
(
  $as_echo "237. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp:
  '\'' "\'"
| '\"' "\""
| '"'  "'"
;
_ATEOF


# Pacify font-lock-mode: "

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:515: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:515"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:515"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:515: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "regression.at:515"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:515"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:515: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:515"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:515"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:515: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:515"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:515"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:515: bison -o input.c input.y"
at_fn_check_prepare_trace "regression.at:515"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:515"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:516: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c" "regression.at:516"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:516"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_237
#AT_START_238
at_fn_group_banner 238 'regression.at:530' \
  "Web2c Report" "                                   " 17
at_xfail=no
(
  $as_echo "238. $at_setup_line: testing $at_desc ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%token	undef_id_tok const_id_tok

%start CONST_DEC_PART

%%
CONST_DEC_PART:
         CONST_DEC_LIST
        ;

CONST_DEC_LIST:
	  CONST_DEC
        | CONST_DEC_LIST CONST_DEC
        ;

CONST_DEC:
	  { } undef_id_tok '=' const_id_tok ';'
        ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:555: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:555"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:555"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:555: bison --xml=xml-tests/test.xml -v input.y"
at_fn_check_prepare_trace "regression.at:555"
( $at_check_trace; bison --xml=xml-tests/test.xml -v input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:555"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:555: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:555"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:555"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:555: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:555"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:555"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:555: bison -v input.y"
at_fn_check_prepare_trace "regression.at:555"
( $at_check_trace; bison -v input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:555"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:556: cat input.output"
at_fn_check_prepare_trace "regression.at:556"
( $at_check_trace; cat input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Grammar

    0 \$accept: CONST_DEC_PART \$end

    1 CONST_DEC_PART: CONST_DEC_LIST

    2 CONST_DEC_LIST: CONST_DEC
    3               | CONST_DEC_LIST CONST_DEC

    4 \$@1: /* empty */

    5 CONST_DEC: \$@1 undef_id_tok '=' const_id_tok ';'


Terminals, with rules where they appear

\$end (0) 0
';' (59) 5
'=' (61) 5
error (256)
undef_id_tok (258) 5
const_id_tok (259) 5


Nonterminals, with rules where they appear

\$accept (7)
    on left: 0
CONST_DEC_PART (8)
    on left: 1, on right: 0
CONST_DEC_LIST (9)
    on left: 2 3, on right: 1 3
CONST_DEC (10)
    on left: 5, on right: 2 3
\$@1 (11)
    on left: 4, on right: 5


state 0

    0 \$accept: . CONST_DEC_PART \$end

    \$default  reduce using rule 4 (\$@1)

    CONST_DEC_PART  go to state 1
    CONST_DEC_LIST  go to state 2
    CONST_DEC       go to state 3
    \$@1             go to state 4


state 1

    0 \$accept: CONST_DEC_PART . \$end

    \$end  shift, and go to state 5


state 2

    1 CONST_DEC_PART: CONST_DEC_LIST .
    3 CONST_DEC_LIST: CONST_DEC_LIST . CONST_DEC

    undef_id_tok  reduce using rule 4 (\$@1)
    \$default      reduce using rule 1 (CONST_DEC_PART)

    CONST_DEC  go to state 6
    \$@1        go to state 4


state 3

    2 CONST_DEC_LIST: CONST_DEC .

    \$default  reduce using rule 2 (CONST_DEC_LIST)


state 4

    5 CONST_DEC: \$@1 . undef_id_tok '=' const_id_tok ';'

    undef_id_tok  shift, and go to state 7


state 5

    0 \$accept: CONST_DEC_PART \$end .

    \$default  accept


state 6

    3 CONST_DEC_LIST: CONST_DEC_LIST CONST_DEC .

    \$default  reduce using rule 3 (CONST_DEC_LIST)


state 7

    5 CONST_DEC: \$@1 undef_id_tok . '=' const_id_tok ';'

    '='  shift, and go to state 8


state 8

    5 CONST_DEC: \$@1 undef_id_tok '=' . const_id_tok ';'

    const_id_tok  shift, and go to state 9


state 9

    5 CONST_DEC: \$@1 undef_id_tok '=' const_id_tok . ';'

    ';'  shift, and go to state 10


state 10

    5 CONST_DEC: \$@1 undef_id_tok '=' const_id_tok ';' .

    \$default  reduce using rule 5 (CONST_DEC)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:556"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_238
#AT_START_239
at_fn_group_banner 239 'regression.at:707' \
  "Web2c Actions" "                                  " 17
at_xfail=no
(
  $as_echo "239. $at_setup_line: testing $at_desc ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%%
statement:  struct_stat;
struct_stat:  /* empty. */ | if else;
if: "if" "const" "then" statement;
else: "else" statement;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:720: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:720"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:720: bison --xml=xml-tests/test.xml -v -o input.c input.y"
at_fn_check_prepare_trace "regression.at:720"
( $at_check_trace; bison --xml=xml-tests/test.xml -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:720: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:720"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:720: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:720"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:720: bison -v -o input.c input.y"
at_fn_check_prepare_trace "regression.at:720"
( $at_check_trace; bison -v -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:720"
$at_failed && at_fn_log_failure
$at_traceon; }


# Check only the tables.
sed -n 's/  *$//;/^static const.*\[\] =/,/^}/p' input.c >tables.c

{ set +x
$as_echo "$at_srcdir/regression.at:725: cat tables.c"
at_fn_check_prepare_trace "regression.at:725"
( $at_check_trace; cat tables.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "static const yytype_uint8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6
};
static const yytype_uint8 yyrline[] =
{
       0,     2,     2,     3,     3,     4,     5
};
static const char *const yytname[] =
{
  \"\$end\", \"error\", \"\$undefined\", \"\\\"if\\\"\", \"\\\"const\\\"\", \"\\\"then\\\"\",
  \"\\\"else\\\"\", \"\$accept\", \"statement\", \"struct_stat\", \"if\", \"else\", 0
};
static const yytype_uint16 yytoknum[] =
{
       0,   256,   257,   258,   259,   260,   261
};
static const yytype_int8 yypact[] =
{
      -2,    -1,     4,    -8,     0,     2,    -8,    -2,    -8,    -2,
      -8,    -8
};
static const yytype_uint8 yydefact[] =
{
       3,     0,     0,     2,     0,     0,     1,     3,     4,     3,
       6,     5
};
static const yytype_int8 yypgoto[] =
{
      -8,    -7,    -8,    -8,    -8
};
static const yytype_int8 yydefgoto[] =
{
      -1,     2,     3,     4,     8
};
static const yytype_uint8 yytable[] =
{
      10,     1,    11,     5,     6,     0,     7,     9
};
static const yytype_int8 yycheck[] =
{
       7,     3,     9,     4,     0,    -1,     6,     5
};
static const yytype_uint8 yystos[] =
{
       0,     3,     8,     9,    10,     4,     0,     6,    11,     5,
       8,     8
};
static const yytype_uint8 yyr1[] =
{
       0,     7,     8,     9,     9,    10,    11
};
static const yytype_uint8 yyr2[] =
{
       0,     2,     1,     0,     2,     4,     2
};
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:725"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_239
#AT_START_240
at_fn_group_banner 240 'regression.at:940' \
  "Dancer " "                                        " 17
at_xfail=no
(
  $as_echo "240. $at_setup_line: testing $at_desc ..."
  $at_traceon






# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >dancer.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (void);
#include <stdlib.h>
#include <stdio.h>
static void yyerror (const char *);
%}

%token ARROW INVALID NUMBER STRING DATA
%defines
%verbose
%error-verbose
/* Grammar follows */
%%
line: header body
   ;

header: '<' from ARROW to '>' type ':'
   | '<' ARROW to '>' type ':'
   | ARROW to type ':'
   | type ':'
   | '<' '>'
   ;

from: DATA
   | STRING
   | INVALID
   ;

to: DATA
   | STRING
   | INVALID
   ;

type: DATA
   | STRING
   | INVALID
   ;

body: /* empty */
   | body member
   ;

member: STRING
   | DATA
   | '+' NUMBER
   | '-' NUMBER
   | NUMBER
   | INVALID
   ;
%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int const tokens[] =
    {
      ':', -1
    };
  static size_t toknum;

  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:940: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:940"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:940: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:940"
( $at_check_trace; bison --xml=xml-tests/test.xml -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:940: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:940"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:940: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:940"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:940: bison -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:940"
( $at_check_trace; bison -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:940: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:940"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:940: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:940"
( $at_check_trace; bison --xml=xml-tests/test.xml -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:940: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:940"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:940: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:940"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:940: bison -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:940"
( $at_check_trace; bison -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/regression.at:940: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o dancer dancer.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS" "regression.at:940"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:940:  \$PREPARSER ./dancer"
at_fn_check_prepare_dynamic " $PREPARSER ./dancer" "regression.at:940"
( $at_check_trace;  $PREPARSER ./dancer
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected ':'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:940"
$at_failed && at_fn_log_failure
$at_traceon; }





























  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_240
#AT_START_241
at_fn_group_banner 241 'regression.at:941' \
  "Dancer %glr-parser" "                             " 17
at_xfail=no
(
  $as_echo "241. $at_setup_line: testing $at_desc ..."
  $at_traceon






# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >dancer.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (void);
#include <stdlib.h>
#include <stdio.h>
static void yyerror (const char *);
%}
%glr-parser
%token ARROW INVALID NUMBER STRING DATA
%defines
%verbose
%error-verbose
/* Grammar follows */
%%
line: header body
   ;

header: '<' from ARROW to '>' type ':'
   | '<' ARROW to '>' type ':'
   | ARROW to type ':'
   | type ':'
   | '<' '>'
   ;

from: DATA
   | STRING
   | INVALID
   ;

to: DATA
   | STRING
   | INVALID
   ;

type: DATA
   | STRING
   | INVALID
   ;

body: /* empty */
   | body member
   ;

member: STRING
   | DATA
   | '+' NUMBER
   | '-' NUMBER
   | NUMBER
   | INVALID
   ;
%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int const tokens[] =
    {
      ':', -1
    };
  static size_t toknum;

  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:941: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:941"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:941: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:941"
( $at_check_trace; bison --xml=xml-tests/test.xml -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:941: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:941"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:941: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:941"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:941: bison -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:941"
( $at_check_trace; bison -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:941: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:941"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:941: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:941"
( $at_check_trace; bison --xml=xml-tests/test.xml -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:941: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:941"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:941: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:941"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:941: bison -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:941"
( $at_check_trace; bison -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/regression.at:941: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o dancer dancer.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS" "regression.at:941"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:941:  \$PREPARSER ./dancer"
at_fn_check_prepare_dynamic " $PREPARSER ./dancer" "regression.at:941"
( $at_check_trace;  $PREPARSER ./dancer
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected ':'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:941"
$at_failed && at_fn_log_failure
$at_traceon; }





























  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_241
#AT_START_242
at_fn_group_banner 242 'regression.at:942' \
  "Dancer %skeleton \"lalr1.cc\"" "                    " 17
at_xfail=no
(
  $as_echo "242. $at_setup_line: testing $at_desc ..."
  $at_traceon






# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >dancer.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (int *);
#include <cstdlib>
%}
%skeleton "lalr1.cc"
%token ARROW INVALID NUMBER STRING DATA
%defines
%verbose
%error-verbose
/* Grammar follows */
%%
line: header body
   ;

header: '<' from ARROW to '>' type ':'
   | '<' ARROW to '>' type ':'
   | ARROW to type ':'
   | type ':'
   | '<' '>'
   ;

from: DATA
   | STRING
   | INVALID
   ;

to: DATA
   | STRING
   | INVALID
   ;

type: DATA
   | STRING
   | INVALID
   ;

body: /* empty */
   | body member
   ;

member: STRING
   | DATA
   | '+' NUMBER
   | '-' NUMBER
   | NUMBER
   | INVALID
   ;
%%
/* A C++ error reporting function. */
void
yy::parser::error (const std::string& m)
{
  std::cerr << m << std::endl;
}

int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (YYDEBUG);
#endif
  return parser.parse ();
}


static int
yylex (int *lval)
{
  static int const tokens[] =
    {
      ':', -1
    };
  static size_t toknum;
  *lval = 0; /* Pacify GCC.  */
  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:942: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:942"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:942: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:942"
( $at_check_trace; bison --xml=xml-tests/test.xml -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:942: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:942"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:942: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:942"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:942: bison -o dancer.c dancer.y"
at_fn_check_prepare_trace "regression.at:942"
( $at_check_trace; bison -o dancer.c dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:942: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.cc dancer.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:942"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.cc dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:942: bison --xml=xml-tests/test.xml -o dancer.cc dancer.y"
at_fn_check_prepare_trace "regression.at:942"
( $at_check_trace; bison --xml=xml-tests/test.xml -o dancer.cc dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:942: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:942"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:942: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:942"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:942: bison -o dancer.cc dancer.y"
at_fn_check_prepare_trace "regression.at:942"
( $at_check_trace; bison -o dancer.cc dancer.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:942: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "regression.at:942"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:942: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o dancer dancer.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.cc $LIBS" "regression.at:942"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:942:  \$PREPARSER ./dancer"
at_fn_check_prepare_dynamic " $PREPARSER ./dancer" "regression.at:942"
( $at_check_trace;  $PREPARSER ./dancer
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected ':'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:942"
$at_failed && at_fn_log_failure
$at_traceon; }





























  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_242
#AT_START_243
at_fn_group_banner 243 'regression.at:1036' \
  "Expecting two tokens " "                          " 17
at_xfail=no
(
  $as_echo "243. $at_setup_line: testing $at_desc ..."
  $at_traceon






# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >expect2.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (void);
#include <stdio.h>
#include <stdlib.h>
static void yyerror (const char *);
%}

%defines
%error-verbose
%token A 1000
%token B

%%
program: /* empty */
 | program e ';'
 | program error ';';

e: e '+' t | t;
t: A | B;

%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int const tokens[] =
    {
      1000, '+', '+', -1
    };
  static size_t toknum;

  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1036: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1036"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1036: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1036"
( $at_check_trace; bison --xml=xml-tests/test.xml -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1036: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1036"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1036: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1036"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1036: bison -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1036"
( $at_check_trace; bison -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1036: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1036"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1036: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1036"
( $at_check_trace; bison --xml=xml-tests/test.xml -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1036: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1036"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1036: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1036"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1036: bison -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1036"
( $at_check_trace; bison -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/regression.at:1036: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o expect2 expect2.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS" "regression.at:1036"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:1036:  \$PREPARSER ./expect2"
at_fn_check_prepare_dynamic " $PREPARSER ./expect2" "regression.at:1036"
( $at_check_trace;  $PREPARSER ./expect2
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '+', expecting A or B
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:1036"
$at_failed && at_fn_log_failure
$at_traceon; }





























  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_243
#AT_START_244
at_fn_group_banner 244 'regression.at:1037' \
  "Expecting two tokens %glr-parser" "               " 17
at_xfail=no
(
  $as_echo "244. $at_setup_line: testing $at_desc ..."
  $at_traceon






# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >expect2.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (void);
#include <stdio.h>
#include <stdlib.h>
static void yyerror (const char *);
%}
%glr-parser
%defines
%error-verbose
%token A 1000
%token B

%%
program: /* empty */
 | program e ';'
 | program error ';';

e: e '+' t | t;
t: A | B;

%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int const tokens[] =
    {
      1000, '+', '+', -1
    };
  static size_t toknum;

  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1037: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1037"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1037: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1037"
( $at_check_trace; bison --xml=xml-tests/test.xml -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1037: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1037"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1037: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1037"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1037: bison -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1037"
( $at_check_trace; bison -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1037: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1037"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1037: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1037"
( $at_check_trace; bison --xml=xml-tests/test.xml -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1037: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1037"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1037: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1037"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1037: bison -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1037"
( $at_check_trace; bison -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }

   { set +x
$as_echo "$at_srcdir/regression.at:1037: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o expect2 expect2.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS" "regression.at:1037"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:1037:  \$PREPARSER ./expect2"
at_fn_check_prepare_dynamic " $PREPARSER ./expect2" "regression.at:1037"
( $at_check_trace;  $PREPARSER ./expect2
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '+', expecting A or B
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:1037"
$at_failed && at_fn_log_failure
$at_traceon; }





























  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_244
#AT_START_245
at_fn_group_banner 245 'regression.at:1038' \
  "Expecting two tokens %skeleton \"lalr1.cc\"" "      " 17
at_xfail=no
(
  $as_echo "245. $at_setup_line: testing $at_desc ..."
  $at_traceon






# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.









cat >expect2.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (int *);
#include <cstdlib>
%}
%skeleton "lalr1.cc"
%defines
%error-verbose
%token A 1000
%token B

%%
program: /* empty */
 | program e ';'
 | program error ';';

e: e '+' t | t;
t: A | B;

%%
/* A C++ error reporting function. */
void
yy::parser::error (const std::string& m)
{
  std::cerr << m << std::endl;
}

int
yyparse ()
{
  yy::parser parser;
  return parser.parse ();
}


static int
yylex (int *lval)
{
  static int const tokens[] =
    {
      1000, '+', '+', -1
    };
  static size_t toknum;
  *lval = 0; /* Pacify GCC.  */
  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1038: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1038"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1038: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1038"
( $at_check_trace; bison --xml=xml-tests/test.xml -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1038: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1038"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1038: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1038"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1038: bison -o expect2.c expect2.y"
at_fn_check_prepare_trace "regression.at:1038"
( $at_check_trace; bison -o expect2.c expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1038: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.cc expect2.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1038"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.cc expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1038: bison --xml=xml-tests/test.xml -o expect2.cc expect2.y"
at_fn_check_prepare_trace "regression.at:1038"
( $at_check_trace; bison --xml=xml-tests/test.xml -o expect2.cc expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1038: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1038"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1038: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1038"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1038: bison -o expect2.cc expect2.y"
at_fn_check_prepare_trace "regression.at:1038"
( $at_check_trace; bison -o expect2.cc expect2.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:1038: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "regression.at:1038"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:1038: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o expect2 expect2.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.cc $LIBS" "regression.at:1038"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:1038:  \$PREPARSER ./expect2"
at_fn_check_prepare_dynamic " $PREPARSER ./expect2" "regression.at:1038"
( $at_check_trace;  $PREPARSER ./expect2
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '+', expecting A or B
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:1038"
$at_failed && at_fn_log_failure
$at_traceon; }





























  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_245
#AT_START_246
at_fn_group_banner 246 'regression.at:1046' \
  "Braced code in declaration in rules section" "    " 17
at_xfail=no
(
  $as_echo "246. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison once mistook braced code in a declaration in the rules section to be a
# rule action.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <stdio.h>
static void yyerror (char const *msg);
static int yylex (void);
%}

%error-verbose

%%

start:
  {
    printf ("Bison would once convert this action to a midrule because of the"
	    " subsequent braced code.\n");
  }
  ;

%destructor { fprintf (stderr, "DESTRUCTOR\n"); } 'a';
%printer { fprintf (yyoutput, "PRINTER"); } 'a';

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  return 'a';
}

int
main (void)
{
  yydebug = 1;
  return !yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1094: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -t -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1094"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -t -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1094"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1094: bison --xml=xml-tests/test.xml -t -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1094"
( $at_check_trace; bison --xml=xml-tests/test.xml -t -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1094"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1094: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1094"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1094"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1094: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1094"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1094"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1094: bison -t -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1094"
( $at_check_trace; bison -t -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1094"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:1095: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "regression.at:1095"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1095"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:1096:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "regression.at:1096"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reducing stack by rule 1 (line 20):
-> \$\$ = nterm start ()
Stack now 0
Entering state 1
Reading a token: Next token is token 'a' (PRINTER)
syntax error, unexpected 'a', expecting \$end
Error: popping nterm start ()
Stack now 0
Cleanup: discarding lookahead token 'a' (PRINTER)
DESTRUCTOR
Stack now 0
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Bison would once convert this action to a midrule because of the subsequent braced code.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1096"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_246
#AT_START_247
at_fn_group_banner 247 'regression.at:1122' \
  "String alias declared after use" "                " 17
at_xfail=no
(
  $as_echo "247. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison once incorrectly asserted that the symbol number for either a token or
# its alias was the highest symbol number so far at the point of the alias
# declaration.  That was true unless the declaration appeared after their first
# uses and other tokens appeared in between.

cat >input.y <<'_ATEOF'
%%
start: 'a' "A" 'b';
%token 'a' "A";
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1135: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -t -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1135"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -t -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1135"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1135: bison --xml=xml-tests/test.xml -t -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1135"
( $at_check_trace; bison --xml=xml-tests/test.xml -t -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1135"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1135: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1135"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1135"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1135: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1135"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1135"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1135: bison -t -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1135"
( $at_check_trace; bison -t -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1135"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_247
#AT_START_248
at_fn_group_banner 248 'regression.at:1145' \
  "Extra lookahead sets in report" "                 " 17
at_xfail=no
(
  $as_echo "248. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Bison prints each reduction's lookahead set only next to the associated
# state's one item that (1) is associated with the same rule as the reduction
# and (2) has its dot at the end of its RHS.  Previously, Bison also
# erroneously printed the lookahead set next to all of the state's other items
# associated with the same rule.  This bug affected only the `.output' file and
# not the generated parser source code.

cat >input.y <<'_ATEOF'
%%
start: a | 'a' a 'a' ;
a: 'a' ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1160: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1160"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1160"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1160: bison --xml=xml-tests/test.xml --report=all input.y"
at_fn_check_prepare_trace "regression.at:1160"
( $at_check_trace; bison --xml=xml-tests/test.xml --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1160"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1160: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1160"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1160"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1160: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1160"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1160"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1160: bison --report=all input.y"
at_fn_check_prepare_trace "regression.at:1160"
( $at_check_trace; bison --report=all input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1160"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:1161: sed -n '/^state 1\$/,/^state 2\$/p' input.output"
at_fn_check_prepare_dynamic "sed -n '/^state 1$/,/^state 2$/p' input.output" "regression.at:1161"
( $at_check_trace; sed -n '/^state 1$/,/^state 2$/p' input.output
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 1

    2 start: 'a' . a 'a'
    3 a: . 'a'
    3  | 'a' .  [\$end]

    'a'  shift, and go to state 4

    \$default  reduce using rule 3 (a)

    a  go to state 5


state 2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1161"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_248
#AT_START_249
at_fn_group_banner 249 'regression.at:1186' \
  "Token number in precedence declaration" "         " 17
at_xfail=no
(
  $as_echo "249. $at_setup_line: testing $at_desc ..."
  $at_traceon


# POSIX says token numbers can be declared in %left, %right, and %nonassoc, but
# we lost this in Bison 1.50.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
  #include <stdio.h>
  void yyerror (char const *);
  int yylex (void);
%}

%error-verbose
%left TK1 1 TK2 2 "tok alias" 3

%%

start: TK1 sr_conflict "tok alias" ;

sr_conflict:
  TK2
  | TK2 "tok alias"
  ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  static int const input[] = { 1, 2, 3, 0 };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1233: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1233"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1233"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1233: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1233"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1233"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1233: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1233"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1233"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1233: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1233"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1233"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1233: bison -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1233"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:24.5-19: warning: rule useless in parser due to conflicts: sr_conflict: TK2 \"tok alias\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1233"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:1236: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "regression.at:1236"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1236"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:1237:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "regression.at:1237"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1237"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_249
#AT_START_250
at_fn_group_banner 250 'regression.at:1250' \
  "parse-gram.y: LALR = IELR" "                      " 17
at_xfail=no
(
  $as_echo "250. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Avoid tests/bison's dark magic by processing a local copy of the
# grammar.  Avoid differences in synclines by telling bison that the
# output files have the same name.
cp $abs_top_srcdir/src/parse-gram.y input.y
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1256: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c -Dlr.type=lalr input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1256"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c -Dlr.type=lalr input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1256"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1256: bison --xml=xml-tests/test.xml -o input.c -Dlr.type=lalr input.y"
at_fn_check_prepare_trace "regression.at:1256"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c -Dlr.type=lalr input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1256"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1256: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1256"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1256"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1256: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1256"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1256"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1256: bison -o input.c -Dlr.type=lalr input.y"
at_fn_check_prepare_trace "regression.at:1256"
( $at_check_trace; bison -o input.c -Dlr.type=lalr input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1256"
$at_failed && at_fn_log_failure
$at_traceon; }

mv input.c lalr.c
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1258: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c -Dlr.type=ielr input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1258"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c -Dlr.type=ielr input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1258"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1258: bison --xml=xml-tests/test.xml -o input.c -Dlr.type=ielr input.y"
at_fn_check_prepare_trace "regression.at:1258"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c -Dlr.type=ielr input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1258"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1258: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1258"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1258"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1258: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1258"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1258"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1258: bison -o input.c -Dlr.type=ielr input.y"
at_fn_check_prepare_trace "regression.at:1258"
( $at_check_trace; bison -o input.c -Dlr.type=ielr input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1258"
$at_failed && at_fn_log_failure
$at_traceon; }

mv input.c ielr.c
{ set +x
$as_echo "$at_srcdir/regression.at:1260: diff -u lalr.c ielr.c"
at_fn_check_prepare_trace "regression.at:1260"
( $at_check_trace; diff -u lalr.c ielr.c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1260"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_250
#AT_START_251
at_fn_group_banner 251 'regression.at:1270' \
  "parse.error=verbose and YYSTACK_USE_ALLOCA" "     " 17
at_xfail=no
(
  $as_echo "251. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  void yyerror (char const *);
  int yylex (void);
  #define YYSTACK_USE_ALLOCA 1
}

%define parse.error verbose

%%

start: check syntax_error syntax_error ;

check:
{
  if (128 < sizeof yymsgbuf)
    {
      fprintf (stderr,
               "The initial size of yymsgbuf in yyparse has increased\n"
               "since this test group was last updated.  As a result,\n"
               "this test group may no longer manage to induce a\n"
               "reallocation of the syntax error message buffer.\n"
               "This test group must be adjusted to produce a longer\n"
               "error message.\n");
      YYABORT;
    }
}
;

// Induce a syntax error message whose total length is more than
// sizeof yymsgbuf in yyparse.  Each token here is 64 bytes.
syntax_error:
  "123456789112345678921234567893123456789412345678951234567896123A"
| "123456789112345678921234567893123456789412345678951234567896123B"
| error 'a' 'b' 'c'
;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  /* Induce two syntax error messages (which requires full error
     recovery by shifting 3 tokens) in order to detect any loss of the
     reallocated buffer.  */
  static char const *input = "abc";
  return *input++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1335: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1335"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1335"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1335: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1335"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1335"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1335: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1335"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1335"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1335: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1335"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1335"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1335: bison -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1335"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1335"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:1336: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "regression.at:1336"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1336"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/regression.at:1337:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "regression.at:1337"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected 'a', expecting 123456789112345678921234567893123456789412345678951234567896123A or 123456789112345678921234567893123456789412345678951234567896123B
syntax error, unexpected \$end, expecting 123456789112345678921234567893123456789412345678951234567896123A or 123456789112345678921234567893123456789412345678951234567896123B
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/regression.at:1337"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_251
#AT_START_252
at_fn_group_banner 252 'regression.at:1358' \
  "parse.error=verbose overflow" "                   " 17
at_xfail=no
(
  $as_echo "252. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  void yyerror (char const *);
  int yylex (void);

  /* This prevents this test case from having to induce error messages
     large enough to overflow size_t.  */
  #define YYSIZE_T unsigned char

  /* Bring in malloc and set _STDLIB_H so yacc.c doesn't try to
     provide a malloc prototype using our YYSIZE_T.  */
  #include <stdlib.h>
  #ifndef _STDLIB_H
  # define _STDLIB_H 1
  #endif

  /* Max depth is usually much smaller than YYSTACK_ALLOC_MAXIMUM, and
     we don't want gcc to warn everywhere this constant would be too big
     to make sense for our YYSIZE_T.  */
  #define YYMAXDEPTH 100
}

%define parse.error verbose

%%

start: syntax_error1 check syntax_error2 ;

// Induce a syntax error message whose total length causes yymsg in
// yyparse to be reallocated to size YYSTACK_ALLOC_MAXIMUM, which
// should be 255.  Each token here is 64 bytes.
syntax_error1:
  "123456789112345678921234567893123456789412345678951234567896123A"
| "123456789112345678921234567893123456789412345678951234567896123B"
| "123456789112345678921234567893123456789412345678951234567896123C"
| error 'a' 'b' 'c'
;

check:
{
  if (yymsg_alloc != YYSTACK_ALLOC_MAXIMUM
      || YYSTACK_ALLOC_MAXIMUM != YYSIZE_MAXIMUM
      || YYSIZE_MAXIMUM != 255)
    {
      fprintf (stderr,
               "The assumptions of this test group are no longer\n"
               "valid, so it may no longer catch the error it was\n"
               "designed to catch.  Specifically, the following\n"
               "values should all be 255:\n\n");
      fprintf (stderr, "  yymsg_alloc = %d\n", yymsg_alloc);
      fprintf (stderr, "  YYSTACK_ALLOC_MAXIMUM = %d\n",
               YYSTACK_ALLOC_MAXIMUM);
      fprintf (stderr, "  YYSIZE_MAXIMUM = %d\n", YYSIZE_MAXIMUM);
      YYABORT;
    }
}
;

// Now overflow.
syntax_error2:
  "123456789112345678921234567893123456789412345678951234567896123A"
| "123456789112345678921234567893123456789412345678951234567896123B"
| "123456789112345678921234567893123456789412345678951234567896123C"
| "123456789112345678921234567893123456789412345678951234567896123D"
| "123456789112345678921234567893123456789412345678951234567896123E"
;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  /* Induce two syntax error messages (which requires full error
     recovery by shifting 3 tokens).  */
  static char const *input = "abc";
  return *input++;
}

int
main (void)
{
  /* Push parsers throw away the message buffer between tokens, so skip
     this test under maintainer-push-check.  */
  if (YYPUSH)
    return 77;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/regression.at:1456: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "regression.at:1456"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1456"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/regression.at:1456: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1456"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1456"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/regression.at:1456: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1456"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1456"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/regression.at:1456: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "regression.at:1456"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1456"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/regression.at:1456: bison -o input.c input.y"
at_fn_check_prepare_trace "regression.at:1456"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1456"
$at_failed && at_fn_log_failure
$at_traceon; }


# gcc warns about tautologies and fallacies involving comparisons for
# unsigned char.  However, it doesn't produce these same warnings for
# size_t and many other types when the warnings would seem to make just
# as much sense.  We ignore the warnings.
CFLAGS="$NO_WERROR_CFLAGS"
{ set +x
$as_echo "$at_srcdir/regression.at:1463: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "regression.at:1463"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/regression.at:1463"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/regression.at:1465:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "regression.at:1465"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected 'a', expecting 123456789112345678921234567893123456789412345678951234567896123A or 123456789112345678921234567893123456789412345678951234567896123B or 123456789112345678921234567893123456789412345678951234567896123C
syntax error
memory exhausted
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 2 $at_status "$at_srcdir/regression.at:1465"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_252
#AT_START_253
at_fn_group_banner 253 'c++.at:200' \
  "Variants " "                                      " 18
at_xfail=no
(
  $as_echo "253. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Store strings and integers in a list of strings.
cat >list.yy <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug
%skeleton "lalr1.cc"
%defines
%define variant
%locations


%code requires // code for the .hh file
{
#include <list>
#include <string>
typedef std::list<std::string> strings_type;
}

%code // code for the .cc file
{
#include <iostream>
#include <sstream>

  static
#if defined USE_LEX_SYMBOL
  yy::parser::symbol_type yylex ();
#else
  yy::parser::token_type yylex (yy::parser::semantic_type* yylval,
                                yy::parser::location_type* yylloc);
#endif

  // Printing a list of strings (for %printer).
  // Koening look up will look into std, since that's an std::list.
  namespace std
  {
    std::ostream&
    operator<<(std::ostream& o, const strings_type& s)
    {
      o << '(';
      for (strings_type::const_iterator i = s.begin(); i != s.end (); ++i)
        {
          if (i != s.begin ())
            o << ", ";
          o << *i;
        }
      return o << ')';
    }
  }

  // Conversion to string.
  template <typename T>
    inline
    std::string
    string_cast (const T& t)
  {
    std::ostringstream o;
    o << t;
    return o.str();
  }
}

%token <::std::string> TEXT;
%token <int> NUMBER;
%token END_OF_FILE 0;

%type <::std::string> item;
// Using the template type to exercize its parsing.
// Starting with :: to ensure we don't output "<::" which starts by the
// digraph for the left square bracket.
%type <::std::list<std::string>> list result;

%printer { debug_stream() << $$; }
  <int> <::std::string> <::std::list<::std::string>>;
%%

result:
  list          { std::cout << $1 << std::endl; }
;

list:
  /* nothing */ { /* Generates an empty string list */ }
| list item     { std::swap($$,$1); $$.push_back($2); }
| list error    { std::swap($$,$1); }
;

item:
  TEXT          { std::swap($$,$1); }
| NUMBER        { if ($1 == 3) YYERROR; else $$ = string_cast($1); }
;
%%

#define STAGE_MAX 5
static
#if defined USE_LEX_SYMBOL
yy::parser::symbol_type yylex()
#else
yy::parser::token_type yylex(yy::parser::semantic_type* yylval,
                             yy::parser::location_type* yylloc)
#endif
{
  typedef yy::parser::token token;
  typedef yy::parser::location_type location_type;
  static int stage = -1;
  ++stage;
  if (stage == STAGE_MAX)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_END_OF_FILE (location_type ());
#else
      *yylloc = location_type ();
      return token::END_OF_FILE;
#endif
    }
  else if (stage % 2)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_NUMBER (stage, location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build(stage);
# else
      yylval->build<int>() = stage;
# endif
      *yylloc = location_type ();
      return token::NUMBER;
#endif
    }
  else
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_TEXT (string_cast (stage), location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build (string_cast (stage));
# else
      yylval->build<std::string>() = string_cast (stage);
# endif
      *yylloc = location_type ();
      return token::TEXT;
#endif
    }
  abort();
}

void
yy::parser::error(const yy::parser::location_type&,
                  const std::string& message)
{
  std::cerr << message << std::endl;
}

int
main (void)
{
  yy::parser p;
  p.set_debug_level(!!getenv("YYDEBUG"));
  return p.parse();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:200: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o list.cc list.yy"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:200"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:200: bison --xml=xml-tests/test.xml -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:200"
( $at_check_trace; bison --xml=xml-tests/test.xml -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:200"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:200"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:200: bison -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:200"
( $at_check_trace; bison -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/c++.at:200: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:200"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:200: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o list list.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS" "c++.at:200"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:200: ./list"
at_fn_check_prepare_trace "c++.at:200"
( $at_check_trace; ./list
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "(0, 1, 2, 4)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:200"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_253
#AT_START_254
at_fn_group_banner 254 'c++.at:201' \
  "Variants %define parse.assert" "                  " 18
at_xfail=no
(
  $as_echo "254. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Store strings and integers in a list of strings.
cat >list.yy <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug
%skeleton "lalr1.cc"
%defines
%define variant
%locations
%define parse.assert

%code requires // code for the .hh file
{
#include <list>
#include <string>
typedef std::list<std::string> strings_type;
}

%code // code for the .cc file
{
#include <iostream>
#include <sstream>

  static
#if defined USE_LEX_SYMBOL
  yy::parser::symbol_type yylex ();
#else
  yy::parser::token_type yylex (yy::parser::semantic_type* yylval,
                                yy::parser::location_type* yylloc);
#endif

  // Printing a list of strings (for %printer).
  // Koening look up will look into std, since that's an std::list.
  namespace std
  {
    std::ostream&
    operator<<(std::ostream& o, const strings_type& s)
    {
      o << '(';
      for (strings_type::const_iterator i = s.begin(); i != s.end (); ++i)
        {
          if (i != s.begin ())
            o << ", ";
          o << *i;
        }
      return o << ')';
    }
  }

  // Conversion to string.
  template <typename T>
    inline
    std::string
    string_cast (const T& t)
  {
    std::ostringstream o;
    o << t;
    return o.str();
  }
}

%token <::std::string> TEXT;
%token <int> NUMBER;
%token END_OF_FILE 0;

%type <::std::string> item;
// Using the template type to exercize its parsing.
// Starting with :: to ensure we don't output "<::" which starts by the
// digraph for the left square bracket.
%type <::std::list<std::string>> list result;

%printer { debug_stream() << $$; }
  <int> <::std::string> <::std::list<::std::string>>;
%%

result:
  list          { std::cout << $1 << std::endl; }
;

list:
  /* nothing */ { /* Generates an empty string list */ }
| list item     { std::swap($$,$1); $$.push_back($2); }
| list error    { std::swap($$,$1); }
;

item:
  TEXT          { std::swap($$,$1); }
| NUMBER        { if ($1 == 3) YYERROR; else $$ = string_cast($1); }
;
%%

#define STAGE_MAX 5
static
#if defined USE_LEX_SYMBOL
yy::parser::symbol_type yylex()
#else
yy::parser::token_type yylex(yy::parser::semantic_type* yylval,
                             yy::parser::location_type* yylloc)
#endif
{
  typedef yy::parser::token token;
  typedef yy::parser::location_type location_type;
  static int stage = -1;
  ++stage;
  if (stage == STAGE_MAX)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_END_OF_FILE (location_type ());
#else
      *yylloc = location_type ();
      return token::END_OF_FILE;
#endif
    }
  else if (stage % 2)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_NUMBER (stage, location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build(stage);
# else
      yylval->build<int>() = stage;
# endif
      *yylloc = location_type ();
      return token::NUMBER;
#endif
    }
  else
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_TEXT (string_cast (stage), location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build (string_cast (stage));
# else
      yylval->build<std::string>() = string_cast (stage);
# endif
      *yylloc = location_type ();
      return token::TEXT;
#endif
    }
  abort();
}

void
yy::parser::error(const yy::parser::location_type&,
                  const std::string& message)
{
  std::cerr << message << std::endl;
}

int
main (void)
{
  yy::parser p;
  p.set_debug_level(!!getenv("YYDEBUG"));
  return p.parse();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:201: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o list.cc list.yy"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:201"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:201"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:201: bison --xml=xml-tests/test.xml -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:201"
( $at_check_trace; bison --xml=xml-tests/test.xml -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:201"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:201: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:201"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:201"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:201: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:201"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:201"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:201: bison -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:201"
( $at_check_trace; bison -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:201"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/c++.at:201: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:201"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:201"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:201: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o list list.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS" "c++.at:201"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:201"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:201: ./list"
at_fn_check_prepare_trace "c++.at:201"
( $at_check_trace; ./list
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "(0, 1, 2, 4)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:201"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_254
#AT_START_255
at_fn_group_banner 255 'c++.at:202' \
  "Variants %define parse.assert %code {\\n#define ONE_STAGE_BUILD\\n}" "" 18
at_xfail=no
(
  $as_echo "255. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Store strings and integers in a list of strings.
cat >list.yy <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug
%skeleton "lalr1.cc"
%defines
%define variant
%locations
%define parse.assert %code {
#define ONE_STAGE_BUILD
}

%code requires // code for the .hh file
{
#include <list>
#include <string>
typedef std::list<std::string> strings_type;
}

%code // code for the .cc file
{
#include <iostream>
#include <sstream>

  static
#if defined USE_LEX_SYMBOL
  yy::parser::symbol_type yylex ();
#else
  yy::parser::token_type yylex (yy::parser::semantic_type* yylval,
                                yy::parser::location_type* yylloc);
#endif

  // Printing a list of strings (for %printer).
  // Koening look up will look into std, since that's an std::list.
  namespace std
  {
    std::ostream&
    operator<<(std::ostream& o, const strings_type& s)
    {
      o << '(';
      for (strings_type::const_iterator i = s.begin(); i != s.end (); ++i)
        {
          if (i != s.begin ())
            o << ", ";
          o << *i;
        }
      return o << ')';
    }
  }

  // Conversion to string.
  template <typename T>
    inline
    std::string
    string_cast (const T& t)
  {
    std::ostringstream o;
    o << t;
    return o.str();
  }
}

%token <::std::string> TEXT;
%token <int> NUMBER;
%token END_OF_FILE 0;

%type <::std::string> item;
// Using the template type to exercize its parsing.
// Starting with :: to ensure we don't output "<::" which starts by the
// digraph for the left square bracket.
%type <::std::list<std::string>> list result;

%printer { debug_stream() << $$; }
  <int> <::std::string> <::std::list<::std::string>>;
%%

result:
  list          { std::cout << $1 << std::endl; }
;

list:
  /* nothing */ { /* Generates an empty string list */ }
| list item     { std::swap($$,$1); $$.push_back($2); }
| list error    { std::swap($$,$1); }
;

item:
  TEXT          { std::swap($$,$1); }
| NUMBER        { if ($1 == 3) YYERROR; else $$ = string_cast($1); }
;
%%

#define STAGE_MAX 5
static
#if defined USE_LEX_SYMBOL
yy::parser::symbol_type yylex()
#else
yy::parser::token_type yylex(yy::parser::semantic_type* yylval,
                             yy::parser::location_type* yylloc)
#endif
{
  typedef yy::parser::token token;
  typedef yy::parser::location_type location_type;
  static int stage = -1;
  ++stage;
  if (stage == STAGE_MAX)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_END_OF_FILE (location_type ());
#else
      *yylloc = location_type ();
      return token::END_OF_FILE;
#endif
    }
  else if (stage % 2)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_NUMBER (stage, location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build(stage);
# else
      yylval->build<int>() = stage;
# endif
      *yylloc = location_type ();
      return token::NUMBER;
#endif
    }
  else
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_TEXT (string_cast (stage), location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build (string_cast (stage));
# else
      yylval->build<std::string>() = string_cast (stage);
# endif
      *yylloc = location_type ();
      return token::TEXT;
#endif
    }
  abort();
}

void
yy::parser::error(const yy::parser::location_type&,
                  const std::string& message)
{
  std::cerr << message << std::endl;
}

int
main (void)
{
  yy::parser p;
  p.set_debug_level(!!getenv("YYDEBUG"));
  return p.parse();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:202: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o list.cc list.yy"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:202"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:202"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:202: bison --xml=xml-tests/test.xml -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:202"
( $at_check_trace; bison --xml=xml-tests/test.xml -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:202"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:202: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:202"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:202"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:202: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:202"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:202"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:202: bison -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:202"
( $at_check_trace; bison -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:202"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/c++.at:202: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:202"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:202"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:202: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o list list.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS" "c++.at:202"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:202"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:202: ./list"
at_fn_check_prepare_trace "c++.at:202"
( $at_check_trace; ./list
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "(0, 1, 2, 4)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:202"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_255
#AT_START_256
at_fn_group_banner 256 'c++.at:203' \
  "Variants %define parse.assert %define lex_symbol %code {\\n#define USE_LEX_SYMBOL\\n}" "" 18
at_xfail=no
(
  $as_echo "256. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Store strings and integers in a list of strings.
cat >list.yy <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug
%skeleton "lalr1.cc"
%defines
%define variant
%locations
%define parse.assert %define lex_symbol %code {
#define USE_LEX_SYMBOL
}

%code requires // code for the .hh file
{
#include <list>
#include <string>
typedef std::list<std::string> strings_type;
}

%code // code for the .cc file
{
#include <iostream>
#include <sstream>

  static
#if defined USE_LEX_SYMBOL
  yy::parser::symbol_type yylex ();
#else
  yy::parser::token_type yylex (yy::parser::semantic_type* yylval,
                                yy::parser::location_type* yylloc);
#endif

  // Printing a list of strings (for %printer).
  // Koening look up will look into std, since that's an std::list.
  namespace std
  {
    std::ostream&
    operator<<(std::ostream& o, const strings_type& s)
    {
      o << '(';
      for (strings_type::const_iterator i = s.begin(); i != s.end (); ++i)
        {
          if (i != s.begin ())
            o << ", ";
          o << *i;
        }
      return o << ')';
    }
  }

  // Conversion to string.
  template <typename T>
    inline
    std::string
    string_cast (const T& t)
  {
    std::ostringstream o;
    o << t;
    return o.str();
  }
}

%token <::std::string> TEXT;
%token <int> NUMBER;
%token END_OF_FILE 0;

%type <::std::string> item;
// Using the template type to exercize its parsing.
// Starting with :: to ensure we don't output "<::" which starts by the
// digraph for the left square bracket.
%type <::std::list<std::string>> list result;

%printer { debug_stream() << $$; }
  <int> <::std::string> <::std::list<::std::string>>;
%%

result:
  list          { std::cout << $1 << std::endl; }
;

list:
  /* nothing */ { /* Generates an empty string list */ }
| list item     { std::swap($$,$1); $$.push_back($2); }
| list error    { std::swap($$,$1); }
;

item:
  TEXT          { std::swap($$,$1); }
| NUMBER        { if ($1 == 3) YYERROR; else $$ = string_cast($1); }
;
%%

#define STAGE_MAX 5
static
#if defined USE_LEX_SYMBOL
yy::parser::symbol_type yylex()
#else
yy::parser::token_type yylex(yy::parser::semantic_type* yylval,
                             yy::parser::location_type* yylloc)
#endif
{
  typedef yy::parser::token token;
  typedef yy::parser::location_type location_type;
  static int stage = -1;
  ++stage;
  if (stage == STAGE_MAX)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_END_OF_FILE (location_type ());
#else
      *yylloc = location_type ();
      return token::END_OF_FILE;
#endif
    }
  else if (stage % 2)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_NUMBER (stage, location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build(stage);
# else
      yylval->build<int>() = stage;
# endif
      *yylloc = location_type ();
      return token::NUMBER;
#endif
    }
  else
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_TEXT (string_cast (stage), location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build (string_cast (stage));
# else
      yylval->build<std::string>() = string_cast (stage);
# endif
      *yylloc = location_type ();
      return token::TEXT;
#endif
    }
  abort();
}

void
yy::parser::error(const yy::parser::location_type&,
                  const std::string& message)
{
  std::cerr << message << std::endl;
}

int
main (void)
{
  yy::parser p;
  p.set_debug_level(!!getenv("YYDEBUG"));
  return p.parse();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:203: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o list.cc list.yy"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:203"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:203"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:203: bison --xml=xml-tests/test.xml -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:203"
( $at_check_trace; bison --xml=xml-tests/test.xml -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:203"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:203: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:203"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:203"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:203: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:203"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:203"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:203: bison -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:203"
( $at_check_trace; bison -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:203"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/c++.at:203: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:203"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:203"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:203: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o list list.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS" "c++.at:203"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:203"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:203: ./list"
at_fn_check_prepare_trace "c++.at:203"
( $at_check_trace; ./list
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "(0, 1, 2, 4)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:203"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_256
#AT_START_257
at_fn_group_banner 257 'c++.at:204' \
  "Variants %define parse.assert %define lex_symbol %code {\\n#define USE_LEX_SYMBOL\\n} %define api.tokens.prefix \"TOK_\"" "" 18
at_xfail=no
(
  $as_echo "257. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Store strings and integers in a list of strings.
cat >list.yy <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug
%skeleton "lalr1.cc"
%defines
%define variant
%locations
%define parse.assert %define lex_symbol %code {
#define USE_LEX_SYMBOL
} %define api.tokens.prefix "TOK_"

%code requires // code for the .hh file
{
#include <list>
#include <string>
typedef std::list<std::string> strings_type;
}

%code // code for the .cc file
{
#include <iostream>
#include <sstream>

  static
#if defined USE_LEX_SYMBOL
  yy::parser::symbol_type yylex ();
#else
  yy::parser::token_type yylex (yy::parser::semantic_type* yylval,
                                yy::parser::location_type* yylloc);
#endif

  // Printing a list of strings (for %printer).
  // Koening look up will look into std, since that's an std::list.
  namespace std
  {
    std::ostream&
    operator<<(std::ostream& o, const strings_type& s)
    {
      o << '(';
      for (strings_type::const_iterator i = s.begin(); i != s.end (); ++i)
        {
          if (i != s.begin ())
            o << ", ";
          o << *i;
        }
      return o << ')';
    }
  }

  // Conversion to string.
  template <typename T>
    inline
    std::string
    string_cast (const T& t)
  {
    std::ostringstream o;
    o << t;
    return o.str();
  }
}

%token <::std::string> TEXT;
%token <int> NUMBER;
%token END_OF_FILE 0;

%type <::std::string> item;
// Using the template type to exercize its parsing.
// Starting with :: to ensure we don't output "<::" which starts by the
// digraph for the left square bracket.
%type <::std::list<std::string>> list result;

%printer { debug_stream() << $$; }
  <int> <::std::string> <::std::list<::std::string>>;
%%

result:
  list          { std::cout << $1 << std::endl; }
;

list:
  /* nothing */ { /* Generates an empty string list */ }
| list item     { std::swap($$,$1); $$.push_back($2); }
| list error    { std::swap($$,$1); }
;

item:
  TEXT          { std::swap($$,$1); }
| NUMBER        { if ($1 == 3) YYERROR; else $$ = string_cast($1); }
;
%%

#define STAGE_MAX 5
static
#if defined USE_LEX_SYMBOL
yy::parser::symbol_type yylex()
#else
yy::parser::token_type yylex(yy::parser::semantic_type* yylval,
                             yy::parser::location_type* yylloc)
#endif
{
  typedef yy::parser::token token;
  typedef yy::parser::location_type location_type;
  static int stage = -1;
  ++stage;
  if (stage == STAGE_MAX)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_END_OF_FILE (location_type ());
#else
      *yylloc = location_type ();
      return token::END_OF_FILE;
#endif
    }
  else if (stage % 2)
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_NUMBER (stage, location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build(stage);
# else
      yylval->build<int>() = stage;
# endif
      *yylloc = location_type ();
      return token::NUMBER;
#endif
    }
  else
    {
#if defined USE_LEX_SYMBOL
      return yy::parser::make_TEXT (string_cast (stage), location_type ());
#else
# if defined ONE_STAGE_BUILD
      yylval->build (string_cast (stage));
# else
      yylval->build<std::string>() = string_cast (stage);
# endif
      *yylloc = location_type ();
      return token::TEXT;
#endif
    }
  abort();
}

void
yy::parser::error(const yy::parser::location_type&,
                  const std::string& message)
{
  std::cerr << message << std::endl;
}

int
main (void)
{
  yy::parser p;
  p.set_debug_level(!!getenv("YYDEBUG"));
  return p.parse();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:204: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o list.cc list.yy"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:204"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:204: bison --xml=xml-tests/test.xml -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:204"
( $at_check_trace; bison --xml=xml-tests/test.xml -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:204: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:204"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:204: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:204"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:204: bison -o list.cc list.yy"
at_fn_check_prepare_trace "c++.at:204"
( $at_check_trace; bison -o list.cc list.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/c++.at:204: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:204"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:204: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o list list.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS" "c++.at:204"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o list list.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:204: ./list"
at_fn_check_prepare_trace "c++.at:204"
( $at_check_trace; ./list
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "(0, 1, 2, 4)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_257
#AT_START_258
at_fn_group_banner 258 'c++.at:287' \
  "Doxygen Public Documentation" "                   " 18
at_xfail=no
(
  $as_echo "258. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.yy <<'_ATEOF'
%skeleton "lalr1.cc"
%locations
%debug
%defines
%%
exp:;
%%
yy::parser::error (const location& l, const std::string& m)
{
  std::cerr << l << s << std::endl;
}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:287: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.yy"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:287"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:287"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:287: bison --xml=xml-tests/test.xml -o input.cc input.yy"
at_fn_check_prepare_trace "c++.at:287"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:287"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:287: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:287"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:287"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:287: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:287"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:287"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:287: bison -o input.cc input.yy"
at_fn_check_prepare_trace "c++.at:287"
( $at_check_trace; bison -o input.cc input.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:287"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >Doxyfile <<'_ATEOF'
# The PROJECT_NAME tag is a single word (or a sequence of words
# surrounded by quotes) that should identify the project.
PROJECT_NAME = "Bison C++ Parser"

# The QUIET tag can be used to turn on/off the messages that are
# generated by doxygen. Possible values are YES and NO. If left blank
# NO is used.
QUIET = YES

# The WARNINGS tag can be used to turn on/off the warning messages
# that are generated by doxygen. Possible values are YES and NO. If
# left blank NO is used.
WARNINGS     = YES
# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then
# this flag will automatically be disabled.
WARN_IF_UNDOCUMENTED   = YES
# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings
# for potential errors in the documentation, such as not documenting
# some parameters in a documented function, or documenting parameters
# that don't exist or using markup commands wrongly.
WARN_IF_DOC_ERROR      = YES
# The WARN_FORMAT tag determines the format of the warning messages
# that doxygen can produce. The string should contain the $file,
# $line, and $text tags, which will be replaced by the file and line
# number from which the warning originated and the warning text.
WARN_FORMAT            = "$file:$line: $text"

# If the EXTRACT_ALL tag is set to YES doxygen will assume all
# entities in documentation are documented, even if no documentation
# was available.  Private class members and static file members will
# be hidden unless the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set
# to YES
EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES all private members of a
# class will be included in the documentation.
EXTRACT_PRIVATE        = NO

# If the EXTRACT_STATIC tag is set to YES all static members of a file
# will be included in the documentation.
EXTRACT_STATIC         = NO
_ATEOF


{ set +x
$as_echo "$at_srcdir/c++.at:287: doxygen --version || exit 77"
at_fn_check_prepare_trace "c++.at:287"
( $at_check_trace; doxygen --version || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:287"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:287: doxygen"
at_fn_check_prepare_trace "c++.at:287"
( $at_check_trace; doxygen
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:287"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_258
#AT_START_259
at_fn_group_banner 259 'c++.at:288' \
  "Doxygen Private Documentation" "                  " 18
at_xfail=no
(
  $as_echo "259. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.yy <<'_ATEOF'
%skeleton "lalr1.cc"
%locations
%debug
%defines
%%
exp:;
%%
yy::parser::error (const location& l, const std::string& m)
{
  std::cerr << l << s << std::endl;
}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:288: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.yy"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:288"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:288"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:288: bison --xml=xml-tests/test.xml -o input.cc input.yy"
at_fn_check_prepare_trace "c++.at:288"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:288"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:288: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:288"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:288"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:288: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:288"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:288"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:288: bison -o input.cc input.yy"
at_fn_check_prepare_trace "c++.at:288"
( $at_check_trace; bison -o input.cc input.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:288"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >Doxyfile <<'_ATEOF'
# The PROJECT_NAME tag is a single word (or a sequence of words
# surrounded by quotes) that should identify the project.
PROJECT_NAME = "Bison C++ Parser"

# The QUIET tag can be used to turn on/off the messages that are
# generated by doxygen. Possible values are YES and NO. If left blank
# NO is used.
QUIET = YES

# The WARNINGS tag can be used to turn on/off the warning messages
# that are generated by doxygen. Possible values are YES and NO. If
# left blank NO is used.
WARNINGS     = YES
# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then
# this flag will automatically be disabled.
WARN_IF_UNDOCUMENTED   = YES
# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings
# for potential errors in the documentation, such as not documenting
# some parameters in a documented function, or documenting parameters
# that don't exist or using markup commands wrongly.
WARN_IF_DOC_ERROR      = YES
# The WARN_FORMAT tag determines the format of the warning messages
# that doxygen can produce. The string should contain the $file,
# $line, and $text tags, which will be replaced by the file and line
# number from which the warning originated and the warning text.
WARN_FORMAT            = "$file:$line: $text"

# If the EXTRACT_ALL tag is set to YES doxygen will assume all
# entities in documentation are documented, even if no documentation
# was available.  Private class members and static file members will
# be hidden unless the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set
# to YES
EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES all private members of a
# class will be included in the documentation.
EXTRACT_PRIVATE        = YES

# If the EXTRACT_STATIC tag is set to YES all static members of a file
# will be included in the documentation.
EXTRACT_STATIC         = YES
_ATEOF


{ set +x
$as_echo "$at_srcdir/c++.at:288: doxygen --version || exit 77"
at_fn_check_prepare_trace "c++.at:288"
( $at_check_trace; doxygen --version || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:288"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:288: doxygen"
at_fn_check_prepare_trace "c++.at:288"
( $at_check_trace; doxygen
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:288"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_259
#AT_START_260
at_fn_group_banner 260 'c++.at:348' \
  "Relative namespace references" "                  " 18
at_xfail=no
(
  $as_echo "260. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "foo"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const foo::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::parser::error (const foo::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:349: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:349"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:349"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:349: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:349"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:349"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:349: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:349"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:349"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:349: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:349"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:349"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:349: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:349"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:349"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/c++.at:349: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:349"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:349"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:349: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:349"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:349"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:349:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:349"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:349"
$at_failed && at_fn_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "foo::bar"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const foo::bar::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::bar::parser::error (const foo::bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:350: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:350"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:350"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:350: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:350"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:350"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:350: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:350"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:350"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:350: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:350"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:350"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:350: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:350"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:350"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/c++.at:350: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:350"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:350"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:350: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:350"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:350"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:350:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:350"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:350"
$at_failed && at_fn_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "foo::bar::baz"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const foo::bar::baz::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::bar::baz::parser::error (const foo::bar::baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::bar::baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:351: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:351"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:351"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:351: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:351"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:351"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:351: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:351"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:351"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:351: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:351"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:351"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:351: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:351"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:351"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/c++.at:351: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:351"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:351"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:351: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:351"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:351"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:351:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:351"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:351"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_260
#AT_START_261
at_fn_group_banner 261 'c++.at:354' \
  "Absolute namespace references" "                  " 18
at_xfail=no
(
  $as_echo "261. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "::foo"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const ::foo::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
::foo::parser::error (const ::foo::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  ::foo::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:355: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:355"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:355"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:355: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:355"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:355"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:355: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:355"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:355"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:355: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:355"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:355"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:355: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:355"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:355"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/c++.at:355: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:355"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:355"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:355: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:355"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:355"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:355:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:355"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:355"
$at_failed && at_fn_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "::foo::bar"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const ::foo::bar::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
::foo::bar::parser::error (const ::foo::bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  ::foo::bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:356: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:356"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:356"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:356: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:356"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:356"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:356: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:356"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:356"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:356: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:356"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:356"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:356: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:356"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:356"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/c++.at:356: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:356"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:356"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:356: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:356"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:356"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:356:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:356"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:356"
$at_failed && at_fn_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "::foo::bar::baz"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const ::foo::bar::baz::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
::foo::bar::baz::parser::error (const ::foo::bar::baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  ::foo::bar::baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:357: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:357"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:357"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:357: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:357"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:357"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:357: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:357"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:357"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:357: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:357"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:357"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:357: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:357"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:357"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/c++.at:357: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:357"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:357"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:357: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:357"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:357"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:357:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:357"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:357"
$at_failed && at_fn_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "	::foo"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const 	::foo::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
	::foo::parser::error (const 	::foo::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  	::foo::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:358: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:358"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:358"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:358: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:358"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:358"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:358: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:358"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:358"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:358: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:358"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:358"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:358: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:358"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:358"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/c++.at:358: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:358"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:358"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:358: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:358"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:358"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:358:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:358"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:358"
$at_failed && at_fn_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "  	 ::foo::bar"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const   	 ::foo::bar::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
  	 ::foo::bar::parser::error (const   	 ::foo::bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
    	 ::foo::bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:359: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:359"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:359"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:359: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:359"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:359"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:359: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:359"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:359"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:359: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:359"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:359"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:359: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:359"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:359"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/c++.at:359: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:359"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:359"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:359: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:359"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:359"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:359:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:359"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:359"
$at_failed && at_fn_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "  ::foo::bar::baz"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const   ::foo::bar::baz::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
  ::foo::bar::baz::parser::error (const   ::foo::bar::baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
    ::foo::bar::baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:360: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:360"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:360: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:360"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:360: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:360"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:360: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:360"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:360: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:360"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
$as_echo "$at_srcdir/c++.at:360: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:360"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:360: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:360"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:360:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:360"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_261
#AT_START_262
at_fn_group_banner 262 'c++.at:363' \
  "Syntactically invalid namespace references" "     " 18
at_xfail=no
(
  $as_echo "262. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace ":foo:bar"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const :foo:bar::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
:foo:bar::parser::error (const :foo:bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  :foo:bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:364: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:364"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:364"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:364: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:364"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:364"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:364: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:364"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:364"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:364: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:364"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:364"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:364: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:364"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:364"
$at_failed && at_fn_log_failure
$at_traceon; }







cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "foo: :bar"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const foo: :bar::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo: :bar::parser::error (const foo: :bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo: :bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:365: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:365"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:365"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:365: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:365"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:365"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:365: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:365"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:365"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:365: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:365"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:365"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:365: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:365"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:365"
$at_failed && at_fn_log_failure
$at_traceon; }





# This one is interesting because `[3]' is encoded as `[3]', which
# contains single occurrences of `:'.


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "foo[3]::bar::baz"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const foo[3]::bar::baz::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo[3]::bar::baz::parser::error (const foo[3]::bar::baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo[3]::bar::baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:368: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:368"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:368"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:368: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:368"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:368"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:368: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:368"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:368"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:368: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:368"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:368"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:368: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:368"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:368"
$at_failed && at_fn_log_failure
$at_traceon; }







cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "foo::bar,baz"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const foo::bar,baz::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::bar,baz::parser::error (const foo::bar,baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::bar,baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:369: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:369"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:369"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:369: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:369"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:369"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:369: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:369"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:369"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:369: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:369"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:369"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:369: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:369"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:369"
$at_failed && at_fn_log_failure
$at_traceon; }







cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define api.namespace "foo::bar::(baz /* Pacify Emacs ) */"
%union { int i; }
%define global_tokens_and_yystype
%locations

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval, const foo::bar::(baz /* Pacify Emacs ) */::parser::location_type*) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::bar::(baz /* Pacify Emacs ) */::parser::error (const foo::bar::(baz /* Pacify Emacs ) */::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::bar::(baz /* Pacify Emacs ) */::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:370: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:370"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:370"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:370: bison --xml=xml-tests/test.xml -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:370"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:370"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:370: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:370"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:370"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:370: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:370"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:370"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:370: bison -o input.cc input.y"
at_fn_check_prepare_trace "c++.at:370"
( $at_check_trace; bison -o input.cc input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:370"
$at_failed && at_fn_log_failure
$at_traceon; }





  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_262
#AT_START_263
at_fn_group_banner 263 'c++.at:382' \
  "Syntax error discarding no lookahead" "           " 18
at_xfail=no
(
  $as_echo "263. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.yy <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"

%code {
  #include <string>
  int yylex (yy::parser::semantic_type *, yy::location *);
  #define USE(Args)
}

%defines
%locations
%define parse.error verbose

%nonassoc 'a' ;

%destructor {
  std::cerr << "Discarding 'a'." << std::endl;
} 'a'

%%

start: error-reduce consistent-error 'a' { USE ($3); };

error-reduce:
  'a' 'a' consistent-error 'a' { USE (($1, $2, $4)); }
| 'a' error { std::cerr << "Reducing 'a'." << std::endl; USE ($1); }
;

consistent-error:
  'a'
| /*empty*/ %prec 'a'
;

// Provide another context in which all rules are useful so that this
// test case looks a little more realistic.
start: 'b' consistent-error ;

%%

int
yylex (yy::parser::semantic_type *, yy::location *)
{
  static char const *input = "aa";
  return *input++;
}

void
yy::parser::error (const location_type &, const std::string &m)
{
  std::cerr << m << std::endl;
}

int
main (void)
{
  yy::parser parser;
  return parser.parse ();
}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/c++.at:443: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.yy"
at_fn_check_prepare_notrace 'an embedded newline' "c++.at:443"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:443"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/c++.at:443: bison --xml=xml-tests/test.xml -o input.cc input.yy"
at_fn_check_prepare_trace "c++.at:443"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.cc input.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:443"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/c++.at:443: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:443"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:443"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/c++.at:443: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "c++.at:443"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:443"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/c++.at:443: bison -o input.cc input.yy"
at_fn_check_prepare_trace "c++.at:443"
( $at_check_trace; bison -o input.cc input.yy
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:443"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/c++.at:444: \$BISON_CXX_WORKS"
at_fn_check_prepare_dynamic "$BISON_CXX_WORKS" "c++.at:444"
( $at_check_trace; $BISON_CXX_WORKS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:444"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/c++.at:444: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
at_fn_check_prepare_dynamic "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS" "c++.at:444"
( $at_check_trace; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/c++.at:444"
$at_failed && at_fn_log_failure
$at_traceon; }

# This used to print "Discarding 'a'." again at the end.
{ set +x
$as_echo "$at_srcdir/c++.at:446:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "c++.at:446"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
Discarding 'a'.
Reducing 'a'.
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/c++.at:446"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_263
#AT_START_264
at_fn_group_banner 264 'java.at:386' \
  "Calculator " "                                    " 19
at_xfail=no
(
  $as_echo "264. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public


%code {

  public static void main (String args[]) throws IOException
  {
    CalcLexer l = new CalcLexer (System.in);
    Calc p = new Calc (l);
    p.parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%%
class CalcLexer implements Calc.Lexer {

  StreamTokenizer st;

  public CalcLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  public void yyerror (String s)
  {
    System.err.println (s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();

    if (ttype == st.TT_EOF)
      return EOF;

    else if (ttype == st.TT_EOL)
      {

        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return NUM;
      }

    else
      return st.ttype;
  }



}


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:386: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:386"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:386: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; bison --xml=xml-tests/test.xml -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:386: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:386"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:386: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:386"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:386: bison -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; bison -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:386: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:386"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:386: \$SHELL ../../../javacomp.sh Calc.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh Calc.java" "java.at:386"
( $at_check_trace; $SHELL ../../../javacomp.sh Calc.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < /dev/null" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_264
#AT_START_265
at_fn_group_banner 265 'java.at:386' \
  "Calculator %error-verbose " "                     " 19
at_xfail=no
(
  $as_echo "265. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%error-verbose
%code {

  public static void main (String args[]) throws IOException
  {
    CalcLexer l = new CalcLexer (System.in);
    Calc p = new Calc (l);
    p.parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%%
class CalcLexer implements Calc.Lexer {

  StreamTokenizer st;

  public CalcLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  public void yyerror (String s)
  {
    System.err.println (s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();

    if (ttype == st.TT_EOF)
      return EOF;

    else if (ttype == st.TT_EOL)
      {

        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return NUM;
      }

    else
      return st.ttype;
  }



}


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:386: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:386"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:386: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; bison --xml=xml-tests/test.xml -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:386: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:386"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:386: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:386"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:386: bison -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; bison -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:386: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:386"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:386: \$SHELL ../../../javacomp.sh Calc.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh Calc.java" "java.at:386"
( $at_check_trace; $SHELL ../../../javacomp.sh Calc.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < /dev/null" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_265
#AT_START_266
at_fn_group_banner 266 'java.at:386' \
  "Calculator %locations " "                         " 19
at_xfail=no
(
  $as_echo "266. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%locations
%code {

  public static void main (String args[]) throws IOException
  {
    CalcLexer l = new CalcLexer (System.in);
    Calc p = new Calc (l);
    p.parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%%
class CalcLexer implements Calc.Lexer {

  StreamTokenizer st;

  public CalcLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  Position yystartpos;
  Position yyendpos = new Position (1);

  public Position getStartPos() {
    return yystartpos;
  }

  public Position getEndPos() {
    return yyendpos;
  }

  public void yyerror (Calc.Location l, String s)
  {
    if (l == null)
      System.err.println (s);
    else
      System.err.println (l.begin + ": " + s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();
    yystartpos = yyendpos;
    if (ttype == st.TT_EOF)
      return EOF;

    else if (ttype == st.TT_EOL)
      {
        yyendpos = new Position (yyendpos.lineno () + 1);
        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return NUM;
      }

    else
      return st.ttype;
  }



}


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:386: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:386"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:386: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; bison --xml=xml-tests/test.xml -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:386: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:386"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:386: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:386"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:386: bison -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; bison -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:386: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:386"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:386: \$SHELL ../../../javacomp.sh Calc.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh Calc.java" "java.at:386"
( $at_check_trace; $SHELL ../../../javacomp.sh Calc.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < /dev/null" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_266
#AT_START_267
at_fn_group_banner 267 'java.at:386' \
  "Calculator %error-verbose %locations " "          " 19
at_xfail=no
(
  $as_echo "267. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%error-verbose %locations
%code {

  public static void main (String args[]) throws IOException
  {
    CalcLexer l = new CalcLexer (System.in);
    Calc p = new Calc (l);
    p.parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%%
class CalcLexer implements Calc.Lexer {

  StreamTokenizer st;

  public CalcLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  Position yystartpos;
  Position yyendpos = new Position (1);

  public Position getStartPos() {
    return yystartpos;
  }

  public Position getEndPos() {
    return yyendpos;
  }

  public void yyerror (Calc.Location l, String s)
  {
    if (l == null)
      System.err.println (s);
    else
      System.err.println (l.begin + ": " + s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();
    yystartpos = yyendpos;
    if (ttype == st.TT_EOF)
      return EOF;

    else if (ttype == st.TT_EOL)
      {
        yyendpos = new Position (yyendpos.lineno () + 1);
        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return NUM;
      }

    else
      return st.ttype;
  }



}


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:386: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:386"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:386: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; bison --xml=xml-tests/test.xml -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:386: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:386"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:386: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:386"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:386: bison -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; bison -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:386: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:386"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:386: \$SHELL ../../../javacomp.sh Calc.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh Calc.java" "java.at:386"
( $at_check_trace; $SHELL ../../../javacomp.sh Calc.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < /dev/null" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:386:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:386"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:386: cat stderr"
at_fn_check_prepare_trace "java.at:386"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:386"
$at_failed && at_fn_log_failure
$at_traceon; }































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_267
#AT_START_268
at_fn_group_banner 268 'java.at:395' \
  "Calculator %lex-param { InputStream is } " "      " 19
at_xfail=no
(
  $as_echo "268. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%lex-param { InputStream is }
%code {

  public static void main (String args[]) throws IOException
  {
    new Calc (System.in).parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%code lexer {

  StreamTokenizer st;

  public YYLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  public void yyerror (String s)
  {
    System.err.println (s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();

    if (ttype == st.TT_EOF)
      return EOF;

    else if (ttype == st.TT_EOL)
      {

        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return NUM;
      }

    else
      return st.ttype;
  }



};
%%


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:395: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:395"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:395: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; bison --xml=xml-tests/test.xml -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:395: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:395"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:395: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:395"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:395: bison -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; bison -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:395: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:395"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:395: \$SHELL ../../../javacomp.sh Calc.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh Calc.java" "java.at:395"
( $at_check_trace; $SHELL ../../../javacomp.sh Calc.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < /dev/null" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_268
#AT_START_269
at_fn_group_banner 269 'java.at:395' \
  "Calculator %error-verbose %lex-param { InputStream is } " "" 19
at_xfail=no
(
  $as_echo "269. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%error-verbose %lex-param { InputStream is }
%code {

  public static void main (String args[]) throws IOException
  {
    new Calc (System.in).parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%code lexer {

  StreamTokenizer st;

  public YYLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  public void yyerror (String s)
  {
    System.err.println (s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();

    if (ttype == st.TT_EOF)
      return EOF;

    else if (ttype == st.TT_EOL)
      {

        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return NUM;
      }

    else
      return st.ttype;
  }



};
%%


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:395: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:395"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:395: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; bison --xml=xml-tests/test.xml -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:395: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:395"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:395: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:395"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:395: bison -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; bison -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:395: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:395"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:395: \$SHELL ../../../javacomp.sh Calc.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh Calc.java" "java.at:395"
( $at_check_trace; $SHELL ../../../javacomp.sh Calc.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < /dev/null" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_269
#AT_START_270
at_fn_group_banner 270 'java.at:395' \
  "Calculator %locations %lex-param { InputStream is } " "" 19
at_xfail=no
(
  $as_echo "270. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%locations %lex-param { InputStream is }
%code {

  public static void main (String args[]) throws IOException
  {
    new Calc (System.in).parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%code lexer {

  StreamTokenizer st;

  public YYLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  Position yystartpos;
  Position yyendpos = new Position (1);

  public Position getStartPos() {
    return yystartpos;
  }

  public Position getEndPos() {
    return yyendpos;
  }

  public void yyerror (Calc.Location l, String s)
  {
    if (l == null)
      System.err.println (s);
    else
      System.err.println (l.begin + ": " + s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();
    yystartpos = yyendpos;
    if (ttype == st.TT_EOF)
      return EOF;

    else if (ttype == st.TT_EOL)
      {
        yyendpos = new Position (yyendpos.lineno () + 1);
        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return NUM;
      }

    else
      return st.ttype;
  }



};
%%


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:395: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:395"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:395: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; bison --xml=xml-tests/test.xml -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:395: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:395"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:395: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:395"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:395: bison -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; bison -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:395: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:395"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:395: \$SHELL ../../../javacomp.sh Calc.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh Calc.java" "java.at:395"
( $at_check_trace; $SHELL ../../../javacomp.sh Calc.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < /dev/null" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_270
#AT_START_271
at_fn_group_banner 271 'java.at:395' \
  "Calculator %error-verbose %locations %lex-param { InputStream is } " "" 19
at_xfail=no
(
  $as_echo "271. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%error-verbose %locations %lex-param { InputStream is }
%code {

  public static void main (String args[]) throws IOException
  {
    new Calc (System.in).parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%code lexer {

  StreamTokenizer st;

  public YYLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  Position yystartpos;
  Position yyendpos = new Position (1);

  public Position getStartPos() {
    return yystartpos;
  }

  public Position getEndPos() {
    return yyendpos;
  }

  public void yyerror (Calc.Location l, String s)
  {
    if (l == null)
      System.err.println (s);
    else
      System.err.println (l.begin + ": " + s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();
    yystartpos = yyendpos;
    if (ttype == st.TT_EOF)
      return EOF;

    else if (ttype == st.TT_EOL)
      {
        yyendpos = new Position (yyendpos.lineno () + 1);
        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return NUM;
      }

    else
      return st.ttype;
  }



};
%%


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:395: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:395"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:395: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; bison --xml=xml-tests/test.xml -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:395: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:395"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:395: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:395"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:395: bison -o Calc.java Calc.y"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; bison -o Calc.java Calc.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:395: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:395"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:395: \$SHELL ../../../javacomp.sh Calc.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh Calc.java" "java.at:395"
( $at_check_trace; $SHELL ../../../javacomp.sh Calc.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < /dev/null" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < /dev/null
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ set +x
$as_echo "$at_srcdir/java.at:395:  \$SHELL ../../../javaexec.sh Calc < input"
at_fn_check_prepare_dynamic " $SHELL ../../../javaexec.sh Calc < input" "java.at:395"
( $at_check_trace;  $SHELL ../../../javaexec.sh Calc < input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; tee stderr <"$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ set +x
$as_echo "$at_srcdir/java.at:395: cat stderr"
at_fn_check_prepare_trace "java.at:395"
( $at_check_trace; cat stderr
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:395"
$at_failed && at_fn_log_failure
$at_traceon; }































  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_271
#AT_START_272
at_fn_group_banner 272 'java.at:482' \
  "Java parser class and package names" "            " 20
at_xfail=no
(
  $as_echo "272. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:484: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:484"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:484"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:484: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:484"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:484"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:484: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:484"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:484"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:484: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:484"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:484"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:484: bison YYParser.y"
at_fn_check_prepare_trace "java.at:484"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:484"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:484: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:484"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:484"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:484: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:484"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:484"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:484: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:484"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:484"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:485: grep -c '^class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^class YYParser$' YYParser.java" "java.at:485"
( $at_check_trace; grep -c '^class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:485"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%name-prefix "Prefix"
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:487: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:487"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:487"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:487: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:487"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:487"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:487: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:487"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:487"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:487: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:487"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:487"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:487: bison YYParser.y"
at_fn_check_prepare_trace "java.at:487"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:487"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:487: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:487"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:487"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:487: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:487"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:487"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:487: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:487"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:487"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:488: grep -c '^class PrefixParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^class PrefixParser$' YYParser.java" "java.at:488"
( $at_check_trace; grep -c '^class PrefixParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:488"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%define api.tokens.prefix "TOK_"
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:490: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:490"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:490"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:490: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:490"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:490"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:490: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:490"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:490"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:490: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:490"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:490"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:490: bison YYParser.y"
at_fn_check_prepare_trace "java.at:490"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:490"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:490: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:490"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:490"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:490: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:490"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:490"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:490: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:490"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:490"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:491: grep -c '^.*TOK_END.*\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^.*TOK_END.*$' YYParser.java" "java.at:491"
( $at_check_trace; grep -c '^.*TOK_END.*$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:491"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%define parser_class_name "ParserClassName"
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:493: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:493"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:493"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:493: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:493"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:493"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:493: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:493"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:493"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:493: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:493"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:493"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:493: bison YYParser.y"
at_fn_check_prepare_trace "java.at:493"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:493"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:493: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:493"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:493"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:493: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:493"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:493"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:493: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:493"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:493"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:494: grep -c '^class ParserClassName\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^class ParserClassName$' YYParser.java" "java.at:494"
( $at_check_trace; grep -c '^class ParserClassName$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:494"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%define package "user_java_package"
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:496: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:496"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:496"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:496: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:496"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:496"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:496: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:496"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:496"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:496: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:496"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:496"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:496: bison YYParser.y"
at_fn_check_prepare_trace "java.at:496"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:496"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:496: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:496"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:496"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:496: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:496"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:496"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:496: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:496"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:496"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:497: grep -c '^package user_java_package;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^package user_java_package;$' YYParser.java" "java.at:497"
( $at_check_trace; grep -c '^package user_java_package;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:497"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_272
#AT_START_273
at_fn_group_banner 273 'java.at:506' \
  "Java parser class modifiers" "                    " 20
at_xfail=no
(
  $as_echo "273. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%define abstract
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:508: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:508"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:508"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:508: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:508"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:508"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:508: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:508"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:508"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:508: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:508"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:508"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:508: bison YYParser.y"
at_fn_check_prepare_trace "java.at:508"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:508"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:508: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:508"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:508"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:508: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:508"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:508"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:508: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:508"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:508"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:509: grep -c '^abstract class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^abstract class YYParser$' YYParser.java" "java.at:509"
( $at_check_trace; grep -c '^abstract class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:509"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%define final
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:511: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:511"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:511"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:511: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:511"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:511"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:511: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:511"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:511"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:511: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:511"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:511"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:511: bison YYParser.y"
at_fn_check_prepare_trace "java.at:511"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:511"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:511: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:511"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:511"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:511: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:511"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:511"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:511: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:511"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:511"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:512: grep -c '^final class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^final class YYParser$' YYParser.java" "java.at:512"
( $at_check_trace; grep -c '^final class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:512"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%define strictfp
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:514: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:514"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:514"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:514: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:514"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:514"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:514: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:514"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:514"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:514: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:514"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:514"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:514: bison YYParser.y"
at_fn_check_prepare_trace "java.at:514"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:514"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:514: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:514"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:514"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:514: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:514"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:514"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:514: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:514"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:514"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:515: grep -c '^strictfp class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^strictfp class YYParser$' YYParser.java" "java.at:515"
( $at_check_trace; grep -c '^strictfp class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:515"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define abstract
%define strictfp
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:517: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:517"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:517"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:517: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:517"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:517"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:517: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:517"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:517"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:517: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:517"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:517"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:517: bison YYParser.y"
at_fn_check_prepare_trace "java.at:517"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:517"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:517: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:517"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:517"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:517: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:517"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:517"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:517: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:517"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:517"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:520: grep -c '^abstract strictfp class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^abstract strictfp class YYParser$' YYParser.java" "java.at:520"
( $at_check_trace; grep -c '^abstract strictfp class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:520"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define final
%define strictfp
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:522: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:522"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:522: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:522"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:522: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:522"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:522: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:522"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:522: bison YYParser.y"
at_fn_check_prepare_trace "java.at:522"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:522: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:522"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:522: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:522"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:522: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:522"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:522"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:525: grep -c '^final strictfp class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^final strictfp class YYParser$' YYParser.java" "java.at:525"
( $at_check_trace; grep -c '^final strictfp class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:525"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%define public
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:527: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:527"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:527"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:527: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:527"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:527"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:527: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:527"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:527"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:527: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:527"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:527"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:527: bison YYParser.y"
at_fn_check_prepare_trace "java.at:527"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:527"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:527: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:527"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:527"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:527: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:527"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:527"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:527: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:527"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:527"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:528: grep -c '^public class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^public class YYParser$' YYParser.java" "java.at:528"
( $at_check_trace; grep -c '^public class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:528"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define public
%define abstract
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:530: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:530"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:530"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:530: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:530"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:530"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:530: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:530"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:530"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:530: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:530"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:530"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:530: bison YYParser.y"
at_fn_check_prepare_trace "java.at:530"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:530"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:530: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:530"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:530"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:530: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:530"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:530"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:530: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:530"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:530"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:533: grep -c '^public abstract class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^public abstract class YYParser$' YYParser.java" "java.at:533"
( $at_check_trace; grep -c '^public abstract class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:533"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define public
%define final
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:535: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:535"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:535"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:535: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:535"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:535"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:535: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:535"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:535"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:535: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:535"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:535"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:535: bison YYParser.y"
at_fn_check_prepare_trace "java.at:535"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:535"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:535: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:535"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:535"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:535: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:535"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:535"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:535: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:535"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:535"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:538: grep -c '^public final class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^public final class YYParser$' YYParser.java" "java.at:538"
( $at_check_trace; grep -c '^public final class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:538"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define public
%define strictfp
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:540: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:540"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:540: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:540"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:540: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:540"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:540: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:540"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:540: bison YYParser.y"
at_fn_check_prepare_trace "java.at:540"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:540: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:540"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:540: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:540"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:540: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:540"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:540"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:543: grep -c '^public strictfp class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^public strictfp class YYParser$' YYParser.java" "java.at:543"
( $at_check_trace; grep -c '^public strictfp class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:543"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define public
%define abstract
%define strictfp
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:545: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:545"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:545"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:545: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:545"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:545"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:545: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:545"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:545"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:545: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:545"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:545"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:545: bison YYParser.y"
at_fn_check_prepare_trace "java.at:545"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:545"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:545: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:545"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:545"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:545: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:545"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:545"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:545: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:545"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:545"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:549: grep -c '^public abstract strictfp class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^public abstract strictfp class YYParser$' YYParser.java" "java.at:549"
( $at_check_trace; grep -c '^public abstract strictfp class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:549"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define public
%define final
%define strictfp
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:551: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:551"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:551"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:551: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:551"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:551"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:551: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:551"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:551"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:551: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:551"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:551"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:551: bison YYParser.y"
at_fn_check_prepare_trace "java.at:551"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:551"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:551: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:551"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:551"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:551: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:551"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:551"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:551: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:551"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:551"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:555: grep -c '^public final strictfp class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^public final strictfp class YYParser$' YYParser.java" "java.at:555"
( $at_check_trace; grep -c '^public final strictfp class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:555"
$at_failed && at_fn_log_failure
$at_traceon; }



# FIXME: Can't do a Java compile because javacomp.sh is configured for 1.3

cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define annotations "/*@Deprecated @SupressWarnings(\"unchecked\") @SupressWarnings({\"unchecked\", \"deprecation\"}) @SupressWarnings(value={\"unchecked\", \"deprecation\"})*/"
%define public
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:558: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:558"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:558"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:558: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:558"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:558"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:558: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:558"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:558"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:558: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:558"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:558"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:558: bison YYParser.y"
at_fn_check_prepare_trace "java.at:558"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:558"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:558: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:558"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:558"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:558: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:558"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:558"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:558: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:558"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:558"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:561: grep -c '^/\\*@Deprecated @SupressWarnings(\"unchecked\") @SupressWarnings({\"unchecked\", \"deprecation\"}) @SupressWarnings(value={\"unchecked\", \"deprecation\"})\\*/ public class YYParser\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^/\\*@Deprecated @SupressWarnings(\"unchecked\") @SupressWarnings({\"unchecked\", \"deprecation\"}) @SupressWarnings(value={\"unchecked\", \"deprecation\"})\\*/ public class YYParser$' YYParser.java" "java.at:561"
( $at_check_trace; grep -c '^/\*@Deprecated @SupressWarnings("unchecked") @SupressWarnings({"unchecked", "deprecation"}) @SupressWarnings(value={"unchecked", "deprecation"})\*/ public class YYParser$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:561"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_273
#AT_START_274
at_fn_group_banner 274 'java.at:570' \
  "Java parser class extends and implements" "       " 20
at_xfail=no
(
  $as_echo "274. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%define extends "Thread"
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:572: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:572"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:572: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:572"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:572: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:572"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:572: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:572"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:572: bison YYParser.y"
at_fn_check_prepare_trace "java.at:572"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:572: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:572"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:572: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:572"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:572: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:572"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:573: grep -c '^class YYParser extends Thread\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^class YYParser extends Thread$' YYParser.java" "java.at:573"
( $at_check_trace; grep -c '^class YYParser extends Thread$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:573"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%define implements "Cloneable"
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:575: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:575"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:575: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:575"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:575: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:575"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:575: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:575"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:575: bison YYParser.y"
at_fn_check_prepare_trace "java.at:575"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:575: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:575"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:575: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:575"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:575: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:575"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:576: grep -c '^class YYParser implements Cloneable\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^class YYParser implements Cloneable$' YYParser.java" "java.at:576"
( $at_check_trace; grep -c '^class YYParser implements Cloneable$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:576"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define extends "Thread"
%define implements "Cloneable"
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:578: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:578"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:578: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:578"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:578: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:578"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:578: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:578"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:578: bison YYParser.y"
at_fn_check_prepare_trace "java.at:578"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:578: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:578"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:578: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:578"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:578: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:578"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:578"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:581: grep -c '^class YYParser extends Thread implements Cloneable\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^class YYParser extends Thread implements Cloneable$' YYParser.java" "java.at:581"
( $at_check_trace; grep -c '^class YYParser extends Thread implements Cloneable$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:581"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_274
#AT_START_275
at_fn_group_banner 275 'java.at:590' \
  "Java %parse-param and %lex-param" "               " 20
at_xfail=no
(
  $as_echo "275. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:592: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:592"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:592"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:592: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:592"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:592"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:592: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:592"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:592"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:592: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:592"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:592"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:592: bison YYParser.y"
at_fn_check_prepare_trace "java.at:592"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:592"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:592: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:592"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:592"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:592: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:592"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:592"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:592: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:592"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:592"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:593: grep -c '^ *public YYParser (Lexer yylexer) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public YYParser (Lexer yylexer) *$' YYParser.java" "java.at:593"
( $at_check_trace; grep -c '^ *public YYParser (Lexer yylexer) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:593"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%parse-param {int parse_param1}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:595: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:595"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:595"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:595: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:595"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:595"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:595: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:595"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:595"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:595: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:595"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:595"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:595: bison YYParser.y"
at_fn_check_prepare_trace "java.at:595"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:595"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:595: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:595"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:595"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:595: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:595"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:595"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:595: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:595"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:595"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:596: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected final int parse_param1;$' YYParser.java" "java.at:596"
( $at_check_trace; grep -c '^ *protected final int parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:596"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:597: grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1) *$' YYParser.java" "java.at:597"
( $at_check_trace; grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:597"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:598: grep -c '^ *this.parse_param1 = parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java" "java.at:598"
( $at_check_trace; grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:598"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%parse-param {int parse_param1}
%parse-param {long parse_param2}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:600: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:600"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:600"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:600: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:600"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:600"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:600: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:600"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:600"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:600: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:600"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:600"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:600: bison YYParser.y"
at_fn_check_prepare_trace "java.at:600"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:600"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:600: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:600"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:600"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:600: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:600"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:600"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:600: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:600"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:600"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:603: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected final int parse_param1;$' YYParser.java" "java.at:603"
( $at_check_trace; grep -c '^ *protected final int parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:603"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:604: grep -c '^ *protected final long parse_param2;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected final long parse_param2;$' YYParser.java" "java.at:604"
( $at_check_trace; grep -c '^ *protected final long parse_param2;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:604"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:605: grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) *$' YYParser.java" "java.at:605"
( $at_check_trace; grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:605"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:606: grep -c '^ *this.parse_param1 = parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java" "java.at:606"
( $at_check_trace; grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:606"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:607: grep -c '^ *this.parse_param2 = parse_param2;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *this.parse_param2 = parse_param2;$' YYParser.java" "java.at:607"
( $at_check_trace; grep -c '^ *this.parse_param2 = parse_param2;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:607"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:609: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:609"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:609: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:609"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:609: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:609"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:609: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:609"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:609: bison YYParser.y"
at_fn_check_prepare_trace "java.at:609"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:609: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:609"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:609: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:609"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:609: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:609"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:609"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:610: grep -c '^ *public YYParser () *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public YYParser () *$' YYParser.java" "java.at:610"
( $at_check_trace; grep -c '^ *public YYParser () *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:610"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:611: grep -c '^ *protected YYParser (Lexer yylexer) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected YYParser (Lexer yylexer) *$' YYParser.java" "java.at:611"
( $at_check_trace; grep -c '^ *protected YYParser (Lexer yylexer) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:611"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%parse-param {int parse_param1}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:613: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:613"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:613: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:613"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:613: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:613"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:613: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:613"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:613: bison YYParser.y"
at_fn_check_prepare_trace "java.at:613"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:613: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:613"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:613: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:613"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:613: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:613"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:613"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:615: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected final int parse_param1;$' YYParser.java" "java.at:615"
( $at_check_trace; grep -c '^ *protected final int parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:616: grep -c '^ *public YYParser (int parse_param1) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public YYParser (int parse_param1) *$' YYParser.java" "java.at:616"
( $at_check_trace; grep -c '^ *public YYParser (int parse_param1) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:616"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:617: grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1) *$' YYParser.java" "java.at:617"
( $at_check_trace; grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:617"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:618: grep -c '^ *this.parse_param1 = parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java" "java.at:618"
( $at_check_trace; grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:618"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%parse-param {int parse_param1}
%parse-param {long parse_param2}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:620: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:620"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:620: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:620"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:620: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:620"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:620: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:620"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:620: bison YYParser.y"
at_fn_check_prepare_trace "java.at:620"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:620: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:620"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:620: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:620"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:620: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:620"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:620"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:624: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected final int parse_param1;$' YYParser.java" "java.at:624"
( $at_check_trace; grep -c '^ *protected final int parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:624"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:625: grep -c '^ *protected final long parse_param2;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected final long parse_param2;$' YYParser.java" "java.at:625"
( $at_check_trace; grep -c '^ *protected final long parse_param2;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:625"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:626: grep -c '^ *public YYParser (int parse_param1, *long parse_param2) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public YYParser (int parse_param1, *long parse_param2) *$' YYParser.java" "java.at:626"
( $at_check_trace; grep -c '^ *public YYParser (int parse_param1, *long parse_param2) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:626"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:627: grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) *$' YYParser.java" "java.at:627"
( $at_check_trace; grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:627"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:628: grep -c '^ *this.parse_param1 = parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java" "java.at:628"
( $at_check_trace; grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:628"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:629: grep -c '^ *this.parse_param2 = parse_param2;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *this.parse_param2 = parse_param2;$' YYParser.java" "java.at:629"
( $at_check_trace; grep -c '^ *this.parse_param2 = parse_param2;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:629"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"
%lex-param {char lex_param1}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }

  YYLexer (char lex_param1) {}
}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:631: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:631"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:631: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:631"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:631: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:631"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:631: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:631"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:631: bison YYParser.y"
at_fn_check_prepare_trace "java.at:631"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:631: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:631"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:631: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:631"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:631: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:631"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:631"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:633: grep -c '^ *public YYParser (char lex_param1) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public YYParser (char lex_param1) *$' YYParser.java" "java.at:633"
( $at_check_trace; grep -c '^ *public YYParser (char lex_param1) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:633"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:634: grep -c '^.* = new YYLexer *(lex_param1);\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^.* = new YYLexer *(lex_param1);$' YYParser.java" "java.at:634"
( $at_check_trace; grep -c '^.* = new YYLexer *(lex_param1);$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:634"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%lex-param {char lex_param1}
%lex-param {short lex_param2}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }

  YYLexer (char lex_param1, short lex_param2) {}
}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:636: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:636"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:636"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:636: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:636"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:636"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:636: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:636"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:636"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:636: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:636"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:636"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:636: bison YYParser.y"
at_fn_check_prepare_trace "java.at:636"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:636"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:636: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:636"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:636"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:636: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:636"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:636"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:636: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:636"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:636"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:640: grep -c '^ *public YYParser (char lex_param1, *short lex_param2) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public YYParser (char lex_param1, *short lex_param2) *$' YYParser.java" "java.at:640"
( $at_check_trace; grep -c '^ *public YYParser (char lex_param1, *short lex_param2) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:640"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:641: grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java" "java.at:641"
( $at_check_trace; grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:641"
$at_failed && at_fn_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%parse-param {int parse_param1}
%parse-param {long parse_param2}
%lex-param {char lex_param1}
%lex-param {short lex_param2}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }

  YYLexer (char lex_param1, short lex_param2) {}
}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:643: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:643"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:643"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:643: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:643"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:643"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:643: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:643"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:643"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:643: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:643"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:643"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:643: bison YYParser.y"
at_fn_check_prepare_trace "java.at:643"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:643"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:643: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:643"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:643"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:643: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:643"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:643"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:643: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:643"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:643"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:649: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected final int parse_param1;$' YYParser.java" "java.at:649"
( $at_check_trace; grep -c '^ *protected final int parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:649"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:650: grep -c '^ *protected final long parse_param2;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected final long parse_param2;$' YYParser.java" "java.at:650"
( $at_check_trace; grep -c '^ *protected final long parse_param2;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:650"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:651: grep -c '^ *public YYParser (char lex_param1, *short lex_param2, *int parse_param1, *long parse_param2) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public YYParser (char lex_param1, *short lex_param2, *int parse_param1, *long parse_param2) *$' YYParser.java" "java.at:651"
( $at_check_trace; grep -c '^ *public YYParser (char lex_param1, *short lex_param2, *int parse_param1, *long parse_param2) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:651"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:652: grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java" "java.at:652"
( $at_check_trace; grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:652"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:653: grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) *$' YYParser.java" "java.at:653"
( $at_check_trace; grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:653"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:654: grep -c '^ *this.parse_param1 = parse_param1;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java" "java.at:654"
( $at_check_trace; grep -c '^ *this.parse_param1 = parse_param1;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:654"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:655: grep -c '^ *this.parse_param2 = parse_param2;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *this.parse_param2 = parse_param2;$' YYParser.java" "java.at:655"
( $at_check_trace; grep -c '^ *this.parse_param2 = parse_param2;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:655"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_275
#AT_START_276
at_fn_group_banner 276 'java.at:664' \
  "Java throws specifications" "                     " 20
at_xfail=no
(
  $as_echo "276. $at_setup_line: testing $at_desc ..."
  $at_traceon


# %define throws	- 0 1 2
# %define lex-throws	- 0 1 2
# %code lexer		  0 1





















cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"




%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws java.io.IOException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws ""


%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws java.io.IOException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException"

%initial-action {if (true) throw new ClassNotFoundException();}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException, InstantiationException"

%initial-action {if (true) throw new InstantiationException();}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"


%define lex_throws ""

%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws ""
%define lex_throws ""

%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException"
%define lex_throws ""
%initial-action {if (true) throw new ClassNotFoundException();}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws ""
%initial-action {if (true) throw new InstantiationException();}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"


%define lex_throws "InterruptedException"

%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws ""
%define lex_throws "InterruptedException"

%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException"
%define lex_throws "InterruptedException"
%initial-action {if (true) throw new ClassNotFoundException();}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws "InterruptedException"
%initial-action {if (true) throw new InstantiationException();}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"


%define lex_throws "InterruptedException, IllegalAccessException"

%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws ""
%define lex_throws "InterruptedException, IllegalAccessException"

%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException"
%define lex_throws "InterruptedException, IllegalAccessException"
%initial-action {if (true) throw new ClassNotFoundException();}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws "InterruptedException, IllegalAccessException"
%initial-action {if (true) throw new InstantiationException();}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"





%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws java.io.IOException
  {
    throw new java.io.IOException();
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws java.io.IOException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws ""



%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws java.io.IOException
  {
    throw new java.io.IOException();
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws java.io.IOException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException"

%initial-action {if (true) throw new ClassNotFoundException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws java.io.IOException
  {
    throw new java.io.IOException();
  }


}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException, InstantiationException"

%initial-action {if (true) throw new InstantiationException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws java.io.IOException
  {
    throw new java.io.IOException();
  }


}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"


%define lex_throws ""


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws ""
%define lex_throws ""


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException"
%define lex_throws ""
%initial-action {if (true) throw new ClassNotFoundException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws ""
%initial-action {if (true) throw new InstantiationException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"


%define lex_throws "InterruptedException"


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException
  {
    throw new InterruptedException();
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws ""
%define lex_throws "InterruptedException"


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException
  {
    throw new InterruptedException();
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException"
%define lex_throws "InterruptedException"
%initial-action {if (true) throw new ClassNotFoundException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException
  {
    throw new InterruptedException();
  }


}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws "InterruptedException"
%initial-action {if (true) throw new InstantiationException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException
  {
    throw new InterruptedException();
  }


}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"


%define lex_throws "InterruptedException, IllegalAccessException"


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException, IllegalAccessException
  {
    throw new IllegalAccessException();
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws ""
%define lex_throws "InterruptedException, IllegalAccessException"


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException, IllegalAccessException
  {
    throw new IllegalAccessException();
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException"
%define lex_throws "InterruptedException, IllegalAccessException"
%initial-action {if (true) throw new ClassNotFoundException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException, IllegalAccessException
  {
    throw new IllegalAccessException();
  }


}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws "InterruptedException, IllegalAccessException"
%initial-action {if (true) throw new InstantiationException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException, IllegalAccessException
  {
    throw new IllegalAccessException();
  }


}
%%
start: END {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:724: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:724: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:724: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:724"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:724: bison YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:724"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:724"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:724: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:724"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:724: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
at_fn_check_prepare_dynamic "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java" "java.at:724"
( $at_check_trace; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:724"
$at_failed && at_fn_log_failure
$at_traceon; }




  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_276
#AT_START_277
at_fn_group_banner 277 'java.at:753' \
  "Java constructor init and init_throws" "          " 20
at_xfail=no
(
  $as_echo "277. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define extends "Thread"
%code init { super("Test Thread"); if (true) throw new InterruptedException(); }
%define init_throws "InterruptedException"
%lex-param {int lex_param}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:755: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:755"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:755"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:755: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:755"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:755"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:755: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:755"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:755"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:755: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:755"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:755"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:755: bison YYParser.y"
at_fn_check_prepare_trace "java.at:755"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:755"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:755: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:755"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:755"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:755: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:755"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:755"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:755: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:755"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:755"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:760: grep -q 'super(\"Test Thread\"); if (true) throw new InterruptedException();' YYParser.java"
at_fn_check_prepare_trace "java.at:760"
( $at_check_trace; grep -q 'super("Test Thread"); if (true) throw new InterruptedException();' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:760"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define extends "Thread"
%code init { super("Test Thread"); if (true) throw new InterruptedException(); }
%define init_throws "InterruptedException"

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: END {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:762: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:762"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:762: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:762"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:762: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:762"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:762: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:762"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:762: bison YYParser.y"
at_fn_check_prepare_trace "java.at:762"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:762: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:762"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:762: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:762"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:762: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:762"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:766: grep -q 'super(\"Test Thread\"); if (true) throw new InterruptedException();' YYParser.java"
at_fn_check_prepare_trace "java.at:766"
( $at_check_trace; grep -q 'super("Test Thread"); if (true) throw new InterruptedException();' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:766"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_277
#AT_START_278
at_fn_group_banner 278 'java.at:775' \
  "Java stype, position_class and location_class" "  " 20
at_xfail=no
(
  $as_echo "278. $at_setup_line: testing $at_desc ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define stype "java.awt.Color"
%type<java.awt.Color> start;
%define location_type "MyLoc"
%define position_type "MyPos"
%code { class MyPos {} }
%%
start: END {$$ = $<java.awt.Color>1;};
%%
class MyPos {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:777: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:777"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:777"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:777: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:777"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:777"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:777: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:777"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:777"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:777: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:777"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:777"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:777: bison YYParser.y"
at_fn_check_prepare_trace "java.at:777"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:777"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:777: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:777"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:777"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:777: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:777"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:777"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:777: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:777"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:777"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:783: grep 'java.awt.Color' YYParser.java"
at_fn_check_prepare_trace "java.at:783"
( $at_check_trace; grep 'java.awt.Color' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:783"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:784: \$EGREP -v ' */?\\*' YYParser.java | grep 'Position'"
at_fn_check_prepare_notrace 'a shell pipeline' "java.at:784"
( $at_check_trace; $EGREP -v ' */?\*' YYParser.java | grep 'Position'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:784"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:785: \$EGREP -v ' */?\\*' YYParser.java | grep 'Location'"
at_fn_check_prepare_notrace 'a shell pipeline' "java.at:785"
( $at_check_trace; $EGREP -v ' */?\*' YYParser.java | grep 'Location'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:785"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%token END "end"

%define stype "java.awt.Color"
%type<java.awt.Color> start;
%define location_type "MyLoc"
%define position_type "MyPos"
%code { class MyPos {} }

%code lexer
{
  java.awt.Color yylval;
  public java.awt.Color getLVal() { return yylval; }

  public MyPos getStartPos() { return null; }
  public MyPos getEndPos()   { return null; }

  public void yyerror (MyLoc loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: END {$$ = $<java.awt.Color>1;};
%%
class MyPos {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/java.at:787: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:787"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:787"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/java.at:787: bison --xml=xml-tests/test.xml YYParser.y"
at_fn_check_prepare_trace "java.at:787"
( $at_check_trace; bison --xml=xml-tests/test.xml YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:787"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/java.at:787: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:787"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:787"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/java.at:787: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "java.at:787"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:787"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/java.at:787: bison YYParser.y"
at_fn_check_prepare_trace "java.at:787"
( $at_check_trace; bison YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:787"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:787: grep '[mb]4_' YYParser.y"
at_fn_check_prepare_trace "java.at:787"
( $at_check_trace; grep '[mb]4_' YYParser.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:787"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:787: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
at_fn_check_prepare_notrace 'an embedded newline' "java.at:787"
( $at_check_trace; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/java.at:787"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:787: \$SHELL ../../../javacomp.sh YYParser.java"
at_fn_check_prepare_dynamic "$SHELL ../../../javacomp.sh YYParser.java" "java.at:787"
( $at_check_trace; $SHELL ../../../javacomp.sh YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:787"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/java.at:795: grep 'java.awt.Color' YYParser.java"
at_fn_check_prepare_trace "java.at:795"
( $at_check_trace; grep 'java.awt.Color' YYParser.java
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java.at:795"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:796: \$EGREP -v ' */?\\*' YYParser.java | grep 'Position'"
at_fn_check_prepare_notrace 'a shell pipeline' "java.at:796"
( $at_check_trace; $EGREP -v ' */?\*' YYParser.java | grep 'Position'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:796"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java.at:797: \$EGREP -v ' */?\\*' YYParser.java | grep 'Location'"
at_fn_check_prepare_notrace 'a shell pipeline' "java.at:797"
( $at_check_trace; $EGREP -v ' */?\*' YYParser.java | grep 'Location'
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 1 $at_status "$at_srcdir/java.at:797"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_278
#AT_START_279
at_fn_group_banner 279 'cxx-type.at:414' \
  "GLR: Resolve ambiguity, impure, no locations" "   " 21
at_xfail=no
(
  $as_echo "279. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */



%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *

  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/cxx-type.at:415: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
at_fn_check_prepare_notrace 'an embedded newline' "cxx-type.at:415"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:415"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/cxx-type.at:415: bison --xml=xml-tests/test.xml -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:415"
( $at_check_trace; bison --xml=xml-tests/test.xml -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:415"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:415: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:415"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:415"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:415: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:415"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:415"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/cxx-type.at:415: bison -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:415"
( $at_check_trace; bison -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:415"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cxx-type.at:415: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS" "cxx-type.at:415"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:415"
$at_failed && at_fn_log_failure
$at_traceon; }






























{ set +x
$as_echo "$at_srcdir/cxx-type.at:417:  \$PREPARSER ./types test-input"
at_fn_check_prepare_dynamic " $PREPARSER ./types test-input" "cxx-type.at:417"
( $at_check_trace;  $PREPARSER ./types test-input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<declare>(T,x)
<init-declare>(T,y,+(z,q))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:417"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_279
#AT_START_280
at_fn_group_banner 280 'cxx-type.at:421' \
  "GLR: Resolve ambiguity, impure, locations" "      " 21
at_xfail=no
(
  $as_echo "280. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%locations

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *

  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/cxx-type.at:422: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
at_fn_check_prepare_notrace 'an embedded newline' "cxx-type.at:422"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:422"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/cxx-type.at:422: bison --xml=xml-tests/test.xml -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:422"
( $at_check_trace; bison --xml=xml-tests/test.xml -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:422"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:422: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:422"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:422"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:422: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:422"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:422"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/cxx-type.at:422: bison -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:422"
( $at_check_trace; bison -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:422"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cxx-type.at:422: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS" "cxx-type.at:422"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:422"
$at_failed && at_fn_log_failure
$at_traceon; }






























{ set +x
$as_echo "$at_srcdir/cxx-type.at:423:  \$PREPARSER ./types test-input"
at_fn_check_prepare_dynamic " $PREPARSER ./types test-input" "cxx-type.at:423"
( $at_check_trace;  $PREPARSER ./types test-input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3.0-3.5: +(z,q)
5.0-5.3: <declare>(T,x)
7.0-7.7: <init-declare>(T,x,y)
9.0-9.5: =(x,y)
11.0-11.9: +(<cast>(x,T),y)
13.0-13.5: <declare>(T,x)
15.0-15.13: <init-declare>(T,y,+(z,q))
17.0-17.15: <error>
19.0-19.5: +(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:423"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_280
#AT_START_281
at_fn_group_banner 281 'cxx-type.at:427' \
  "GLR: Resolve ambiguity, pure, no locations" "     " 21
at_xfail=no
(
  $as_echo "281. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%define api.pure

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *

  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/cxx-type.at:428: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
at_fn_check_prepare_notrace 'an embedded newline' "cxx-type.at:428"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:428"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/cxx-type.at:428: bison --xml=xml-tests/test.xml -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:428"
( $at_check_trace; bison --xml=xml-tests/test.xml -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:428"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:428: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:428"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:428"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:428: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:428"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:428"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/cxx-type.at:428: bison -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:428"
( $at_check_trace; bison -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:428"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cxx-type.at:428: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS" "cxx-type.at:428"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:428"
$at_failed && at_fn_log_failure
$at_traceon; }






























{ set +x
$as_echo "$at_srcdir/cxx-type.at:430:  \$PREPARSER ./types test-input"
at_fn_check_prepare_dynamic " $PREPARSER ./types test-input" "cxx-type.at:430"
( $at_check_trace;  $PREPARSER ./types test-input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<declare>(T,x)
<init-declare>(T,y,+(z,q))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:430"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_281
#AT_START_282
at_fn_group_banner 282 'cxx-type.at:434' \
  "GLR: Resolve ambiguity, pure, locations" "        " 21
at_xfail=no
(
  $as_echo "282. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%define api.pure %locations

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *

  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/cxx-type.at:435: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
at_fn_check_prepare_notrace 'an embedded newline' "cxx-type.at:435"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:435"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/cxx-type.at:435: bison --xml=xml-tests/test.xml -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:435"
( $at_check_trace; bison --xml=xml-tests/test.xml -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:435"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:435: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:435"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:435"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:435: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:435"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:435"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/cxx-type.at:435: bison -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:435"
( $at_check_trace; bison -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:435"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cxx-type.at:435: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS" "cxx-type.at:435"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:435"
$at_failed && at_fn_log_failure
$at_traceon; }






























{ set +x
$as_echo "$at_srcdir/cxx-type.at:437:  \$PREPARSER ./types test-input"
at_fn_check_prepare_dynamic " $PREPARSER ./types test-input" "cxx-type.at:437"
( $at_check_trace;  $PREPARSER ./types test-input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3.0-3.5: +(z,q)
5.0-5.3: <declare>(T,x)
7.0-7.7: <init-declare>(T,x,y)
9.0-9.5: =(x,y)
11.0-11.9: +(<cast>(x,T),y)
13.0-13.5: <declare>(T,x)
15.0-15.13: <init-declare>(T,y,+(z,q))
17.0-17.15: <error>
19.0-19.5: +(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:437"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_282
#AT_START_283
at_fn_group_banner 283 'cxx-type.at:441' \
  "GLR: Merge conflicting parses, impure, no locations" "" 21
at_xfail=no
(
  $as_echo "283. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */



%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/cxx-type.at:442: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
at_fn_check_prepare_notrace 'an embedded newline' "cxx-type.at:442"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:442"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/cxx-type.at:442: bison --xml=xml-tests/test.xml -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:442"
( $at_check_trace; bison --xml=xml-tests/test.xml -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:442"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:442: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:442"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:442"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:442: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:442"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:442"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/cxx-type.at:442: bison -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:442"
( $at_check_trace; bison -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:442"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cxx-type.at:442: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS" "cxx-type.at:442"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:442"
$at_failed && at_fn_log_failure
$at_traceon; }






























{ set +x
$as_echo "$at_srcdir/cxx-type.at:444:  \$PREPARSER ./types test-input"
at_fn_check_prepare_dynamic " $PREPARSER ./types test-input" "cxx-type.at:444"
( $at_check_trace;  $PREPARSER ./types test-input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<OR>(<declare>(T,x),<cast>(x,T))
<OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:444"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_283
#AT_START_284
at_fn_group_banner 284 'cxx-type.at:448' \
  "GLR: Merge conflicting parses, impure, locations" "" 21
at_xfail=no
(
  $as_echo "284. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%locations

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/cxx-type.at:449: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
at_fn_check_prepare_notrace 'an embedded newline' "cxx-type.at:449"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:449"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/cxx-type.at:449: bison --xml=xml-tests/test.xml -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:449"
( $at_check_trace; bison --xml=xml-tests/test.xml -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:449"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:449: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:449"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:449"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:449: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:449"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:449"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/cxx-type.at:449: bison -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:449"
( $at_check_trace; bison -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:449"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cxx-type.at:449: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS" "cxx-type.at:449"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:449"
$at_failed && at_fn_log_failure
$at_traceon; }






























{ set +x
$as_echo "$at_srcdir/cxx-type.at:451:  \$PREPARSER ./types test-input"
at_fn_check_prepare_dynamic " $PREPARSER ./types test-input" "cxx-type.at:451"
( $at_check_trace;  $PREPARSER ./types test-input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3.0-3.5: +(z,q)
5.0-5.3: <declare>(T,x)
7.0-7.7: <init-declare>(T,x,y)
9.0-9.5: =(x,y)
11.0-11.9: +(<cast>(x,T),y)
13.0-13.5: <OR>(<declare>(T,x),<cast>(x,T))
15.0-15.13: <OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
17.0-17.15: <error>
19.0-19.5: +(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:451"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_284
#AT_START_285
at_fn_group_banner 285 'cxx-type.at:455' \
  "GLR: Merge conflicting parses, pure, no locations" "" 21
at_xfail=no
(
  $as_echo "285. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%define api.pure

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/cxx-type.at:456: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
at_fn_check_prepare_notrace 'an embedded newline' "cxx-type.at:456"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:456"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/cxx-type.at:456: bison --xml=xml-tests/test.xml -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:456"
( $at_check_trace; bison --xml=xml-tests/test.xml -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:456"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:456: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:456"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:456"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:456: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:456"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:456"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/cxx-type.at:456: bison -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:456"
( $at_check_trace; bison -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:456"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cxx-type.at:456: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS" "cxx-type.at:456"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:456"
$at_failed && at_fn_log_failure
$at_traceon; }






























{ set +x
$as_echo "$at_srcdir/cxx-type.at:458:  \$PREPARSER ./types test-input"
at_fn_check_prepare_dynamic " $PREPARSER ./types test-input" "cxx-type.at:458"
( $at_check_trace;  $PREPARSER ./types test-input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<OR>(<declare>(T,x),<cast>(x,T))
<OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:458"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_285
#AT_START_286
at_fn_group_banner 286 'cxx-type.at:461' \
  "GLR: Merge conflicting parses, pure, locations" " " 21
at_xfail=no
(
  $as_echo "286. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%define api.pure %locations

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/cxx-type.at:462: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
at_fn_check_prepare_notrace 'an embedded newline' "cxx-type.at:462"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:462"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/cxx-type.at:462: bison --xml=xml-tests/test.xml -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:462"
( $at_check_trace; bison --xml=xml-tests/test.xml -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:462"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:462: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:462"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:462"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:462: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:462"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:462"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/cxx-type.at:462: bison -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:462"
( $at_check_trace; bison -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:462"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cxx-type.at:462: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS" "cxx-type.at:462"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:462"
$at_failed && at_fn_log_failure
$at_traceon; }






























{ set +x
$as_echo "$at_srcdir/cxx-type.at:464:  \$PREPARSER ./types test-input"
at_fn_check_prepare_dynamic " $PREPARSER ./types test-input" "cxx-type.at:464"
( $at_check_trace;  $PREPARSER ./types test-input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3.0-3.5: +(z,q)
5.0-5.3: <declare>(T,x)
7.0-7.7: <init-declare>(T,x,y)
9.0-9.5: =(x,y)
11.0-11.9: +(<cast>(x,T),y)
13.0-13.5: <OR>(<declare>(T,x),<cast>(x,T))
15.0-15.13: <OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
17.0-17.15: <error>
19.0-19.5: +(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:464"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_286
#AT_START_287
at_fn_group_banner 287 'cxx-type.at:468' \
  "GLR: Verbose messages, resolve ambiguity, impure, no locations" "" 21
at_xfail=no
(
  $as_echo "287. $at_setup_line: testing $at_desc ..."
  $at_traceon







# Using yacc.c?










# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











# Handle the different types of location components.










cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%error-verbose

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/cxx-type.at:469: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
at_fn_check_prepare_notrace 'an embedded newline' "cxx-type.at:469"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:469"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/cxx-type.at:469: bison --xml=xml-tests/test.xml -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:469"
( $at_check_trace; bison --xml=xml-tests/test.xml -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:469"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:469: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:469"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:469"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/cxx-type.at:469: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "cxx-type.at:469"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:469"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/cxx-type.at:469: bison -o types.c types.y"
at_fn_check_prepare_trace "cxx-type.at:469"
( $at_check_trace; bison -o types.c types.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:469"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cxx-type.at:469: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS" "cxx-type.at:469"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:469"
$at_failed && at_fn_log_failure
$at_traceon; }






























{ set +x
$as_echo "$at_srcdir/cxx-type.at:471:  \$PREPARSER ./types test-input"
at_fn_check_prepare_dynamic " $PREPARSER ./types test-input" "cxx-type.at:471"
( $at_check_trace;  $PREPARSER ./types test-input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error, unexpected ID, expecting '=' or '+' or ')'
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<OR>(<declare>(T,x),<cast>(x,T))
<OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/cxx-type.at:471"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_287
#AT_START_288
at_fn_group_banner 288 'glr-regression.at:25' \
  "Badly Collapsed GLR States" "                     " 22
at_xfail=no
(
  $as_echo "288. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr1.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Regression Test: Improper state compression */
/* Reported by Scott McPeak */

%{
#include <stdio.h>
#include <stdlib.h>

#define YYSTYPE int
static YYSTYPE exprMerge (YYSTYPE x0, YYSTYPE x1);
int yylex (void);
void yyerror (char const *msg);
%}


%glr-parser


/* -------- productions ------ */
%%

StartSymbol: E  { $$=0; }                   %merge <exprMerge>
           ;

E: E 'P' E { $$=1; printf("E -> E 'P' E\n"); }  %merge <exprMerge>
 | 'B'     { $$=2; printf("E -> 'B'\n"); }      %merge <exprMerge>
 ;



/* ---------- C code ----------- */
%%

static YYSTYPE exprMerge (YYSTYPE x0, YYSTYPE x1)
{
  (void) x0;
  (void) x1;
  printf ("<OR>\n");
  return 0;
}

int
main (void)
{
  return yyparse ();
}

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}


int
yylex (void)
{
  for (;;)
    {
      int ch;
      if (feof (stdin))
	abort ();
      ch = getchar ();
      if (ch == EOF)
	return 0;
      else if (ch == 'B' || ch == 'P')
	return ch;
    }
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:98: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr1.c glr-regr1.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:98"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr1.c glr-regr1.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:98: bison --xml=xml-tests/test.xml -o glr-regr1.c glr-regr1.y"
at_fn_check_prepare_trace "glr-regression.at:98"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr1.c glr-regr1.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:98: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:98"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:98: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:98"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:98: bison -o glr-regr1.c glr-regr1.y"
at_fn_check_prepare_trace "glr-regression.at:98"
( $at_check_trace; bison -o glr-regr1.c glr-regr1.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr1.y: conflicts: 1 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:98"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:101: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr1 glr-regr1.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr1 glr-regr1.c $LIBS" "glr-regression.at:101"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr1 glr-regr1.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:101"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:102:  \$PREPARSER echo BPBPB | ./glr-regr1"
at_fn_check_prepare_notrace 'a shell pipeline' "glr-regression.at:102"
( $at_check_trace;  $PREPARSER echo BPBPB | ./glr-regr1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "E -> 'B'
E -> 'B'
E -> E 'P' E
E -> 'B'
E -> E 'P' E
E -> 'B'
E -> E 'P' E
E -> E 'P' E
<OR>
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:102"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_288
#AT_START_289
at_fn_group_banner 289 'glr-regression.at:120' \
  "Improper handling of embedded actions and dollar(-N) in GLR parsers" "" 22
at_xfail=no
(
  $as_echo "289. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr2a.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Regression Test: Improper handling of embedded actions and $-N  */
/* Reported by S. Eken */

%{
  #define YYSTYPE char *

  #include <ctype.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  int yylex (void);
  void yyerror (char const *);
%}

%glr-parser

%%

command:
    's' var 't'
       { printf ("Variable: '%s'\n", $2); }
    'v' 'x' 'q'
       { free ($2); }
  | 's' var_list 't' 'e'
       { printf ("Varlist: '%s'\n", $2); free ($2); }
  | 's' var 't' var_printer 'x'
       { free ($2); }
  ;

var:
  'V'
     { $$ = $1; }
  ;

var_list:
  var
    { $$ = $1; }
  | var ',' var_list
    {
      char *s = (char *) realloc ($1, strlen ($1) + 1 + strlen ($3) + 1);
      strcat (s, ",");
      strcat (s, $3);
      free ($3);
      $$ = s;
    }
  ;

var_printer: 'v'
   { printf ("Variable: '%s'\n", $-1); }

%%

FILE *input;

int
yylex (void)
{
  char buf[50];
  char *s;
  if (feof (stdin))
    abort ();
  switch (fscanf (input, " %1[a-z,]", buf)) {
  case 1:
    return buf[0];
  case EOF:
    return 0;
  default:
    break;
  }
  if (fscanf (input, "%49s", buf) != 1)
    return 0;
  if (sizeof buf - 1 <= strlen (buf))
    abort ();
  s = (char *) malloc (strlen (buf) + 1);
  strcpy (s, buf);
  yylval = s;
  return 'V';
}

void
yyerror (char const *s)
{ printf ("%s\n", s);
}

int
main (int argc, char **argv)
{
  input = stdin;
  if (argc == 2 && !(input = fopen (argv[1], "r"))) return 3;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:216: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr2a.c glr-regr2a.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:216"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr2a.c glr-regr2a.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:216"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:216: bison --xml=xml-tests/test.xml -o glr-regr2a.c glr-regr2a.y"
at_fn_check_prepare_trace "glr-regression.at:216"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr2a.c glr-regr2a.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:216"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:216: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:216"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:216"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:216: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:216"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:216"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:216: bison -o glr-regr2a.c glr-regr2a.y"
at_fn_check_prepare_trace "glr-regression.at:216"
( $at_check_trace; bison -o glr-regr2a.c glr-regr2a.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr2a.y: conflicts: 2 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:216"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:219: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr2a glr-regr2a.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr2a glr-regr2a.c $LIBS" "glr-regression.at:219"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr2a glr-regr2a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:219"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:221:  \$PREPARSER echo s VARIABLE_1 t v x q | ./glr-regr2a"
at_fn_check_prepare_notrace 'a shell pipeline' "glr-regression.at:221"
( $at_check_trace;  $PREPARSER echo s VARIABLE_1 t v x q | ./glr-regr2a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Variable: 'VARIABLE_1'
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:221"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:224:  \$PREPARSER echo s VARIABLE_1 , ANOTHER_VARIABLE_2 t e | ./glr-regr2a"
at_fn_check_prepare_notrace 'a shell pipeline' "glr-regression.at:224"
( $at_check_trace;  $PREPARSER echo s VARIABLE_1 , ANOTHER_VARIABLE_2 t e | ./glr-regr2a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Varlist: 'VARIABLE_1,ANOTHER_VARIABLE_2'
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:224"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:228:  \$PREPARSER echo s VARIABLE_3 t v x | ./glr-regr2a"
at_fn_check_prepare_notrace 'a shell pipeline' "glr-regression.at:228"
( $at_check_trace;  $PREPARSER echo s VARIABLE_3 t v x | ./glr-regr2a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Variable: 'VARIABLE_3'
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }



  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_289
#AT_START_290
at_fn_group_banner 290 'glr-regression.at:239' \
  "Improper merging of GLR delayed action sets" "    " 22
at_xfail=no
(
  $as_echo "290. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr3.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Regression Test: Improper merging of GLR delayed action sets.  */
/* Reported by M. Rosien */

%{
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

static int MergeRule (int x0, int x1);
static void yyerror (char const * s);
int yylex (void);

#define RULE(x) (1 << (x))

%}

%glr-parser

%token BAD_CHAR
%token P1 P2 T1 T2 T3 T4 O1 O2

%%

S : P1 T4 O2 NT6 P2  { printf ("Result: %x\n", $4); }
;

NT1 : P1 T1 O1 T2 P2 { $$ = RULE(2); }  %merge<MergeRule>
;

NT2 : NT1             { $$ = RULE(3); } %merge<MergeRule>
    | P1 NT1 O1 T3 P2 { $$ = RULE(4); } %merge<MergeRule>
;

NT3 : T3              { $$ = RULE(5); } %merge<MergeRule>
    | P1 NT1 O1 T3 P2 { $$ = RULE(6); } %merge<MergeRule>
;

NT4 : NT3              { $$ = RULE(7); } %merge<MergeRule>
    | NT2              { $$ = RULE(8); } %merge<MergeRule>
    | P1 NT2 O1 NT3 P2 { $$ = RULE(9); } %merge<MergeRule>
;

NT5 : NT4              { $$ = RULE(10); } %merge<MergeRule>
;

NT6 : P1 NT1 O1 T3 P2  { $$ = RULE(11) | $2; } %merge<MergeRule>
    | NT5              { $$ = RULE(12) | $1; } %merge<MergeRule>
;

%%

static int MergeRule (int x0, int x1) {
  return x0 | x1;
}

static void yyerror(char const * s) {
  fprintf(stderr,"error: %s\n",s);
}

FILE *input = NULL;

int P[] = { P1, P2 };
int O[] = { O1, O2 };
int T[] = { T1, T2, T3, T4 };

int yylex (void)
{
  char inp[3];
  if (feof (stdin))
    abort ();
  if (fscanf (input, "%2s", inp) == EOF)
    return 0;
  switch (inp[0])
    {
    case 'p': return P[inp[1] - '1'];
    case 't': return T[inp[1] - '1'];
    case 'o': return O[inp[1] - '1'];
    }
  return BAD_CHAR;
}

int main(int argc, char* argv[]) {
  input = stdin;
  if (argc == 2 && !(input = fopen (argv[1], "r"))) return 3;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:330: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr3.c glr-regr3.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:330"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr3.c glr-regr3.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:330"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:330: bison --xml=xml-tests/test.xml -o glr-regr3.c glr-regr3.y"
at_fn_check_prepare_trace "glr-regression.at:330"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr3.c glr-regr3.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:330"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:330: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:330"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:330"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:330: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:330"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:330"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:330: bison -o glr-regr3.c glr-regr3.y"
at_fn_check_prepare_trace "glr-regression.at:330"
( $at_check_trace; bison -o glr-regr3.c glr-regr3.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr3.y: conflicts: 1 shift/reduce, 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:330"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:333: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr3 glr-regr3.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr3 glr-regr3.c $LIBS" "glr-regression.at:333"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr3 glr-regr3.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:333"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:335:  \$PREPARSER echo p1 t4 o2 p1 p1 t1 o1 t2 p2 o1 t3 p2 p2 | ./glr-regr3"
at_fn_check_prepare_notrace 'a shell pipeline' "glr-regression.at:335"
( $at_check_trace;  $PREPARSER echo p1 t4 o2 p1 p1 t1 o1 t2 p2 o1 t3 p2 p2 | ./glr-regr3
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Result: 1c04
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:335"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_290
#AT_START_291
at_fn_group_banner 291 'glr-regression.at:348' \
  "Duplicate representation of merged trees" "       " 22
at_xfail=no
(
  $as_echo "291. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr4.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%union { char *ptr; }
%type <ptr> S A A1 A2 B
%glr-parser

%{
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  static char *merge (YYSTYPE, YYSTYPE);
  static char *make_value (char const *, char const *);
  static void yyerror (char const *);
  static int yylex (void);
  static char *ptrs[100];
  static char **ptrs_next = ptrs;
%}

%%

tree: S { printf ("%s\n", $1); } ;

S:
  A   %merge<merge> { $$ = make_value ("S", $1); }
  | B %merge<merge> { $$ = make_value ("S", $1); }
  ;

A:
  A1   %merge<merge> { $$ = make_value ("A", $1); }
  | A2 %merge<merge> { $$ = make_value ("A", $1); }
  ;

A1: 'a' { $$ = make_value ("A1", "'a'"); } ;
A2: 'a' { $$ = make_value ("A2", "'a'"); } ;
B:  'a' { $$ = make_value ("B", "'a'");  } ;

%%

static int
yylex (void)
{
  static char const input[] = "a";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

int
main (void)
{
  int status = yyparse ();
  while (ptrs_next != ptrs)
    free (*--ptrs_next);
  return status;
}

static char *
make_value (char const *parent, char const *child)
{
  char const format[] = "%s <- %s";
  char *value = *ptrs_next++ =
    (char *) malloc (strlen (parent) + strlen (child) + sizeof format);
  sprintf (value, format, parent, child);
  return value;
}

static char *
merge (YYSTYPE s1, YYSTYPE s2)
{
  char const format[] = "merge{ %s and %s }";
  char *value = *ptrs_next++ =
    (char *) malloc (strlen (s1.ptr) + strlen (s2.ptr) + sizeof format);
  sprintf (value, format, s1.ptr, s2.ptr);
  return value;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:434: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr4.c glr-regr4.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:434"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr4.c glr-regr4.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:434"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:434: bison --xml=xml-tests/test.xml -o glr-regr4.c glr-regr4.y"
at_fn_check_prepare_trace "glr-regression.at:434"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr4.c glr-regr4.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:434"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:434: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:434"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:434"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:434: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:434"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:434"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:434: bison -o glr-regr4.c glr-regr4.y"
at_fn_check_prepare_trace "glr-regression.at:434"
( $at_check_trace; bison -o glr-regr4.c glr-regr4.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr4.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:434"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:437: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr4 glr-regr4.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr4 glr-regr4.c $LIBS" "glr-regression.at:437"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr4 glr-regr4.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:437"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:439:  \$PREPARSER ./glr-regr4"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr4" "glr-regression.at:439"
( $at_check_trace;  $PREPARSER ./glr-regr4
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "merge{ S <- merge{ A <- A1 <- 'a' and A <- A2 <- 'a' } and S <- B <- 'a' }
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:439"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_291
#AT_START_292
at_fn_group_banner 292 'glr-regression.at:451' \
  "User destructor for unresolved GLR semantic value" "" 22
at_xfail=no
(
  $as_echo "292. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr5.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <stdio.h>
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  enum { MAGIC_VALUE = -1057808125 }; /* originally chosen at random */
%}

%glr-parser
%union { int value; }
%type <value> start

%destructor {
  if ($$ != MAGIC_VALUE)
    {
      fprintf (stderr, "Bad destructor call.\n");
      exit (EXIT_FAILURE);
    }
} start

%%

start:
   'a' { $$ = MAGIC_VALUE; }
   | 'a' { $$ = MAGIC_VALUE; }
   ;

%%

static int
yylex (void)
{
  static char const input[] = "a";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse () != 1;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:507: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr5.c glr-regr5.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:507"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr5.c glr-regr5.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:507"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:507: bison --xml=xml-tests/test.xml -o glr-regr5.c glr-regr5.y"
at_fn_check_prepare_trace "glr-regression.at:507"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr5.c glr-regr5.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:507"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:507: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:507"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:507"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:507: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:507"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:507"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:507: bison -o glr-regr5.c glr-regr5.y"
at_fn_check_prepare_trace "glr-regression.at:507"
( $at_check_trace; bison -o glr-regr5.c glr-regr5.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr5.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:507"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:510: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr5 glr-regr5.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr5 glr-regr5.c $LIBS" "glr-regression.at:510"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr5 glr-regr5.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:510"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:512:  \$PREPARSER ./glr-regr5"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr5" "glr-regression.at:512"
( $at_check_trace;  $PREPARSER ./glr-regr5
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax is ambiguous
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:512"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_292
#AT_START_293
at_fn_group_banner 293 'glr-regression.at:524' \
  "User destructor after an error during a split parse" "" 22
at_xfail=no
(
  $as_echo "293. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr6.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <stdio.h>
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
%}

%glr-parser
%union { int value; }
%type <value> 'a'

%destructor {
  printf ("Destructor called.\n");
} 'a'

%%

start: 'a' | 'a' ;

%%

static int
yylex (void)
{
  static char const input[] = "a";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse () != 1;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:572: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr6.c glr-regr6.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:572"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr6.c glr-regr6.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:572: bison --xml=xml-tests/test.xml -o glr-regr6.c glr-regr6.y"
at_fn_check_prepare_trace "glr-regression.at:572"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr6.c glr-regr6.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:572: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:572"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:572: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:572"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:572: bison -o glr-regr6.c glr-regr6.y"
at_fn_check_prepare_trace "glr-regression.at:572"
( $at_check_trace; bison -o glr-regr6.c glr-regr6.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr6.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:575: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr6 glr-regr6.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr6 glr-regr6.c $LIBS" "glr-regression.at:575"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr6 glr-regr6.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:575"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:577:  \$PREPARSER ./glr-regr6"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr6" "glr-regression.at:577"
( $at_check_trace;  $PREPARSER ./glr-regr6
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax is ambiguous
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Destructor called.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_293
#AT_START_294
at_fn_group_banner 294 'glr-regression.at:591' \
  "Duplicated user destructor for lookahead" "       " 22
at_xfail=no
(
  $as_echo "294. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr7.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <stdio.h>
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  #define YYSTACKEXPANDABLE 0
  typedef struct count_node {
    int count;
    struct count_node *prev;
  } count_node;
  static count_node *tail;
%}

%glr-parser
%union { count_node *node; }
%type <node> 'a'

%destructor {
  if ($$->count++)
    fprintf (stderr, "Destructor called on same value twice.\n");
} 'a'

%%

start:
    stack1 start
  | stack2 start
  | /* empty */
  ;
stack1: 'a' ;
stack2: 'a' ;

%%

static int
yylex (void)
{
  yylval.node = (count_node*) malloc (sizeof *yylval.node);
  if (!yylval.node)
    {
      fprintf (stderr, "Test inconclusive.\n");
      exit (EXIT_FAILURE);
    }
  yylval.node->count = 0;
  yylval.node->prev = tail;
  tail = yylval.node;
  return 'a';
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  int status = yyparse ();
  while (tail)
    {
      count_node *prev = tail->prev;
      free (tail);
      tail = prev;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:664: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr7.c glr-regr7.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:664"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr7.c glr-regr7.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:664: bison --xml=xml-tests/test.xml -o glr-regr7.c glr-regr7.y"
at_fn_check_prepare_trace "glr-regression.at:664"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr7.c glr-regr7.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:664: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:664"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:664: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:664"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:664: bison -o glr-regr7.c glr-regr7.y"
at_fn_check_prepare_trace "glr-regression.at:664"
( $at_check_trace; bison -o glr-regr7.c glr-regr7.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr7.y: conflicts: 2 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:664"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:667: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr7 glr-regr7.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr7 glr-regr7.c $LIBS" "glr-regression.at:667"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr7 glr-regr7.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:667"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:669:  \$PREPARSER ./glr-regr7"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr7" "glr-regression.at:669"
( $at_check_trace;  $PREPARSER ./glr-regr7
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "memory exhausted
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 2 $at_status "$at_srcdir/glr-regression.at:669"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_294
#AT_START_295
at_fn_group_banner 295 'glr-regression.at:683' \
  "Incorrectly initialized location for empty right-hand side in GLR" "" 22
at_xfail=no
(
  $as_echo "295. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr8.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <stdio.h>
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  static void yyerror (char const *msg);
%}

%token T_CONSTANT
%token T_PORT
%token T_SIGNAL

%glr-parser

%%


PortClause	: T_PORT InterfaceDeclaration T_PORT
		{ printf("%d/%d - %d/%d - %d/%d\n",
			 @1.first_column, @1.last_column,
			 @2.first_column, @2.last_column,
			 @3.first_column, @3.last_column); }
	;

InterfaceDeclaration	: OptConstantWord	%dprec 1
	| OptSignalWord	%dprec 2
	;

OptConstantWord	: /* empty */
	| T_CONSTANT
	;

OptSignalWord	: /* empty */
		{ printf("empty: %d/%d\n", @$.first_column, @$.last_column); }
	| T_SIGNAL
	;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int lexIndex;

int yylex (void)
{
  lexIndex += 1;
  switch (lexIndex)
    {
    default:
      abort ();
    case 1:
      yylloc.first_column = 1;
      yylloc.last_column = 9;
      return T_PORT;
    case 2:
      yylloc.first_column = 13;
      yylloc.last_column = 17;
      return T_PORT;
    case 3:
      return 0;
    }
}

int
main (void)
{
  yyparse();
  return 0;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:762: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr8.c glr-regr8.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:762"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr8.c glr-regr8.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:762: bison --xml=xml-tests/test.xml -o glr-regr8.c glr-regr8.y"
at_fn_check_prepare_trace "glr-regression.at:762"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr8.c glr-regr8.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:762: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:762"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:762: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:762"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:762: bison -o glr-regr8.c glr-regr8.y"
at_fn_check_prepare_trace "glr-regression.at:762"
( $at_check_trace; bison -o glr-regr8.c glr-regr8.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr8.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:762"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:765: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr8 glr-regr8.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr8 glr-regr8.c $LIBS" "glr-regression.at:765"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr8 glr-regr8.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:765"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:767:  \$PREPARSER ./glr-regr8"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr8" "glr-regression.at:767"
( $at_check_trace;  $PREPARSER ./glr-regr8
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "empty: 9/9
1/9 - 9/9 - 13/17
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:767"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_295
#AT_START_296
at_fn_group_banner 296 'glr-regression.at:781' \
  "No users destructors if stack 0 deleted" "        " 22
at_xfail=no
(
  $as_echo "296. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr9.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
# define YYSTACKEXPANDABLE 0
  static int tokens = 0;
  static int destructors = 0;
# define USE(Var)
%}

%glr-parser
%union { int dummy; }
%type <dummy> 'a'

%destructor {
  destructors += 1;
} 'a'

%%

start:
    ambig0 'a'   { destructors += 2; USE ($2); }
  | ambig1 start { destructors += 1; }
  | ambig2 start { destructors += 1; }
  ;

ambig0: 'a' ;
ambig1: 'a' ;
ambig2: 'a' ;

%%

static int
yylex (void)
{
  tokens += 1;
  return 'a';
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  int exit_status;
  exit_status = yyparse ();
  if (tokens != destructors)
    {
      fprintf (stderr, "Tokens = %d, Destructors = %d\n", tokens, destructors);
      return 1;
    }
  return !exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:845: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr9.c glr-regr9.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:845"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr9.c glr-regr9.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:845"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:845: bison --xml=xml-tests/test.xml -o glr-regr9.c glr-regr9.y"
at_fn_check_prepare_trace "glr-regression.at:845"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr9.c glr-regr9.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:845"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:845: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:845"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:845"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:845: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:845"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:845"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:845: bison -o glr-regr9.c glr-regr9.y"
at_fn_check_prepare_trace "glr-regression.at:845"
( $at_check_trace; bison -o glr-regr9.c glr-regr9.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr9.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:845"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:848: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr9 glr-regr9.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr9 glr-regr9.c $LIBS" "glr-regression.at:848"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr9 glr-regr9.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:848"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:850:  \$PREPARSER ./glr-regr9"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr9" "glr-regression.at:850"
( $at_check_trace;  $PREPARSER ./glr-regr9
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "memory exhausted
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:850"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_296
#AT_START_297
at_fn_group_banner 297 'glr-regression.at:861' \
  "Corrupted semantic options if user action cuts parse" "" 22
at_xfail=no
(
  $as_echo "297. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr10.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
# include <stdlib.h>
# include <stdio.h>
  static void yyerror (char const *);
  static int yylex (void);
  #define GARBAGE_SIZE 50
  static char garbage[GARBAGE_SIZE];
%}

%glr-parser
%union { char *ptr; }
%type <ptr> start

%%

start:
    %dprec 2 { $$ = garbage; YYACCEPT; }
  | %dprec 1 { $$ = garbage; YYACCEPT; }
  ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

int
main (void)
{
  int i;
  for (i = 0; i < GARBAGE_SIZE; i+=1)
    garbage[i] = 108;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:912: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr10.c glr-regr10.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:912"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr10.c glr-regr10.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:912"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:912: bison --xml=xml-tests/test.xml -o glr-regr10.c glr-regr10.y"
at_fn_check_prepare_trace "glr-regression.at:912"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr10.c glr-regr10.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:912"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:912: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:912"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:912"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:912: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:912"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:912"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:912: bison -o glr-regr10.c glr-regr10.y"
at_fn_check_prepare_trace "glr-regression.at:912"
( $at_check_trace; bison -o glr-regr10.c glr-regr10.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr10.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:912"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:915: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr10 glr-regr10.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr10 glr-regr10.c $LIBS" "glr-regression.at:915"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr10 glr-regr10.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:915"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:917:  \$PREPARSER ./glr-regr10"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr10" "glr-regression.at:917"
( $at_check_trace;  $PREPARSER ./glr-regr10
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:917"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_297
#AT_START_298
at_fn_group_banner 298 'glr-regression.at:926' \
  "Undesirable destructors if user action cuts parse" "" 22
at_xfail=no
(
  $as_echo "298. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr11.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
# include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  static int destructors = 0;
# define USE(val)
%}

%glr-parser
%union { int dummy; }
%type <int> 'a'
%destructor { destructors += 1; } 'a'

%%

start:
    'a' %dprec 2 { USE ($1); destructors += 1; YYACCEPT; }
  | 'a' %dprec 1 { USE ($1); destructors += 1; YYACCEPT; }
  ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static char const input[] = "a";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

int
main (void)
{
  int exit_status = yyparse ();
  if (destructors != 1)
    {
      fprintf (stderr, "Destructor calls: %d\n", destructors);
      return 1;
    }
  return exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:981: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr11.c glr-regr11.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:981"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr11.c glr-regr11.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:981"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:981: bison --xml=xml-tests/test.xml -o glr-regr11.c glr-regr11.y"
at_fn_check_prepare_trace "glr-regression.at:981"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr11.c glr-regr11.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:981"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:981: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:981"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:981"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:981: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:981"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:981"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:981: bison -o glr-regr11.c glr-regr11.y"
at_fn_check_prepare_trace "glr-regression.at:981"
( $at_check_trace; bison -o glr-regr11.c glr-regr11.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr11.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:981"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:984: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr11 glr-regr11.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr11 glr-regr11.c $LIBS" "glr-regression.at:984"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr11 glr-regr11.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:984"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:986:  \$PREPARSER ./glr-regr11"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr11" "glr-regression.at:986"
( $at_check_trace;  $PREPARSER ./glr-regr11
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:986"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_298
#AT_START_299
at_fn_group_banner 299 'glr-regression.at:995' \
  "Leaked semantic values if user action cuts parse" "" 22
at_xfail=no
(
  $as_echo "299. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr12.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%glr-parser
%union { int dummy; }
%token PARENT_RHS_AFTER
%type <dummy> parent_rhs_before merged PARENT_RHS_AFTER
%destructor { parent_rhs_before_value = 0; } parent_rhs_before
%destructor { merged_value = 0; } merged
%destructor { parent_rhs_after_value = 0; } PARENT_RHS_AFTER

%{
# include <stdlib.h>
  static int merge (YYSTYPE, YYSTYPE);
  static void yyerror (char const *);
  static int yylex (void);
  static int parent_rhs_before_value = 0;
  static int merged_value = 0;
  static int parent_rhs_after_value = 0;
# define USE(val)
%}

%%

start:
  alt1 %dprec 1
  | alt2 %dprec 2
  ;

alt1:
  PARENT_RHS_AFTER {
    USE ($1);
    parent_rhs_after_value = 0;
  }
  ;

alt2:
  parent_rhs_before merged PARENT_RHS_AFTER {
    USE (($1, $2, $3));
    parent_rhs_before_value = 0;
    merged_value = 0;
    parent_rhs_after_value = 0;
  }
  ;

parent_rhs_before:
  {
    USE ($$);
    parent_rhs_before_value = 1;
  }
  ;

merged:
  %merge<merge> {
    USE ($$);
    merged_value = 1;
  }
  | cut %merge<merge> {
    USE ($$);
    merged_value = 1;
  }
  ;

cut: { YYACCEPT; } ;

%%

static int
merge (YYSTYPE s1, YYSTYPE s2)
{
  /* Not invoked. */
  char dummy = s1.dummy + s2.dummy;
  return dummy;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = { PARENT_RHS_AFTER, 0 };
  static size_t toknum;
  if (! (toknum < sizeof input / sizeof *input))
    abort ();
  if (input[toknum] == PARENT_RHS_AFTER)
    parent_rhs_after_value = 1;
  return input[toknum++];
}

int
main (void)
{
  int exit_status = yyparse ();
  if (parent_rhs_before_value)
    {
      fprintf (stderr, "`parent_rhs_before' destructor not called.\n");
      exit_status = 1;
    }
  if (merged_value)
    {
      fprintf (stderr, "`merged' destructor not called.\n");
      exit_status = 1;
    }
  if (parent_rhs_after_value)
    {
      fprintf (stderr, "`PARENT_RHS_AFTER' destructor not called.\n");
      exit_status = 1;
    }
  return exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1112: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr12.c glr-regr12.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:1112"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr12.c glr-regr12.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1112"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:1112: bison --xml=xml-tests/test.xml -o glr-regr12.c glr-regr12.y"
at_fn_check_prepare_trace "glr-regression.at:1112"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr12.c glr-regr12.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1112"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1112: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1112"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1112"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1112: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1112"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1112"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:1112: bison -o glr-regr12.c glr-regr12.y"
at_fn_check_prepare_trace "glr-regression.at:1112"
( $at_check_trace; bison -o glr-regr12.c glr-regr12.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr12.y: conflicts: 1 shift/reduce, 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1112"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:1115: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr12 glr-regr12.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr12 glr-regr12.c $LIBS" "glr-regression.at:1115"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr12 glr-regr12.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1115"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:1117:  \$PREPARSER ./glr-regr12"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr12" "glr-regression.at:1117"
( $at_check_trace;  $PREPARSER ./glr-regr12
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1117"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_299
#AT_START_300
at_fn_group_banner 300 'glr-regression.at:1128' \
  "Incorrect lookahead during deterministic GLR" "   " 22
at_xfail=no
(
  $as_echo "300. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr13.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


/* Tests:
     - Defaulted state with initial yychar: yychar == YYEMPTY.
     - Nondefaulted state: yychar != YYEMPTY.
     - Defaulted state after lookahead: yychar != YYEMPTY.
     - Defaulted state after shift: yychar == YYEMPTY.
     - User action changing the lookahead.  */

%{
  #include <stdio.h>
  static void yyerror (char const *);
  static int yylex (void);
  static void print_lookahead (char const *);
  #define USE(value)
%}

%union { char value; }
%type <value> 'a' 'b'
%glr-parser
%locations

%%

start:
  defstate_init defstate_shift 'b' change_lookahead 'a' {
    USE ($3);
    print_lookahead ("start <- defstate_init defstate_shift 'b'");
  }
  ;
defstate_init:
  {
    print_lookahead ("defstate_init <- empty string");
  }
  ;
defstate_shift:
  nondefstate defstate_look 'a' {
    USE ($3);
    print_lookahead ("defstate_shift <- nondefstate defstate_look 'a'");
  }
  ;
defstate_look:
  {
    print_lookahead ("defstate_look <- empty string");
  }
  ;
nondefstate:
  {
    print_lookahead ("nondefstate <- empty string");
  }
  | 'b' {
    USE ($1);
    print_lookahead ("nondefstate <- 'b'");
  }
  ;
change_lookahead:
  {
    yychar = 'a';
  }
  ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static char const input[] = "ab";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = toknum + 1;
  yylval.value = input[toknum] + 'A' - 'a';
  return input[toknum++];
}

static void
print_lookahead (char const *reduction)
{
  printf ("%s:\n  yychar=", reduction);
  if (yychar == YYEMPTY)
    printf ("YYEMPTY");
  else if (yychar == YYEOF)
    printf ("YYEOF");
  else
    {
      printf ("'%c', yylval='", yychar);
      if (yylval.value > ' ')
	printf ("%c", yylval.value);
      printf ("', yylloc=(%d,%d),(%d,%d)",
	      yylloc.first_line, yylloc.first_column,
	      yylloc.last_line, yylloc.last_column);
    }
  printf ("\n");
}

int
main (void)
{
  yychar = '#'; /* Not a token in the grammar.  */
  yylval.value = '!';
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1241: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr13.c glr-regr13.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:1241"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr13.c glr-regr13.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1241"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:1241: bison --xml=xml-tests/test.xml -o glr-regr13.c glr-regr13.y"
at_fn_check_prepare_trace "glr-regression.at:1241"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr13.c glr-regr13.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1241"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1241: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1241"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1241"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1241: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1241"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1241"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:1241: bison -o glr-regr13.c glr-regr13.y"
at_fn_check_prepare_trace "glr-regression.at:1241"
( $at_check_trace; bison -o glr-regr13.c glr-regr13.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1241"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:1242: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr13 glr-regr13.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr13 glr-regr13.c $LIBS" "glr-regression.at:1242"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr13 glr-regr13.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1242"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:1244:  \$PREPARSER ./glr-regr13"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr13" "glr-regression.at:1244"
( $at_check_trace;  $PREPARSER ./glr-regr13
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "defstate_init <- empty string:
  yychar=YYEMPTY
nondefstate <- empty string:
  yychar='a', yylval='A', yylloc=(1,1),(1,1)
defstate_look <- empty string:
  yychar='a', yylval='A', yylloc=(1,1),(1,1)
defstate_shift <- nondefstate defstate_look 'a':
  yychar=YYEMPTY
start <- defstate_init defstate_shift 'b':
  yychar=YYEMPTY
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1244"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_300
#AT_START_301
at_fn_group_banner 301 'glr-regression.at:1264' \
  "Incorrect lookahead during nondeterministic GLR" "" 22
at_xfail=no
(
  $as_echo "301. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr14.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


/* Tests:
     - Conflicting actions (split-off parse, which copies lookahead need,
       which is necessarily yytrue) and nonconflicting actions (non-split-off
       parse) for nondefaulted state: yychar != YYEMPTY.
     - Merged deferred actions (lookahead need and RHS from different stack
       than the target state) and nonmerged deferred actions (same stack).
     - Defaulted state after lookahead: yychar != YYEMPTY.
     - Defaulted state after shift: yychar == YYEMPTY.
     - yychar != YYEMPTY but lookahead need is yyfalse (a previous stack has
       seen the lookahead but current stack has not).
     - Exceeding stack capacity (stack explosion), and thus reallocating
       lookahead need array.
   Note that it does not seem possible to see the initial yychar value during
   nondeterministic operation since:
     - In order to preserve the initial yychar, only defaulted states may be
       entered.
     - If only defaulted states are entered, there are no conflicts, so
       nondeterministic operation does not start.  */

%union { char value; }

%{
  #include <stdlib.h>
  #include <stdio.h>
  static void yyerror (char const *);
  static int yylex (void);
  static void print_lookahead (char const *);
  static char merge (union YYSTYPE, union YYSTYPE);
  #define USE(value)
%}

%type <value> 'a' 'b' 'c' 'd' stack_explosion
%glr-parser
%locations

%%

start:
  merge 'c' stack_explosion {
    USE ($2); USE ($3);
    print_lookahead ("start <- merge 'c' stack_explosion");
  }
  ;

/* When merging the 2 deferred actions, the lookahead needs are different.  */
merge:
  nonconflict1 'a' 'b' nonconflict2 %dprec 1 {
    USE ($2); USE ($3);
    print_lookahead ("merge <- nonconflict1 'a' 'b' nonconflict2");
  }
  | conflict defstate_look 'a' nonconflict2 'b' defstate_shift %dprec 2 {
    USE ($3); USE ($5);
    print_lookahead ("merge <- conflict defstate_look 'a' nonconflict2 'b'"
		      " defstate_shift");
  }
  ;

nonconflict1:
  {
    print_lookahead ("nonconflict1 <- empty string");
  }
  ;
nonconflict2:
  {
    print_lookahead ("nonconflict2 <- empty string");
  }
  | 'a' {
    USE ($1);
    print_lookahead ("nonconflict2 <- 'a'");
  }
  ;
conflict:
  {
    print_lookahead ("conflict <- empty string");
  }
  ;
defstate_look:
  {
    print_lookahead ("defstate_look <- empty string");
  }
  ;

/* yychar != YYEMPTY but lookahead need is yyfalse.  */
defstate_shift:
  {
    print_lookahead ("defstate_shift <- empty string");
  }
  ;

stack_explosion:
  { $$ = '\0'; }
  | alt1 stack_explosion %merge<merge> { $$ = $2; }
  | alt2 stack_explosion %merge<merge> { $$ = $2; }
  | alt3 stack_explosion %merge<merge> { $$ = $2; }
  ;
alt1:
  'd' no_look {
    USE ($1);
    if (yychar != 'd' && yychar != YYEOF)
      {
	fprintf (stderr, "Incorrect lookahead during stack explosion.\n");
      }
  }
  ;
alt2:
  'd' no_look {
    USE ($1);
    if (yychar != 'd' && yychar != YYEOF)
      {
	fprintf (stderr, "Incorrect lookahead during stack explosion.\n");
      }
  }
  ;
alt3:
  'd' no_look {
    USE ($1);
    if (yychar != 'd' && yychar != YYEOF)
      {
	fprintf (stderr, "Incorrect lookahead during stack explosion.\n");
      }
  }
  ;
no_look:
  {
    if (yychar != YYEMPTY)
      {
	fprintf (stderr,
		 "Found lookahead where shouldn't during stack explosion.\n");
      }
  }
  ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static char const input[] = "abcdddd";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = toknum + 1;
  yylval.value = input[toknum] + 'A' - 'a';
  return input[toknum++];
}

static void
print_lookahead (char const *reduction)
{
  printf ("%s:\n  yychar=", reduction);
  if (yychar == YYEMPTY)
    printf ("YYEMPTY");
  else if (yychar == YYEOF)
    printf ("YYEOF");
  else
    {
      printf ("'%c', yylval='", yychar);
      if (yylval.value > ' ')
	printf ("%c", yylval.value);
      printf ("', yylloc=(%d,%d),(%d,%d)",
	      yylloc.first_line, yylloc.first_column,
	      yylloc.last_line, yylloc.last_column);
    }
  printf ("\n");
}

static char
merge (union YYSTYPE s1, union YYSTYPE s2)
{
  char dummy = s1.value + s2.value;
  return dummy;
}

int
main (void)
{
  yychar = '#'; /* Not a token in the grammar.  */
  yylval.value = '!';
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1457: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr14.c glr-regr14.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:1457"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr14.c glr-regr14.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1457"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:1457: bison --xml=xml-tests/test.xml -o glr-regr14.c glr-regr14.y"
at_fn_check_prepare_trace "glr-regression.at:1457"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr14.c glr-regr14.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1457"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1457: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1457"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1457"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1457: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1457"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1457"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:1457: bison -o glr-regr14.c glr-regr14.y"
at_fn_check_prepare_trace "glr-regression.at:1457"
( $at_check_trace; bison -o glr-regr14.c glr-regr14.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr14.y: conflicts: 3 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1457"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:1460: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr14 glr-regr14.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr14 glr-regr14.c $LIBS" "glr-regression.at:1460"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr14 glr-regr14.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1460"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:1462:  \$PREPARSER ./glr-regr14"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr14" "glr-regression.at:1462"
( $at_check_trace;  $PREPARSER ./glr-regr14
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "conflict <- empty string:
  yychar='a', yylval='A', yylloc=(1,1),(1,1)
defstate_look <- empty string:
  yychar='a', yylval='A', yylloc=(1,1),(1,1)
nonconflict2 <- empty string:
  yychar='b', yylval='B', yylloc=(1,2),(1,2)
defstate_shift <- empty string:
  yychar=YYEMPTY
merge <- conflict defstate_look 'a' nonconflict2 'b' defstate_shift:
  yychar=YYEMPTY
start <- merge 'c' stack_explosion:
  yychar=YYEOF
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1462"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_301
#AT_START_302
at_fn_group_banner 302 'glr-regression.at:1484' \
  "Leaked semantic values when reporting ambiguity" "" 22
at_xfail=no
(
  $as_echo "302. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >glr-regr15.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%glr-parser
%destructor { parent_rhs_before_value = 0; } parent_rhs_before

%{
# include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  static int parent_rhs_before_value = 0;
# define USE(val)
%}

%%

start:
  alt1 %dprec 1
  | alt2 %dprec 2
  ;

/* This stack must be merged into the other stacks *last* (added at the
   beginning of the semantic options list) so that yyparse will choose to clean
   it up rather than the tree for which some semantic actions have been
   performed.  Thus, if yyreportAmbiguity longjmp's to yyparse, the values from
   those other trees are not cleaned up.  */
alt1: ;

alt2:
  parent_rhs_before ambiguity {
    USE ($1);
    parent_rhs_before_value = 0;
  }
  ;

parent_rhs_before:
  {
    USE ($$);
    parent_rhs_before_value = 1;
  }
  ;

ambiguity: ambiguity1 | ambiguity2 ;
ambiguity1: ;
ambiguity2: ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

int
main (void)
{
  int exit_status = yyparse () != 1;
  if (parent_rhs_before_value)
    {
      fprintf (stderr, "`parent_rhs_before' destructor not called.\n");
      exit_status = 1;
    }
  return exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1561: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr15.c glr-regr15.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:1561"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr15.c glr-regr15.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1561"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:1561: bison --xml=xml-tests/test.xml -o glr-regr15.c glr-regr15.y"
at_fn_check_prepare_trace "glr-regression.at:1561"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr15.c glr-regr15.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1561"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1561: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1561"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1561"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1561: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1561"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1561"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:1561: bison -o glr-regr15.c glr-regr15.y"
at_fn_check_prepare_trace "glr-regression.at:1561"
( $at_check_trace; bison -o glr-regr15.c glr-regr15.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr15.y: conflicts: 2 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1561"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:1564: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr15 glr-regr15.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr15 glr-regr15.c $LIBS" "glr-regression.at:1564"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr15 glr-regr15.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1564"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:1566:  \$PREPARSER ./glr-regr15"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr15" "glr-regression.at:1566"
( $at_check_trace;  $PREPARSER ./glr-regr15
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax is ambiguous
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1566"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_302
#AT_START_303
at_fn_group_banner 303 'glr-regression.at:1577' \
  "Leaked lookahead after nondeterministic parse syntax error" "" 22
at_xfail=no
(
  $as_echo "303. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >glr-regr16.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%glr-parser
%destructor { lookahead_value = 0; } 'b'

%{
# include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  static int lookahead_value = 0;
# define USE(val)
%}

%%

start: alt1 'a' | alt2 'a' ;
alt1: ;
alt2: ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static char const input[] = "ab";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  if (input[toknum] == 'b')
    lookahead_value = 1;
  return input[toknum++];
}

int
main (void)
{
  int exit_status = yyparse () != 1;
  if (lookahead_value)
    {
      fprintf (stderr, "Lookahead destructor not called.\n");
      exit_status = 1;
    }
  return exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1630: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr16.c glr-regr16.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:1630"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr16.c glr-regr16.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1630"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:1630: bison --xml=xml-tests/test.xml -o glr-regr16.c glr-regr16.y"
at_fn_check_prepare_trace "glr-regression.at:1630"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr16.c glr-regr16.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1630"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1630: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1630"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1630"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1630: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1630"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1630"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:1630: bison -o glr-regr16.c glr-regr16.y"
at_fn_check_prepare_trace "glr-regression.at:1630"
( $at_check_trace; bison -o glr-regr16.c glr-regr16.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr16.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1630"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:1633: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr16 glr-regr16.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr16 glr-regr16.c $LIBS" "glr-regression.at:1633"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr16 glr-regr16.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1633"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:1635:  \$PREPARSER ./glr-regr16"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr16" "glr-regression.at:1635"
( $at_check_trace;  $PREPARSER ./glr-regr16
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1635"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_303
#AT_START_304
at_fn_group_banner 304 'glr-regression.at:1646' \
  "Uninitialized location when reporting ambiguity" "" 22
at_xfail=no
(
  $as_echo "304. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >glr-regr17.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%glr-parser
%locations
%define api.pure
%error-verbose

%union { int dummy; }

%{
  static void yyerror (YYLTYPE *, char const *);
  static int yylex (YYSTYPE *, YYLTYPE *);
%}

%initial-action {
  @$.first_line = 1;
  @$.first_column = 1;
  @$.last_line = 1;
  @$.last_column = 1;
}

%%

/* Tests the case of an empty RHS that has inherited the location of the
   previous nonterminal, which is unresolved.  That location is reported as the
   last position of the ambiguity.  */
start: ambig1 empty1 | ambig2 empty2 ;

/* Tests multiple levels of yyresolveLocations recursion.  */
ambig1: sub_ambig1 | sub_ambig2 ;
ambig2: sub_ambig1 | sub_ambig2 ;

/* Tests the case of a non-empty RHS as well as the case of an empty RHS that
   has inherited the initial location.  The empty RHS's location is reported as
   the first position in the ambiguity.  */
sub_ambig1: empty1 'a' 'b' ;
sub_ambig2: empty2 'a' 'b' ;
empty1: ;
empty2: ;

%%

static void
yyerror (YYLTYPE *locp, char const *msg)
{
  fprintf (stderr, "Error at %d.%d-%d.%d: %s.\n", locp->first_line,
	   locp->first_column, locp->last_line, locp->last_column, msg);
}

static int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static char const input[] = "ab";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  lvalp->dummy = 0;
  llocp->first_line = llocp->last_line = 2;
  llocp->first_column = toknum + 1;
  llocp->last_column = llocp->first_column + 1;
  return input[toknum++];
}

int
main (void)
{
  return yyparse () != 1;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1717: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr17.c glr-regr17.y"
at_fn_check_prepare_notrace 'an embedded newline' "glr-regression.at:1717"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr17.c glr-regr17.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1717"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/glr-regression.at:1717: bison --xml=xml-tests/test.xml -o glr-regr17.c glr-regr17.y"
at_fn_check_prepare_trace "glr-regression.at:1717"
( $at_check_trace; bison --xml=xml-tests/test.xml -o glr-regr17.c glr-regr17.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1717"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1717: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1717"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1717"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/glr-regression.at:1717: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "glr-regression.at:1717"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1717"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/glr-regression.at:1717: bison -o glr-regr17.c glr-regr17.y"
at_fn_check_prepare_trace "glr-regression.at:1717"
( $at_check_trace; bison -o glr-regr17.c glr-regr17.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr17.y: conflicts: 3 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1717"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/glr-regression.at:1720: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr17 glr-regr17.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr17 glr-regr17.c $LIBS" "glr-regression.at:1720"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr17 glr-regr17.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1720"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
$as_echo "$at_srcdir/glr-regression.at:1722:  \$PREPARSER ./glr-regr17"
at_fn_check_prepare_dynamic " $PREPARSER ./glr-regr17" "glr-regression.at:1722"
( $at_check_trace;  $PREPARSER ./glr-regr17
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "Error at 1.1-2.3: syntax is ambiguous.
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/glr-regression.at:1722"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_304
#AT_START_305
at_fn_group_banner 305 'glr-regression.at:1733' \
  "Missed %merge type warnings when LHS type is declared later" "" 22
at_xfail=no
(
  $as_echo "305. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >glr-regr18.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser

%{
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex ();
%}

%union {
  int type1;
  int type2;
  int type3;
}

%%

sym1: sym2 %merge<merge> { $$ = $1; } ;
sym2: sym3 %merge<merge> { $$ = $1; } ;
sym3: %merge<merge> { $$ = 0; } ;

%type <type1> sym1;
%type <type2> sym2;
%type <type3> sym3;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex ()
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF




{ set +x
$as_echo "$at_srcdir/glr-regression.at:1783: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o glr-regr18.c glr-regr18.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o glr-regr18.c glr-regr18.y" "glr-regression.at:1783"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o glr-regr18.c glr-regr18.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "glr-regr18.y:26.18-24: result type clash on merge function \`merge': <type2> != <type1>
glr-regr18.y:25.18-24: previous declaration
glr-regr18.y:27.13-19: result type clash on merge function \`merge': <type3> != <type2>
glr-regr18.y:26.18-24: previous declaration
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/glr-regression.at:1783"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_305
#AT_START_306
at_fn_group_banner 306 'push.at:24' \
  "Memory Leak for Early Deletion" "                 " 23
at_xfail=no
(
  $as_echo "306. $at_setup_line: testing $at_desc ..."
  $at_traceon


# Requires Valgrind.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <assert.h>
  #include <stdio.h>
  #define YYINITDEPTH 1
  void yyerror (char const *msg);
%}

%define api.pure %define api.push-pull push

%%

start: 'a' 'b' 'c' ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yypstate *ps;

  /* Make sure we don't try to free ps->yyss in this case.  */
  ps = yypstate_new ();
  yypstate_delete (ps);

  /* yypstate_delete used to leak ps->yyss if the stack was reallocated but the
     parse did not return on success, syntax error, or memory exhaustion.  */
  ps = yypstate_new ();
  assert (yypush_parse (ps, 'a', NULL) == YYPUSH_MORE);
  yypstate_delete (ps);

  ps = yypstate_new ();
  assert (yypush_parse (ps, 'a', NULL) == YYPUSH_MORE);
  assert (yypush_parse (ps, 'b', NULL) == YYPUSH_MORE);
  yypstate_delete (ps);

  return 0;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/push.at:75: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "push.at:75"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/push.at:75"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/push.at:75: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "push.at:75"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/push.at:75"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/push.at:75: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "push.at:75"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:75"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/push.at:75: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "push.at:75"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:75"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/push.at:75: bison -o input.c input.y"
at_fn_check_prepare_trace "push.at:75"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:75"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/push.at:76: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "push.at:76"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/push.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/push.at:77:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "push.at:77"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:77"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_306
#AT_START_307
at_fn_group_banner 307 'push.at:85' \
  "Multiple impure instances" "                      " 23
at_xfail=no
(
  $as_echo "307. $at_setup_line: testing $at_desc ..."
  $at_traceon





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <assert.h>
  #include <stdio.h>
  void yyerror (char const *msg);
  int yylex (void);
%}

%define api.push-pull both

%%

start: ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  return 0;
}

int
main (void)
{
  yypstate *ps;
  int i;

  for (i = 0; i < 2; ++i)
    {
      ps = yypstate_new ();
      assert (ps);
      assert (yypstate_new () == NULL);
      assert (yyparse () == 2);
      yychar = 0;
      assert (yypush_parse (ps) == 0);
      assert (yypstate_new () == NULL);
      assert (yyparse () == 2);
      yypstate_delete (ps);
    }

  return 0;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/push.at:145: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "push.at:145"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/push.at:145"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/push.at:145: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "push.at:145"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/push.at:145"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/push.at:145: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "push.at:145"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:145"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/push.at:145: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "push.at:145"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:145"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/push.at:145: bison -o input.c input.y"
at_fn_check_prepare_trace "push.at:145"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:145"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/push.at:145: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "push.at:145"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/push.at:145"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/push.at:145:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "push.at:145"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:145"
$at_failed && at_fn_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <assert.h>
  #include <stdio.h>
  void yyerror (char const *msg);
  int yylex (void);
%}

%define api.push-pull push

%%

start: ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  return 0;
}

int
main (void)
{
  yypstate *ps;
  int i;

  for (i = 0; i < 2; ++i)
    {
      ps = yypstate_new ();
      assert (ps);
      assert (yypstate_new () == NULL);
      ;
      yychar = 0;
      assert (yypush_parse (ps) == 0);
      assert (yypstate_new () == NULL);
      ;
      yypstate_delete (ps);
    }

  return 0;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { set +x
$as_echo "$at_srcdir/push.at:146: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
at_fn_check_prepare_notrace 'an embedded newline' "push.at:146"
( $at_check_trace; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/push.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  { set +x
$as_echo "$at_srcdir/push.at:146: bison --xml=xml-tests/test.xml -o input.c input.y"
at_fn_check_prepare_trace "push.at:146"
( $at_check_trace; bison --xml=xml-tests/test.xml -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/push.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { set +x
$as_echo "$at_srcdir/push.at:146: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "push.at:146"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { set +x
$as_echo "$at_srcdir/push.at:146: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
at_fn_check_prepare_notrace 'a `...` command substitution' "push.at:146"
( $at_check_trace; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ set +x
$as_echo "$at_srcdir/push.at:146: bison -o input.c input.y"
at_fn_check_prepare_trace "push.at:146"
( $at_check_trace; bison -o input.c input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/push.at:146: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
at_fn_check_prepare_dynamic "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS" "push.at:146"
( $at_check_trace; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/push.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/push.at:146:  \$PREPARSER ./input"
at_fn_check_prepare_dynamic " $PREPARSER ./input" "push.at:146"
( $at_check_trace;  $PREPARSER ./input
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/push.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }





  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_307
#AT_START_308
at_fn_group_banner 308 'push.at:156' \
  "Unsupported Skeletons" "                          " 23
at_xfail=no
(
  $as_echo "308. $at_setup_line: testing $at_desc ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%glr-parser
%define api.push-pull push
%%
start: ;
_ATEOF



{ set +x
$as_echo "$at_srcdir/push.at:165: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
at_fn_check_prepare_dynamic "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y" "push.at:165"
( $at_check_trace; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo >>"$at_stderr"; $as_echo "input.y:2.9-21: %define variable \`api.push-pull' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/push.at:165"
$at_failed && at_fn_log_failure
$at_traceon; }


  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_308
