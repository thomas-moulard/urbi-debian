// This file is autogenerated from cxx-primitive.hxx.py -- Do not modify

#include <boost/bind.hpp>
#include <boost/tr1/type_traits.hpp>

#include <urbi/object/any-to-boost-function.hh>
#include <urbi/object/cxx-conversions.hh>
#include <urbi/object/cxx-primitive.hh>
#include <urbi/object/primitive.hh>

namespace urbi
{
  namespace object
  {
    template <typename M>
    struct MakePrimitive
    {};

    namespace
    {
      // Remove const and reference
      template <typename T>
      struct Flatten
      {
        typedef typename boost::remove_const
        <typename boost::remove_reference<T>::type>::type type;
      };
    }

  
    // Return: True, Arguments: -1
    template <typename R>
    struct MakePrimitive<boost::function0<R> >
    {
      static rObject primitive(const object::objects_type& ,
                               boost::function0<R>  f)
      {
        
        return CxxConvert<typename Flatten<R>::type>::from
        (f());
        
      }
    };
    
    // Return: True, Arguments: 0
    template <typename R, typename S>
    struct MakePrimitive<boost::function1<R, S> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function1<R, S>  f)
      {
        check_arg_count(args.size() - 1, 0);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0)));
        
      }
    };
    
    // Return: True, Arguments: 1
    template <typename R, typename S, typename Arg0>
    struct MakePrimitive<boost::function2<R, S, Arg0> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function2<R, S, Arg0>  f)
      {
        check_arg_count(args.size() - 1, 1);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0),
           CxxConvert<typename Flatten<Arg0>::type>::to(args[1], 1)));
        
      }
    };
    
    // Return: True, Arguments: 2
    template <typename R, typename S, typename Arg0, typename Arg1>
    struct MakePrimitive<boost::function3<R, S, Arg0, Arg1> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function3<R, S, Arg0, Arg1>  f)
      {
        check_arg_count(args.size() - 1, 2);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0),
           CxxConvert<typename Flatten<Arg0>::type>::to(args[1], 1),
           CxxConvert<typename Flatten<Arg1>::type>::to(args[2], 2)));
        
      }
    };
    
    // Return: True, Arguments: 3
    template <typename R, typename S, typename Arg0, typename Arg1, typename Arg2>
    struct MakePrimitive<boost::function4<R, S, Arg0, Arg1, Arg2> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function4<R, S, Arg0, Arg1, Arg2>  f)
      {
        check_arg_count(args.size() - 1, 3);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0),
           CxxConvert<typename Flatten<Arg0>::type>::to(args[1], 1),
           CxxConvert<typename Flatten<Arg1>::type>::to(args[2], 2),
           CxxConvert<typename Flatten<Arg2>::type>::to(args[3], 3)));
        
      }
    };
    
    // Return: True, Arguments: 4
    template <typename R, typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
    struct MakePrimitive<boost::function5<R, S, Arg0, Arg1, Arg2, Arg3> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function5<R, S, Arg0, Arg1, Arg2, Arg3>  f)
      {
        check_arg_count(args.size() - 1, 4);
        return CxxConvert<typename Flatten<R>::type>::from
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0),
           CxxConvert<typename Flatten<Arg0>::type>::to(args[1], 1),
           CxxConvert<typename Flatten<Arg1>::type>::to(args[2], 2),
           CxxConvert<typename Flatten<Arg2>::type>::to(args[3], 3),
           CxxConvert<typename Flatten<Arg3>::type>::to(args[4], 4)));
        
      }
    };
    
    // Return: True, Method: True
    template <typename R, typename S>
    struct MakePrimitive<boost::function2<R, S, const object::objects_type&> >
    {
      static rObject primitive(
        const object::objects_type& args,
        boost::function2<R, S, const object::objects_type&>  f)
      {
        S tgt = CxxConvert<S>::to(args[0], 0);
        object::objects_type new_args = args;
        libport::pop_front(new_args);
        return CxxConvert<typename Flatten<R>::type>::from(f(tgt, new_args));
        
      }
    };
    
    // Return: True, Method: False
    template <typename R>
    struct MakePrimitive<boost::function1<R, const object::objects_type&> >
    {
      static rObject primitive(
        const object::objects_type& args,
        boost::function1<R, const object::objects_type&>  f)
      {
        
        return CxxConvert<typename Flatten<R>::type>::from(f(args));
        
      }
    };
    
    // Return: False, Arguments: -1
    template <>
    struct MakePrimitive<boost::function0<void> >
    {
      static rObject primitive(const object::objects_type& ,
                               boost::function0<void>  f)
      {
        
        
        (f());
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 0
    template <typename S>
    struct MakePrimitive<boost::function1<void, S> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function1<void, S>  f)
      {
        check_arg_count(args.size() - 1, 0);
        
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 1
    template <typename S, typename Arg0>
    struct MakePrimitive<boost::function2<void, S, Arg0> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function2<void, S, Arg0>  f)
      {
        check_arg_count(args.size() - 1, 1);
        
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0),
           CxxConvert<typename Flatten<Arg0>::type>::to(args[1], 1)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 2
    template <typename S, typename Arg0, typename Arg1>
    struct MakePrimitive<boost::function3<void, S, Arg0, Arg1> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function3<void, S, Arg0, Arg1>  f)
      {
        check_arg_count(args.size() - 1, 2);
        
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0),
           CxxConvert<typename Flatten<Arg0>::type>::to(args[1], 1),
           CxxConvert<typename Flatten<Arg1>::type>::to(args[2], 2)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 3
    template <typename S, typename Arg0, typename Arg1, typename Arg2>
    struct MakePrimitive<boost::function4<void, S, Arg0, Arg1, Arg2> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function4<void, S, Arg0, Arg1, Arg2>  f)
      {
        check_arg_count(args.size() - 1, 3);
        
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0),
           CxxConvert<typename Flatten<Arg0>::type>::to(args[1], 1),
           CxxConvert<typename Flatten<Arg1>::type>::to(args[2], 2),
           CxxConvert<typename Flatten<Arg2>::type>::to(args[3], 3)));
        return object::void_class;
      }
    };
    
    // Return: False, Arguments: 4
    template <typename S, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
    struct MakePrimitive<boost::function5<void, S, Arg0, Arg1, Arg2, Arg3> >
    {
      static rObject primitive(const object::objects_type& args,
                               boost::function5<void, S, Arg0, Arg1, Arg2, Arg3>  f)
      {
        check_arg_count(args.size() - 1, 4);
        
        (f(CxxConvert<typename Flatten<S>::type>::to(args[0], 0),
           CxxConvert<typename Flatten<Arg0>::type>::to(args[1], 1),
           CxxConvert<typename Flatten<Arg1>::type>::to(args[2], 2),
           CxxConvert<typename Flatten<Arg2>::type>::to(args[3], 3),
           CxxConvert<typename Flatten<Arg3>::type>::to(args[4], 4)));
        return object::void_class;
      }
    };
    
    // Return: False, Method: True
    template <typename S>
    struct MakePrimitive<boost::function2<void, S, const object::objects_type&> >
    {
      static rObject primitive(
        const object::objects_type& args,
        boost::function2<void, S, const object::objects_type&>  f)
      {
        S tgt = CxxConvert<S>::to(args[0], 0);
        object::objects_type new_args = args;
        libport::pop_front(new_args);
        (f(tgt, new_args));
        return object::void_class;
      }
    };
    
    // Return: False, Method: False
    template <>
    struct MakePrimitive<boost::function1<void, const object::objects_type&> >
    {
      static rObject primitive(
        const object::objects_type& args,
        boost::function1<void, const object::objects_type&>  f)
      {
        
        (f(args));
        return object::void_class;
      }
    };
    ;

    template<typename M>
    inline rPrimitive
    make_primitive(M f)
    {
      typedef AnyToBoostFunction<M> C;
      // If primitive is unfound in MakePrimitive here, you gave an
      // unsupported type to make Primitive. AnyToBoostFunction must be
      // able to convert the given values. It handles:
      // * boost::functions
      // * function pointers
      // * method pointers
      return new Primitive(
        boost::bind(MakePrimitive<typename C::type>::primitive,
                    _1, /*_2,*/ C::convert(f)));
    }

    template<typename M>
    inline void
    extend_primitive(rPrimitive p, M f)
    {
      typedef AnyToBoostFunction<M> C;
      p->value_get() <<
        boost::bind(MakePrimitive<typename C::type>::primitive,
                    _1, /*_2,*/ C::convert(f));
    }


    inline void
    setter_bouncer(rObject self,
                   const std::string&, rObject value, const std::string& name)
    {
      self->call(name, value);
    }

    template <typename F1, typename F2>
    inline void
    Object::bind(const std::string& getter_name, F1 getter,
                 const std::string& setter_name, F2 setter)
    {
      slot_set(libport::Symbol(getter_name), make_primitive(getter));
      slot_set(libport::Symbol(setter_name), make_primitive(setter));
      boost::function3<void, rObject, const std::string&, rObject>
        f(boost::bind(&setter_bouncer, _1, _2, _3, setter_name));
      setProperty(getter_name, "updateHook", make_primitive(f));
    }
  }
}
