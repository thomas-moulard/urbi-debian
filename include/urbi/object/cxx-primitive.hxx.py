#! /usr/bin/python

def iif(cond, iftrue, iffalse):
    if cond:
        return iftrue
    else:
        return iffalse

## ----------- ##
## Boost types ##
## ----------- ##

def boost_param(r, nargs):

    args = []
    if r:
        args += ['R']
    else:
        args += ['void']
    if nargs != -1:
        args += 'S'
    for i in range(nargs):
        args += ['Arg%s' % i]
    return args


def boost_function(args):

    # Leave trailing space to avoid outputting '>>'
    return 'boost::function%s<%s> ' % (len(args) - 1, ', '.join(args))


def boost_type(r, nargs):

    args = boost_param(r, nargs)
    return boost_function(args)


def boost_list_type(r, met):

    args = boost_param(r, 0)
    if not met:
        args = args[:-1]
    args += ['const object::objects_type&']
    return boost_function(args)


def primitive(r, nargs):

    ## HELPERS ##

    # Convert argument n from Urbi to type
    def to(n, type):
        return 'CxxConvert<typename Flatten<%s>::type>::to(args[%s], %s)'\
               % (type, n, n)

    # Convert argument n from type to Urbi
    def fr(n, type):
        return 'CxxConvert<typename Flatten<%s>::type>::from(args[%s], %s)'\
               % (type, n, n)

    def make_arg(n):
        return to(n + 1, 'Arg%s' % n)

    # Generate template parameters list
    def template_param(r, nargs):

        def add_typename(arg):
            return 'typename %s' % arg

        args = []
        if r:
            args += ['R']
        if nargs != -1:
            args += ['S']
        for i in range(nargs):
            args += ['Arg%s' % i]
        args = map(add_typename, args)
        return ', '.join(args)

    # Generate the list of effective arguments for the wrapped function
    # as a possibly empty string.
    def arguments(nargs):
        if nargs != -1:
            args = [to(0, 'S')] + map(make_arg, range(nargs))
            return ',\n           '.join(args)
        else:
            return ''

    if r:
        r = 'return CxxConvert<typename Flatten<R>::type>::from'
        r_void = ''
    else:
        r = ''
        r_void = 'return object::void_class;'

    return '''\
    template <%(param)s>
    struct MakePrimitive<%(boost)s>
    {
      static rObject primitive(const object::objects_type& %(args_name)s,
                               %(boost)s f)
      {
        %(check)s
        %(return)s
        (f(%(args)s));
        %(return_void)s
      }
    };
    ''' % {
        'args': arguments(nargs),
        'args_name': iif(nargs != -1, 'args', ''),
        'boost': boost_type(r, nargs),
        'check': iif(nargs != -1,
                     'check_arg_count(args.size() - 1, %s);' % nargs,
                     ''),
        'nargs': nargs,
        'param': template_param(r, nargs),
        'return': r,
        'return_void': r_void,
        'self': to(0, 'S'),
        }


def primitive_list(r, met):

    params = []
    if r:
        params += ['typename R']
        r = 'return CxxConvert<typename Flatten<R>::type>::from'
        r_void = ''
    else:
        r = ''
        r_void = 'return object::void_class;'
    if met:
        params += ['typename S']
    params = ', '.join(params)
    if met:
        target_get =  'S tgt = CxxConvert<S>::to(args[0], 0);\n'
        target_get += '        object::objects_type new_args = args;\n'
        target_get += '        libport::pop_front(new_args);'
        target = 'tgt, '
        args_name = 'new_args'
    else:
        target_get = ''
        target = ''
        args_name = 'args'
    return '''\
    template <%(params)s>
    struct MakePrimitive<%(boost)s>
    {
      static rObject primitive(
        const object::objects_type& args,
        %(boost)s f)
      {
        %(target_get)s
        %(return)s(f(%(target)s%(args)s));
        %(return_void)s
      }
    };
    ''' % {
        'args': args_name,
        'boost': boost_list_type(r, met),
        'params': params,
        'return': r,
        'return_void': r_void,
        'target': target,
        'target_get': target_get,
        }


# print primitive(True, True, 3)
# print primitive_list(True, True, False)
# print primitive_list(True, True, True)

primitives = ''

for ret in [True, False]:
    # nargs counts "this".  -1 means there is not even a this.
    for nargs in [-1] + range(5):
        primitives += '\n    // Return: %s, Arguments: %s\n' % (ret, nargs)
        primitives += primitive(ret, nargs)
    for met in [True, False]:
        primitives += '\n    // Return: %s, Method: %s\n' % (ret, met)
        primitives += primitive_list(ret, met)

print '''// This file is autogenerated from cxx-primitive.hxx.py -- Do not modify

#include <boost/bind.hpp>
#include <boost/tr1/type_traits.hpp>

#include <urbi/object/any-to-boost-function.hh>
#include <urbi/object/cxx-conversions.hh>
#include <urbi/object/cxx-primitive.hh>
#include <urbi/object/primitive.hh>

namespace urbi
{
  namespace object
  {
    template <typename M>
    struct MakePrimitive
    {};

    namespace
    {
      // Remove const and reference
      template <typename T>
      struct Flatten
      {
        typedef typename boost::remove_const
        <typename boost::remove_reference<T>::type>::type type;
      };
    }

  %s;

    template<typename M>
    inline rPrimitive
    make_primitive(M f)
    {
      typedef AnyToBoostFunction<M> C;
      // If primitive is unfound in MakePrimitive here, you gave an
      // unsupported type to make Primitive. AnyToBoostFunction must be
      // able to convert the given values. It handles:
      // * boost::functions
      // * function pointers
      // * method pointers
      return new Primitive(
        boost::bind(MakePrimitive<typename C::type>::primitive,
                    _1, /*_2,*/ C::convert(f)));
    }

    template<typename M>
    inline void
    extend_primitive(rPrimitive p, M f)
    {
      typedef AnyToBoostFunction<M> C;
      p->value_get() <<
        boost::bind(MakePrimitive<typename C::type>::primitive,
                    _1, /*_2,*/ C::convert(f));
    }


    inline void
    setter_bouncer(rObject self,
                   const std::string&, rObject value, const std::string& name)
    {
      self->call(name, value);
    }

    template <typename F1, typename F2>
    inline void
    Object::bind(const std::string& getter_name, F1 getter,
                 const std::string& setter_name, F2 setter)
    {
      slot_set(libport::Symbol(getter_name), make_primitive(getter));
      slot_set(libport::Symbol(setter_name), make_primitive(setter));
      boost::function3<void, rObject, const std::string&, rObject>
        f(boost::bind(&setter_bouncer, _1, _2, _3, setter_name));
      setProperty(getter_name, "updateHook", make_primitive(f));
    }
  }
}''' % primitives
